<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<title>Die wunderbare Welt von Isotopp - Die InnoDB Storage Engine</title>
<meta name="description" content="">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="manifest" href="site.webmanifest">
<link rel="apple-touch-icon" href="icon.png">
<link rel="favicon.ico" rel="icon" type="image/ico">





	



<link rel="stylesheet" href="/style.min.c5e5cd61f54911f9aafd1dbe09c2f90667957bfe1002126c87aace57759f3446.css">


    </head>
    <body>
        

        <nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container-fluid">
	<a class="navbar-brand" href="" rel="home" title=".Site.Title">
	    Die wunderbare Welt von Isotopp
	</a>
	<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
	</button>

	<div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
		
		
		<li class="nav-item ">
                    <a class="nav-link" href="/about/">
			
			<span>About</span>
			<span class="visually-hidden">(Current)</span>
		    </a>
		    
		</li>
            </ul>
            
	</div>
    </div>
</nav>


        <main role="main" class="container-fluid">

            


<div class="page">
    <article class="die-innodb-storage-engine-page">
	<h1 class="title">
            Die InnoDB Storage Engine
	</h1>

	<p>Die Storage Engine InnoDB ist eine Storage Engine, die ACID-konform
betrieben werden kann, Transaktionen beherrscht und Foreign Key Constraints
prüfen kann. Sie ist geeignet für alle Anwendungen, die Online Transaction
Processing machen oder aus anderen Gründen eine hohe Rate von paralellen
Schreibzugriffen haben.</p>
<h3 id="hat-mein-mysql-innodb-support-und-ist-dieser-betriebsbereit">
    <a href="#hat-mein-mysql-innodb-support-und-ist-dieser-betriebsbereit">
	Hat mein MySQL InnoDB Support und ist dieser betriebsbereit?
    </a>
</h3>
<p>Mit dem Kommano <code>SHOW ENGINES</code> kann man sich die von einer Instanz
unterstützten Engines anzeigen lassen. Wenn InnoDB enthalten und
betriebsbereit ist, wird die Engine mit <code>YES</code> angezeigt. Wenn sie enthalten
und nicht betriebsbereit ist, wird <code>DISABLED</code> gezeigt. Wenn sie nicht einmal
im Code des Servers enthalten ist, wird <code>NO</code> gezeigt.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">root <span style="color:#66d9ef">on</span> mysql.sock [(<span style="color:#66d9ef">none</span>)]<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">show</span> engines;
<span style="color:#f92672">+</span><span style="color:#75715e">------------+---------+----------------------------------------------------------------+
</span><span style="color:#75715e"></span><span style="color:#f92672">|</span> Engine     <span style="color:#f92672">|</span> Support <span style="color:#f92672">|</span> <span style="color:#66d9ef">Comment</span>                                                        <span style="color:#f92672">|</span>
<span style="color:#f92672">+</span><span style="color:#75715e">------------+---------+----------------------------------------------------------------+
</span><span style="color:#75715e"></span><span style="color:#f92672">|</span> MyISAM     <span style="color:#f92672">|</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">Default</span> engine <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">of</span> MySQL <span style="color:#ae81ff">3</span>.<span style="color:#ae81ff">23</span> <span style="color:#66d9ef">with</span> great performance         <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> MEMORY     <span style="color:#f92672">|</span> YES     <span style="color:#f92672">|</span> Hash based, stored <span style="color:#66d9ef">in</span> memory, useful <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">temporary</span> tables      <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> InnoDB     <span style="color:#f92672">|</span> YES     <span style="color:#f92672">|</span> Supports transactions, <span style="color:#66d9ef">row</span><span style="color:#f92672">-</span><span style="color:#66d9ef">level</span> locking, <span style="color:#66d9ef">and</span> <span style="color:#66d9ef">foreign</span> keys     <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> BerkeleyDB <span style="color:#f92672">|</span> <span style="color:#66d9ef">NO</span>      <span style="color:#f92672">|</span> Supports transactions <span style="color:#66d9ef">and</span> page<span style="color:#f92672">-</span><span style="color:#66d9ef">level</span> locking                   <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> BLACKHOLE  <span style="color:#f92672">|</span> YES     <span style="color:#f92672">|</span> <span style="color:#f92672">/</span>dev<span style="color:#f92672">/</span><span style="color:#66d9ef">null</span> <span style="color:#66d9ef">storage</span> engine (anything you <span style="color:#66d9ef">write</span> <span style="color:#66d9ef">to</span> it disappears) <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> EXAMPLE    <span style="color:#f92672">|</span> YES     <span style="color:#f92672">|</span> Example <span style="color:#66d9ef">storage</span> engine                                         <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> ARCHIVE    <span style="color:#f92672">|</span> YES     <span style="color:#f92672">|</span> Archive <span style="color:#66d9ef">storage</span> engine                                         <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> CSV        <span style="color:#f92672">|</span> YES     <span style="color:#f92672">|</span> CSV <span style="color:#66d9ef">storage</span> engine                                             <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> ndbcluster <span style="color:#f92672">|</span> <span style="color:#66d9ef">NO</span>      <span style="color:#f92672">|</span> Clustered, fault<span style="color:#f92672">-</span>tolerant, memory<span style="color:#f92672">-</span>based tables                 <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> FEDERATED  <span style="color:#f92672">|</span> YES     <span style="color:#f92672">|</span> Federated MySQL <span style="color:#66d9ef">storage</span> engine                                 <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> MRG_MYISAM <span style="color:#f92672">|</span> YES     <span style="color:#f92672">|</span> Collection <span style="color:#66d9ef">of</span> identical MyISAM tables                          <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> ISAM       <span style="color:#f92672">|</span> <span style="color:#66d9ef">NO</span>      <span style="color:#f92672">|</span> Obsolete <span style="color:#66d9ef">storage</span> engine                                        <span style="color:#f92672">|</span>
<span style="color:#f92672">+</span><span style="color:#75715e">------------+---------+----------------------------------------------------------------+
</span><span style="color:#75715e"></span><span style="color:#ae81ff">12</span> <span style="color:#66d9ef">rows</span> <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">set</span> (<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span> sec)
</code></pre></div><h3 id="eine-minimale-konfiguration-für-innodb">
    <a href="#eine-minimale-konfiguration-f%c3%bcr-innodb">
	Eine minimale Konfiguration für InnoDB
    </a>
</h3>
<p>Für die folgenden Beispiele ist es notwendig, daß der MySQL-Server mit einem
funktionierenden InnoDB ausgestattet ist. Die folgende Minimal-Konfiguration
ist nicht für die Produktion geeignet, sollte aber ausreichen um von
<code>DISABLED</code> auf <code>YES</code> zu kommen.</p>
<ul>
<li>Mit <code>SHOW GLOBAL VARIABLES LIKE 'datadir'</code> ist das Datenverzeichnis für diese
Instanz von MySQL zu lokalisieren. In diesem Verzeichnis befinden sich
unter Umständen ein Datenfile <code>ibdata1</code> und zwei Logfiles, <code>ib_logfile0</code> und
<code>ib_logfile1.</code></li>
</ul>
<pre><code class="language-console" data-lang="console">root on mysql.sock [(none)]&gt; show global variables like 'datadir';
+---------------+------------------------------+
| Variable_name | Value                        |
+---------------+------------------------------+
| datadir       | /export/data/rootforum/data/ |
+---------------+------------------------------+
1 row in set (0.00 sec)
root on mysql.sock [(none)]&gt; quit
Bye
linux:/export/data/rootforum # ls -lh /export/data/rootforum/data/ib\*
-rw-rw---- 1 mysql mysql   5M Jan  9 17:51 /export/data/rootforum/data/ib_logfile0
-rw-rw---- 1 mysql mysql   5M Jan  9 17:51 /export/data/rootforum/data/ib_logfile1
-rw-rw---- 1 mysql mysql  10M Dec 13 14:34 /export/data/rootforum/data/ibdata1
</code></pre><ul>
<li>
<p>Der Datenbankserver ist zu stoppen. - Die o.a. drei Files sind, wenn
vorhanden, zu löschen. <strong>WARNUNG!</strong> Dies löscht alle evtl. bereits
vorhandenen Daten in InnoDB. Diesen Schritt nur dann durchführen, wenn die
Engine vorher DISABLED war.</p>
</li>
<li>
<p>In der Sektion [mysqld] der my.cnf ist die Anweisung skip-innodb zu
finden, wenn vorhanden, und zu entfernen.</p>
</li>
<li>
<p>Die folgenden Konfigurationsanweisungen sind stattdessen einzufügen. Ihre
Bedeutung wird weiter unten erläutert.</p>
</li>
</ul>
<pre><code class="language-console" data-lang="console">innodb
innodb_file_per_table = 1
innodb_flush_log_at_trx_commit = 2
</code></pre><ul>
<li>
<p>Dies ist ein minimales Setup, das zum Testen geeignet ist, aber keine
Performance bringen wird. Später gehen wir auch auf InnoDB Performance
Tuning ein.</p>
</li>
<li>
<p>Der Server ist zu starten. Er legt die o.a. drei Files
neu an, und hinterläßt entsprechende Nachrichten im Log. Die Engine InnoDB
wird in <code>SHOW ENGINES</code> jetzt mit <code>YES</code> angezeigt.</p>
</li>
</ul>
<h3 id="innodb-tabellen-anlegen">
    <a href="#innodb-tabellen-anlegen">
	InnoDB Tabellen anlegen
    </a>
</h3>
<p>Beim Anlegen einer Tabellenspezifikation kann durch das Nachstellen einer
ENGINE-Klausel festgelegt werden, mit welcher Storage Engine die Tabelle
erzeugt wird. Dies kann innerhalb eines Schemas für jede Tabelle getrennt
festgelegt werden, und mit Hilfe von <code>ALTER TABLE</code> auch nachträglich ohne
Datenverlust geändert werden.</p>
<pre><code class="language-console" data-lang="console">root on mysql.sock [(none)]&gt; create database innodemo;
Query OK, 1 row affected (0.32 sec)

root on mysql.sock [(none)]&gt; use innodemo;
Database changed
root on mysql.sock [innodemo]&gt; create table kris ( 
  id integer unsigned not null primary key auto_increment, 
  d varchar(20) not null 
) engine = innodb;
Query OK, 0 rows affected (0.36 sec)

root on mysql.sock [innodemo]&gt; insert into kris ( d ) values ( &quot;eins&quot;), (&quot;zwei&quot;), (&quot;drei&quot;);
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

root on mysql.sock [innodemo]&gt; select * from kris;
+----+------+
| id | d    |
+----+------+
|  1 | eins |
|  2 | zwei |
|  3 | drei |
+----+------+
3 rows in set (0.01 sec)
</code></pre><p>Mit Hilfe des Kommando <code>SHOW CREATE TABLE</code> oder mit <code>SHOW TABLE STATUS</code> können
wir sehen, welche Storage Engine eine Tabelle verwendet.</p>
<pre><code class="language-console" data-lang="console">root on mysql.sock [innodemo]&gt; show create table kris\G
*************************** 1. row ***************************
       Table: kris
Create Table: CREATE TABLE `kris` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `d` varchar(20) NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8
1 row in set (0.00 sec)

root on mysql.sock [innodemo]&gt; show table status like &quot;kris&quot;\G
*************************** 1. row ***************************
           Name: kris
         Engine: InnoDB
        Version: 10
     Row_format: Compact
           Rows: 3
 Avg_row_length: 5461
    Data_length: 16384
Max_data_length: 0
   Index_length: 0
      Data_free: 0
 Auto_increment: 4
    Create_time: 2008-01-09 18:04:00
    Update_time: NULL
     Check_time: NULL
      Collation: utf8_general_ci
       Checksum: NULL
 Create_options:
        Comment: InnoDB free: 148480 kB
1 row in set (0.00 sec)
</code></pre><p>In der Ausgabe von <code>SHOW TABLE STATUS</code> sehen wir einige Besonderheiten: Erst
einmal ist die angezeigte Average Row Length von InnoDB-Tabellen mit sehr
wenigen Datensätzen ungültig. Die Average Row Length unserer Tabelle ist,
das wissen wir, ungefähr 4 (integer) + 5 (1 Längenbyte und vier
Zeichenbytes) plus ein wenig Verwaltungsoverhead (ca. 10-12 Byte pro Row).</p>
<p>InnoDB vergibt Speicherplatz jedoch in Seiten zu 16KB, und daher ist die
Data_length = 16384 Bytes. Die Average Row Length wird von InnoDB als
Statistik nicht gepflegt und an MySQL exportiert und wird daher als
Data_length/Rows geschätzt. Für kleine Anzahlen von Zeilen ist dieser Wert
falsch.</p>
<p>Außerdem können wir sehen, daß die Index_length für diese Tabelle 0 ist,
obwohl ein Primary Key definiert ist. Das wird uns später noch im Detail
beschäftigen. Für das erste genügt es zu wissen, das der Primary Key in
InnoDB zu den Daten gerechnet wird und auch sonst magisch ist. Data_free
ist, anders als in MyISAM, immer 0.</p>
<h3 id="existierende-tabellen-im-typ-ändern">
    <a href="#existierende-tabellen-im-typ-%c3%a4ndern">
	Existierende Tabellen im Typ ändern
    </a>
</h3>
<p>Mit den Kommando <code>ALTER TABLE</code> können wir eine existierende Tabelle von InnoDB
nach MyISAM umwandeln oder zurück. Daten gehen dabei nicht verloren. Zum
Vergleich hier einmal die Ausgabe von <code>SHOW TABLE STATUS</code> für dieselbe
Tabelle, wenn sie als MyISAM-Tabelle existiert. Man kann sehen, daß MyISAM
den Primary Key NICHT zu den Daten rechnet und daß MyISAM im Index ebenfalls
seitenbasiert arbeitet, nur sind die Seiten viel kleiner: Sie sind nur 1KB
groß.</p>
<pre><code class="language-console" data-lang="console">root on mysql.sock [innodemo]&gt; alter table kris engine=myisam;
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

root on mysql.sock [innodemo]&gt; select * from kris;
+----+------+
| id | d    |
+----+------+
|  1 | eins |
|  2 | zwei |
|  3 | drei |
+----+------+
3 rows in set (0.00 sec)

root on mysql.sock [innodemo]&gt; show table status like &quot;kris&quot;\G
*************************** 1. row ***************************
           Name: kris
         Engine: MyISAM
        Version: 10
     Row_format: Dynamic
           Rows: 3
 Avg_row_length: 20
    Data_length: 60
Max_data_length: 281474976710655
   Index_length: 2048
      Data_free: 0
 Auto_increment: 4
    Create_time: 2008-01-09 18:11:57
    Update_time: 2008-01-09 18:11:57
     Check_time: NULL
      Collation: utf8_general_ci
       Checksum: NULL
 Create_options:
        Comment:
1 row in set (0.00 sec)
</code></pre><p>Wir können unsere Tabelle auch wieder zurück nach InnoDB wandeln. Wir können
sogar eine existierende InnoDB-Tabelle nach InnoDB wandeln. Das macht sogar
Sinn - es ist genau das, was OPTIMIZE TABLE in InnoDB macht.</p>
<pre><code class="language-console" data-lang="console">root on mysql.sock [innodemo]&gt; alter table kris engine=innodb;
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

root on mysql.sock [innodemo]&gt; alter table kris engine=innodb;
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0

root on mysql.sock [innodemo]&gt; select * from kris;
+----+------+
| id | d    |
+----+------+
|  1 | eins |
|  2 | zwei |
|  3 | drei |
+----+------+
3 rows in set (0.00 sec)
</code></pre><p>Ein <code>ALTER TABLE t ENGINE=...</code> erzeugt eine Kopie der Tabelle mit der neuen
Engine als temporäre Tabelle. Danach wird die Originaltabelle gelöscht und
die temporäre Tabelle als permanente Tabelle installiert. Das hat eine Reihe
von Konsequenzen:</p>
<ul>
<li>Die Operation kann keine Daten verlieren. Wenn die Operation scheitert
oder durch Benutzer abgebrochen wird, wird die temporäre Tabelle gelöscht
und die Originaltabelle bleibt unverändert stehen.</li>
<li>Vorübergehend wird sehr viel mehr Speicher gebraucht, denn es müssen ja
beide Tabellen parallel existieren. Dabei ist zu beachten, daß InnoDB die
Daten weniger dicht packt als MyISAM. Eine InnoDB-Tabelle braucht etwa 1.6
bis 2.2 mal so viel Platz wie eine MyISAM-Tabelle.</li>
<li>Während des ALTER TABLE sind beide Tabellen gelockt. Wenn das stört, kann
man sich mit der Sequenz
<ul>
<li><code>CREATE TABLE b LIKE a;</code></li>
<li><code>ALTER TABLE b ENGINE=InnoDB</code></li>
<li><code>INSERT INTO b SELECT * FROM a;</code>
behelfen. Hier ist a dann während des Kopiervorganges nur mit einem Read
Lock gesperrt. Außerdem kann man mit einer LIMIT-Clause am Select die
Datenmenge begrenzen, etwa um zu experimentieren.</li>
</ul>
</li>
</ul>
<h3 id="transaktionen">
    <a href="#transaktionen">
	Transaktionen
    </a>
</h3>
<p>InnoDB beherrscht Transaktionen. Das bedeutet, das Anweisungen an
InnoDB-Tabellen gesammelt werden und erst durch ein <code>COMMIT</code> gesammelt auf
alle Tabellen angewendet werden. Entweder gelingen alle Anweisungen, oder
keine von den Anweisungen wird ausgeführt.</p>
<p>Per Default befindet sich die Datenbank im AUTOCOMMIT Modus. Das bedeutet,
nach jeder Anweisung &ldquo;denkt&rdquo; sich der Server automatisch ein <code>COMMIT</code> dazu.
Man kann entweder Autocommit abschalten, oder mit der Anweisung <code>BEGIN</code> auch
im Autocommit eine längere Transaktion beginnen.</p>
<pre><code class="language-console" data-lang="console">root on mysql.sock [innodemo]&gt; begin;
Query OK, 0 rows affected (0.00 sec)

root on mysql.sock [innodemo]&gt; insert into kris ( d ) values ( &quot;vier&quot; );
Query OK, 1 row affected (0.00 sec)

root on mysql.sock [innodemo]&gt; select * from kris;
+----+------+
| id | d    |
+----+------+
|  1 | eins |
|  2 | zwei |
|  3 | drei |
|  4 | vier |
+----+------+
4 rows in set (0.00 sec)

root on mysql.sock [innodemo]&gt; rollback;
Query OK, 0 rows affected (0.00 sec)

root on mysql.sock [innodemo]&gt; select * from kris;
+----+------+
| id | d    |
+----+------+
|  1 | eins |
|  2 | zwei |
|  3 | drei |
+----+------+
3 rows in set (0.00 sec)
</code></pre><p>Hier wird mit <code>BEGIN</code> eine Transaktion bei aktiviertem Autocommit begonnen,
das Autocommit also vorübergehend unterbrochen. Dies ist die empfohlene
Vorgehensweise. Eine Zeile wird in die Tabelle eingefügt. Für uns selber ist
diese Zeile auch erst einmal sichtbar. Die Transaktion wird jedoch nicht mit
<code>COMMIT</code> beendet, sondern mit <code>ROLLBACK</code> rückgängig gemacht. Dadurch ist nach
dem Ende der Transaktion die Zeile wieder weg.</p>
<h3 id="wie-innodb-auf-der-platte-aussieht">
    <a href="#wie-innodb-auf-der-platte-aussieht">
	Wie InnoDB auf der Platte aussieht
    </a>
</h3>
<pre><code class="language-console" data-lang="console">linux:/export/data/rootforum/data # ls -lh ib* innodemo
-rw-rw---- 1 mysql mysql   5M Jan  9 18:27 ib_logfile0
-rw-rw---- 1 mysql mysql   5M Jan  9 18:28 ib_logfile1
-rw-rw---- 1 mysql mysql  10M Jan  9 18:27 ibdata1

innodemo:
total 112K
-rw-rw---- 1 mysql mysql   61 Jan  9 18:03 db.opt
-rw-rw---- 1 mysql mysql 8.4K Jan  9 18:28 kris.frm
-rw-rw---- 1 mysql mysql  96K Jan  9 18:28 kris.ibd
</code></pre><p>Jede InnoDB-Installation hat mindestens ein Datenfile <code>ibdata1</code> und mindestens
zwei Redo-Logiles <code>ib_logfile0</code> und <code>ib_logfile1</code>. Position, Größe, Anzahl und
Namen dieser Dateien können jedoch relativ frei bestimmt werden.</p>
<p>Unser InnoDB arbeitet mit <code>innodb_file_per_table = 1</code>. Das bedeutet, unsere
Daten liegen in einer .ibd-Datei neben der .frm-Datei im Schema-Directory,
hier also in $datadir/innodemo/kris.ibd. Die Endung IBD steht Datei für
InnoBase-Data. Obwohl die eigentlichen Daten in dieser Datei liegen, braucht
InnoDB zwingend ein ibdata-File und mindestens zwei Redo-Logs. Im
ibdata-File legt Innobase das Data Dictionary ab, also eine Schattenkopie
der Tabellendefinitionen aus dem .frm-Dateien in einer Innobase-internen
Codierung und das Undo-Log. Im Redo-Log loggt InnoDb alle datenverändernden
Operationen.</p>
<p>Anders als bei MyISAM ist es NICHT möglich, .ibd-Dateien auf
Dateisystemebene zu kopieren, verschieben, umzubenennen oder einer anderen
Instanz von MySQL einfach so unterzuschieben. Jede dieser Operationen wird
im günstigsten Fall von InnoDB erkannt und zurückgewiesen und zerstört im
schlimmsten Fall die Instanz.</p>
<p>Wenn wir unser InnoDB mit <code>innodb_file_per_table = 0</code> betreiben, liegen auch
alle Tabellen in der zentralen ibdata-Datei, und es existieren im
Schema-Directory nur .frm-Dateien.</p>
<p>ibdata-Dateien können intern nicht genutzten Platz frei geben und wieder
verwenden, aber sie schrumpfen niemals. Wenn man eine Instanz nachträglich
von <code>innodb_file_per_table = 0</code> auf <code>1</code> umstellt, werden existierende
InnoDB-Tabellen durch ein <code>ALTER TABLE t ENGINE=InnoDB</code> in einem externe
.ibd-Datei umkopiert und der Platz in der ibdata-Datei freigegeben, aber die
Datei wird niemals schrumpfen. Die einzige Methode, von der alten großen
ibdata-Datei weg zu kommen ist ein Dump der Datenbank und ein Neuladen der
Daten in eine andere Instanz.</p>
<p>Wieviel Platz in einer ibdata- oder .ibd-Datei frei ist wird im Comment-Feld
der Ausgabe von SHOW TABLE STATUS für jede Tabelle angezeigt. Die Angaben
sind natürlich immer Vielfache von 16K, der InnoDB Seitengröße.</p>
<p>Es ist möglich, mehr als eine ibdata-Datei zu haben, aber es ist vollkommen
unmöglich zu kontrollieren, welche Tabelle oder welcher Teil einer Tabelle
in welcher ibdata-Datei liegt. Bei <code>innodb_file_per_table</code> liegt jede Tabelle
immer vollständig in ihrer eigenen .ibd-Datei.</p>
<h3 id="das-undo-log">
    <a href="#das-undo-log">
	Das Undo-Log
    </a>
</h3>
<p>Jede Tabelle hat in InnoDB zwei versteckte Spalten, eine Transaktionsnummer
und einen Zeiger auf die vorhergehende Version der Zeile im Undo-Log, den
Rollback-Pointer.</p>
<p>Wenn wir eine Zeile in einer InnoDB-Tabelle verändern, wird die alte Version
der Zeile mit der alten Transaktionsnummer aus der Originaltabelle ins
Undo-Log kopiert und die neue Version mit einer neuen Transaktionsnummer in
die .IBD-Datei kopiert. Der Rollback-Pointer der neuen Version der Zeile
zeigt dabei auf die alte Version der Zeile im Undo-Log.</p>
<pre><code class="language-console" data-lang="console">root on mysql.sock [innodemo]&gt; begin;
Query OK, 0 rows affected (0.00 sec)

root on mysql.sock [innodemo]&gt; update kris set d = &quot;one&quot; where id = 1;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

root on mysql.sock [innodemo]&gt; select * from kris;
+----+------+------+          +----+------+------+
| id | d    | txn# |          | id | d    | txn# |
+----+------+------+          +----+------+------+
|  1 | one  |   2  | ------&gt;  |  1 | eins |   1  |
|  2 | zwei |   1  |          +----+------+------+
|  3 | drei |   1  |
+----+------+------+
3 rows in set (0.00 sec)
</code></pre><p>In dem Beispiel oben habe ich diese verborgenen Zeilen und den Undo-Log
Eintrag zur Verdeutlichung manuell von Hand hereingefälscht.</p>
<p>Diese Verzeigerung von Zeilenversionen kann auch über mehr als eine Version
gehen, d.h. ein Eintrag im Undo-Log kann auf eine noch ältere Version einer
Zeile zeigen und so weiter. Löscht man das Undo-Log nie, bekommt man für
jede Zeile jeder Tabelle eine lineare Liste, die die vollständige Abfolge
aller Versionen dieser Zeile darstellt. Irgendwann einmal jedoch wird der
Undo-Eintrag, der jetzt ja nicht mehr gebraucht wird, von einer
InnoDB-Aufräumkomponente, dem Purge-Thread, gelöscht und der Eintrag im
Undo-Log gelöscht, sodaß das Undo-Log in der Realität nicht ins Unendliche
wächst.</p>
<p>Das Kopieren von Versionen von Zeilen aus der Tabelle ins Undo-Log und die
Verzeigerung von Zeilenversionen untereinander nennt man MVCC, Multiversion
Concurrency Control.</p>
<p>MVCC ist, so wie InnoDB es implementiert, für das COMMIT optimiert. Wenn man
als Anwender ein COMMIT ausführt, ist nichts zu tun: Die Transaktion wird
als comitted markiert, die Verzeigerung der Einträge bleibt bestehen und
alles ist gut.</p>
<pre><code class="language-console" data-lang="console">root on mysql.sock [innodemo]&gt; rollback;
Query OK, 0 rows affected (0.01 sec)

+----+------+------+          +----+------+------+
| id | d    | txn# |          | id | d    | txn# |
+----+------+------+ ROLLBACK +----+------+------+
|  1 | eins |   1  | &lt;------- |    |      |      |
|  2 | zwei |   1  |          +----+------+------+
|  3 | drei |   1  |
+----+------+------+
3 rows in set (0.00 sec)
</code></pre><p>Wenn man als Anwender ein ROLLBACK ausführt, fällt dagegen Arbeit an: Die
Daten aus dem Undo-Log müssen rausgefischt und die Änderung in der
Originaltabelle rückgängig gemacht werden.</p>
<p>Das kann bei vielen Zeilen auch mal länger dauern, da das Undo-Log
zeilenweise und nicht seitenweise organisiert ist. Es ist günstig, seine
Transaktionen nicht zu groß zu machen: In den meisten Fällen wird eine
Transaktionsgröße von 1.000 bis 10.000 Zeilen für das Massenladen von Daten
ein guter Kompromiß sein (Zu klein ist auch doof, wie wir noch sehen
werden).</p>
<h3 id="transaction-isolation-level-read-uncomitted">
    <a href="#transaction-isolation-level-read-uncomitted">
	Transaction Isolation Level Read Uncomitted
    </a>
</h3>
<p>Wenn wir die Transaktion von oben einmal von außen betrachten, also von
einer zweiten Verbindung aus, dann kann es sein, daß wir sie beobachten
können oder auch nicht. Auf der ersten Verbindung machen wir:</p>
<pre><code class="language-console" data-lang="console">root on mysql.sock [innodemo]&gt; begin;
Query OK, 0 rows affected (0.00 sec)

root on mysql.sock [innodemo]&gt; update kris set d = &quot;one&quot; where id = 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
</code></pre><p>und lassen dies nun hängen, ohne die Transaktion mit COMMIT oder ROLLBACK zu
beenden. In einem zweiten Fenster öffnen wir eine zweite Verbindung zur
Datenbank und schauen einmal, was wir sehen:</p>
<pre><code class="language-console" data-lang="console">root on mysql.sock [(none)]&gt; use innodemo;
Database changed
root on mysql.sock [innodemo]&gt; select * from kris;
+----+------+
| id | d    |
+----+------+
|  1 | eins |
|  2 | zwei |
|  3 | drei |
+----+------+
3 rows in set (0.00 sec)
</code></pre><p>Wir sehen erst einmal, daß unser Lesezugriff nicht hängt oder wartet, obwohl
gerade eine Transaktion im Gange ist. In MVCC können lesende und schreibende
Operationen einander niemals blockieren - das ist ein großer Unterschied zu
MyISAM und einer der Gründe warum InnoDB bei Szenarien mit hoher
Parallelität schneller ist als MyISAM, obwohl es ständig Kopien von den
Daten machen muß.</p>
<p>Wir sehen hier den alten Wert der Zeile mit der id = 1. Wir wissen von
weiter oben, das in der ibd-Datei schon die neue Version steht. Also muß die
Datenbank hier für die Zeile id = 1 für unsere Verbindung dem
Rollback-Pointer gefolgt sein und für uns die alte Version der Zeile
gefischt haben. Die erste Verbindung dagegen sieht, wie noch weiter oben
schon demonstriert, ihre eigenen Änderungen sofort, auch ohne COMMIT.</p>
<p>Wir können auch unsere externe, zweite Verbindung diese uncomitteten Daten
sehen lassen. Das geht, indem wir den <code>TRANSACTION ISOLATION LEVEL</code> dieser
Verbindung auf <code>READ UNCOMITTED</code> stellen.</p>
<pre><code class="language-console" data-lang="console">root on mysql.sock [innodemo]&gt; set transaction isolation level read uncommitted;
Query OK, 0 rows affected (0.00 sec)

root on mysql.sock [innodemo]&gt; select * from kris;
+----+------+
| id | d    |
+----+------+
|  1 | one  |
|  2 | zwei |
|  3 | drei |
+----+------+
3 rows in set (0.00 sec)
</code></pre><p>Wir merken uns: Eine schreibende Verbindung macht immer dasselbe: Sie
kopiert die zu verändernden Daten vor der Änderung ins Undo-Log und
verzeigert sie korrekt. Das muß sie tun, damit sie ein Rollback machen kann.</p>
<p>Eine lesende Verbindung kann sich nun aussuchen, welche Version der Daten
sie sehen will. Jede einzelne lesende Verbindung kann das unabhängig von
allen anderen Verbindungen tun und sich auch umentscheiden, denn es sind ja
in jedem Fall alle Versionen der Daten immer da.</p>
<p>In <code>READ UNCOMITTED</code> sehen wir immer die Daten aus dem ibd-File und folgen dem
Rollback-Pointer nie. Dadurch sehen wir Daten, die noch nicht comitted sind
und es auch vielleicht nie sein werden. Wir sehen eine Version der Realität,
die noch nicht existiert und es vielleicht nie tun wird. Für eine Anwendung
ist das in den meisten Fällen nicht das gewünschte Verhalten.</p>
<h3 id="transaction-level-read-comitted">
    <a href="#transaction-level-read-comitted">
	Transaction Level Read Comitted
    </a>
</h3>
<p>Setzen wir dagegen den <code>TRANSACTION ISOLATION LEVEL</code> auf <code>READ COMITTED</code>, dann
bekommen wir für alle Zeilen, die nicht von einer Transaktion in Bearbeitung
sind, die Daten aus dem .ibd-File und für alle Zeilen, in denen noch nicht
comittete Daten stehen folgt die Datenbank dem Rollback-Pointer genau eine
Ebene in das Undo-Log und liefert uns die Daten von dort. Dadurch bekommen
wir immer Daten zu sehen, die &ldquo;wirklich da sind&rdquo; und sie hypothetischen
Versionen der Wirklichkeit von <code>READ UNCOMITTED</code> werden für uns ausgefiltert.</p>
<p>Jedoch besteht immer noch die Möglichkeit, daß wir sehen wir sich Daten
verändern, wenn wir sie zweimal lesen.</p>
<p>Gegeben sei etwa eine Anwendung, die mit der Anweisungssequenz <code>begin; update kris set d = d + 1 where id = 2; commit;</code> einen Zähler für die Zeile
id = 2 hochzählt. Wenn wir in einer zweiten Verbindung wiederholt die
Tabelle mit <code>READ COMMITTED</code> betrachten, bekommen wir veränderliche Werte
von <code>kris.d</code> für <code>kris.id = 2</code> zurück. Das ist auch dann der Fall, wenn unsere
zweite Verbindung selbst eine Transaktion durchführt - die Sequenz
<code>BEGIN-SELECT-SELECT-COMMIT</code>, eine Read-Only-Transaktion, hat in <code>READ COMMITTED</code> keine besondere Bedeutung.</p>
<pre><code class="language-console" data-lang="console">root on mysql.sock [innodemo]&gt; set transaction isolation level read committed;
Query OK, 0 rows affected (0.00 sec)

root on mysql.sock [innodemo]&gt; begin;
Query OK, 0 rows affected (0.00 sec)

root on mysql.sock [innodemo]&gt; select * from kris;
+----+------+
| id | d    |
+----+------+
|  1 | eins |
|  2 | zwei |
|  3 | drei |
+----+------+
3 rows in set (0.01 sec)

root on mysql.sock [innodemo]&gt; select * from kris;
+----+------+
| id | d    |
+----+------+
|  1 | eins |
|  2 | 1    |
|  3 | drei |
+----+------+
3 rows in set (0.00 sec)

root on mysql.sock [innodemo]&gt; select * from kris;
+----+------+
| id | d    |
+----+------+
|  1 | eins |
|  2 | 2    |
|  3 | drei |
+----+------+
3 rows in set (0.00 sec)

root on mysql.sock [innodemo]&gt; commit;
Query OK, 0 rows affected (0.00 sec)

</code></pre><h3 id="transaction-isolation-level-repeatable-read">
    <a href="#transaction-isolation-level-repeatable-read">
	Transaction Isolation Level Repeatable-Read
    </a>
</h3>
<p>Genau dies ändert sich, wenn wir im Transaction Isolation Level <code>REPEATABLE READ</code> arbeiten: In dem Moment, in dem wir mit <code>BEGIN</code> eine Transaktion starten,
sieht diese Verbindung einen Snapshot der Datenbank, der sich nicht mehr
verändert, bis die Transaktion beendet wird. In <code>REPEATABLE READ</code> hat also
auch eine Read-Only-Transaktion eine Bedeutung.</p>
<p>Intern wird dies so realisiert, daß beim Lesen einer Zeile nicht nur einen
Schritt in die Vergangenheit der Zeile im Undo-Log gegangen wird, sondern
den untereinander verbundenen Zeigern im Undo-Log so lange gefolgt wird bis
die neuste Zeile gefunden wird, die für diesen Leser noch sichtbar ist.
Während also die schreibenden Verbindungen die Daten in der Tabelle immer
weiter und weiter ändern, wandern mehr und mehr alte Versionen dieser Zeile
ins Undo-Log, wo sie bis auf weiteres archiviert werden.</p>
<p>Während bei <code>READ COMITTED</code> also immer nur ein Schritt von der Tabelle ins
Undo-Log gemacht wird, kann es bei <code>REPEATABLE READ</code> vorkommen, daß für einen
bestimmten Leser viele Schritte im Undo-Log in die Vergangenheit der Zeile
gemacht werden müssen. Dadurch ist die Lebensdauer einzelner Einträge im
Undo-Log aber nicht mehr einheitlich, sondern es kann sein, daß einmal mehr
oder weniger Einträge im Undo-Log aufbewahrt werden müssen. InnoDB hat einen
globalen (für <code>SHOW PROCESSLIST</code> nicht sichtbaren) Purge-Thread, der schaut,
was die älteste Transaktion im System für eine Transaktionsnummer noch
brauchen würde. Der Purge-Thread löscht dann alle Einträge im Undo-Log, die
noch älter sind als diese Transaktion.</p>
<p>Das bedeutet aber anders herum auch, daß eine lange laufende Transaktion den
Purge-Thread effektiv still legt. Wenn zum Beispiel ein <code>mysqldump --single-transaction</code> eine große Datenbank exportiert, dann kann es sein,
daß diese &ldquo;single transaction&rdquo; viele Minuten oder je nach Datenmenge gar
stundenlang stehen bleibt und damit auch der Purge Thread nichts löschen
kann.</p>
<p>Finden in dieser Zeit viele Schreibzugriffe statt, wird das Undo-Log
unter Umständen beträchtlich anwachsen. Wie weiter oben erklärt, liegt das
Undo-Log <em>immer</em> im ibdata-File, auch dann, wenn <code>innodb_file_per_table</code>
aktiviert ist. Das bedeutet, daß das ibdata-File auch bei einem Server, der
<code>innodb_file_per_table</code> aktiviert hat, größer werden kann - 256M bis 1G sind
unter Umständen vollkommen normal.</p>
<p>Wenn ein ibdata-File zu klein ist und nicht wachsen kann, weil in der
<code>innodb_data_file_path</code> ohne <code>autoextend</code> definiert ist oder die Platte voll
ist, kann dies unter Umständen zu schwer verständlichen Fehlermeldungen
(&ldquo;Table full&rdquo;, obwohl noch mächtig Platz da ist) oder Transaktionsabbrüchen
führen.</p>
<h3 id="transaction-isolation-level-serializable-und-select--for-update">
    <a href="#transaction-isolation-level-serializable-und-select--for-update">
	Transaction Isolation Level SERIALIZABLE und SELECT &hellip; FOR UPDATE
    </a>
</h3>
<p>Während <code>REPEATABLE READ</code> also alle unsere Leseprobleme löst, fehlt uns jetzt
noch ein Mechanismus, mit dem wir <code>READ-MODIFY-WRITE</code> Zyklen korrekt handhaben
können. Ein Read-Modify-Write-Zyklus ist ein Zugriff, bei dem eine Anwendung
Daten liest, in der Anwendung verarbeitet und dann die geänderten Daten
zurück schreibt.</p>
<p>Damit dies konsistent geschehen kann, muß sichergestellt sein, daß die Daten
im Datenbanksystem nicht mehr geändert werden nachdem die Anwendung sie
gelesen hat, ansonsten bekommen wir eine Race-Condition, weil zwei
Verbindungen zeitgleich dieselben Daten lesen und sich gegenseitig die
Änderungen überschreiben.</p>
<p>Wir erreichen dies durch eine Transaktion, in der die Daten mit einem <code>SELECT ... FOR UPDATE</code>-Statement gelesen werden. Dies ist eine Select-Anweisung, die
normal lesend zugreift, aber dabei Locks erzeugt wie ein Update-Statement.
In unserem Fall bedeutet dies, daß exclusive Locks auf allen Zeilen erzeugt
werden, die vom Select-Statement über den Index zugegriffen wird. Die Locks
bleiben bis zum Ende der Transaktion stehen. Das <code>FOR UPDATE</code> bewirkt also
durch die Locks, daß zwei Änderungen an denselben Zeilen nacheinander, also
serialisiert, erfolgen.</p>
<p>Dabei gilt es ein paar trickreiche Dinge zu beachten:</p>
<p>Zunächst einmal werden die Locks über den Index erzeugt. Wenn wir also einen
<code>EXPLAIN</code>-Plan sehen, indem ein &ldquo;using where&rdquo; steht, dann heißt das in der
Regel, daß mehr Zeilen über den Index selektiert werden als nachher im
Result Set zu sehen sind - es gibt weitere einschränkende Bedingungen, die
den über den Index generierten Result Set weiter verkleinern. Für die Locks
bedeutet es aber, daß unter Umständen mehr Zeilen gelockt werden als wir
möchten oder im Result Set sehen können.</p>
<p>Wir können das demonstrieren, indem wir eine Tabelle mit zwei Spalten a und
b erzeugen.</p>
<p>a sei Primary Key und b sei nicht indiziert. Wenn wir jetzt ein <code>SELECT ... FOR UPDATE</code> ausführen, das <code>WHERE a = ... AND b = ...</code> enthält, werden alle in
der a-Bedingung gefundenen Zeilen gelockt, auch jene, bei denen die
b-Bedingung nicht zutrifft.</p>
<pre><code class="language-console" data-lang="console">-- 
-- Tabelle anlegen
-- 
root on mysql.sock [kris]&gt; create table t ( 
  a integer not null, 
  b integer not null 
) engine = innodb;
Query OK, 0 rows affected (0.16 sec)

--
-- Daten generieren
--
root on mysql.sock [kris]&gt; insert into t values ( rand() * 100000, rand() * 10);
Query OK, 1 row affected (0.01 sec)
root on mysql.sock [kris]&gt;  insert into t select rand() * 100000, rand() * 10 from t;
Query OK, 1 row affected (0.01 sec)
Records: 1  Duplicates: 0  Warnings: 0
...
root on mysql.sock [kris]&gt;  insert into t select rand() * 100000, rand() * 10 from t;
Query OK, 4096 rows affected (0.26 sec)
Records: 4096  Duplicates: 0  Warnings: 0

-- Da sind noch Duplikate drin, die das 
-- Anlegen eines Primary Key verhindern
root on mysql.sock [kris]&gt; create table dup as select a from t group by a having count(a) &gt; 1 ;
Query OK, 300 rows affected (0.08 sec)
Records: 300  Duplicates: 0  Warnings: 0
root on mysql.sock [kris]&gt; delete from t where a in ( select a from dup );
Query OK, 608 rows affected (5.65 sec)
root on mysql.sock [kris]&gt; alter table t add primary key (a);
Query OK, 7584 rows affected (0.40 sec)
Records: 7584  Duplicates: 0  Warnings: 0
root on mysql.sock [kris]&gt; drop table dup;
Query OK, 0 rows affected (0.00 sec)

--
-- 68 Zeilen über a selektiert
--
root on mysql.sock [kris]&gt;  select a, b from t where a &gt; 99000;
...
| 99490 |  8 |
...
62 rows in set (0.00 sec)

--
-- Jetzt die Demo: In einer Transaktion
-- ein SELECT ... FOR UPDATE fahren
--
root on mysql.sock [kris]&gt; begin;
Query OK, 0 rows affected (0.00 sec)

root on mysql.sock [kris]&gt;  select a, b from t where a &gt; 99000 and b = 10;
+-------+----+
| a     | b  |
+-------+----+
| 99839 | 10 |
| 99970 | 10 |
+-------+----+
2 rows in set (0.00 sec)
</code></pre><p>In einer anderen Verbindung können wir nun versuchen, etwa das Paar ( 99490,
8 ) zu ändern. Wir sehen: Das Statement hängt wegen eines X-Locks auf der
Zeile.</p>
<pre><code class="language-console" data-lang="console">root on mysql.sock [kris]&gt; update t set b = 502 where a = 99490;
... hang ...
</code></pre><p>Wenn wir jedoch einen weiteren INDEX (a,b) definieren und seine Benutzung
erzwingen, werden nur die beiden Records (99839, 10) und (99970, 10) gelockt
und unser paralleles Update auf (99490) geht ohne Warten durch:</p>
<pre><code class="language-console" data-lang="console">root on mysql.sock [kris]&gt; begin;
Query OK, 0 rows affected (0.00 sec)

root on mysql.sock [kris]&gt;  select * from t force index (a) where a &gt; 99000 and b = 10;
+-------+----+
| a     | b  |
+-------+----+
| 99839 | 10 |
| 99970 | 10 |
+-------+----+
2 rows in set (0.00 sec)
root on mysql.sock [kris]&gt; explain select * from t force index (a) where a &gt; 99000 and b = 10\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t
         type: range
possible_keys: a
          key: a
      key_len: 4
          ref: NULL
         rows: 63
        Extra: Using where; Using index
1 row in set (0.00 sec)
</code></pre><p>In der anderen Verbindung:</p>
<pre><code class="language-console" data-lang="console">root on mysql.sock [kris]&gt; update t set b = 503 where a = 99490;
Query OK, 1 row affected (0.09 sec)
Rows matched: 1  Changed: 1  Warnings: 0
</code></pre><p>Dieses Lockingverhalten hat also weitreichende Auswirkungen: Wir müssen beim
Schreiben von SQL unbedingt darauf achten, daß die Querypläne von <code>SELECT ... FOR UPDATE</code>-Statements die korrekten Indizes benutzen. Ein ALL oder INDEX in
der Type-Spalte des EXPLAIN würde hier zum Beispiel einen Index-Scan
andeuten - da der ganze Index überstrichen wird, bekommen wir so effektiv
ein sehr teures, aus Zeilenlocks zusammengesetztes Table-Lock.</p>
<p>Das andere trickreiche und unerwartete Verhalten ist, daß InnoDB nicht nur
Zeilen lockt, sondern auch die Lücke hinter den Zeilen. Dieses Next-Key
Locking vereinfacht die Implementierung von REPEATABLE-READ. Dieses
Verhalten ist abschaltbar, der Schalter hat den unerwarteten Namen
<code>innodb_locks_unsafe_for_binlog</code> - stellt man ihn auf <code>ON</code>, werden von
InnoDB einfach Zeilenlocks erzeugt ohne die Lücke hinter der Zeile auch zu
sperren.</p>
<p>Auf dem Transaction Isolation Level <code>SERIALIZABLE</code> verhält sich das System
genau wie auf dem Level <code>REPEATABLE-READ</code>, führt aber jedes einzelne
<code>SELECT</code> so aus, als sei es als <code>SELECT ... FOR UPDATE</code> geschrieben worden.
Das führt dazu, daß jedes SELECT Locks erzeugt als wäre es in
UPDATE-Statement, jeder Lesezugriff lockt also wie ein Schreibzugriff. Dies
führt effektiv dazu, daß sich selbst Lesezugriffe (die ja Schreiblocks
erzeugen) gegenseitig in die Quere kommen, wenn sie zugleich dieselben Daten
lesen wollen. Dies ist noch schlechteres Verhalten als in MyISAM!</p>
<p>Der Transaction Isolation Level <code>SERIALIZABLE</code> ist unnötig: Er wird nie
gebraucht, wenn der SQL-Code in der Anwendung korrekt mit <code>... FOR UPDATE</code>
lockt. Nur Anwendungen, die dies nicht korrekt tun <strong>und</strong> bei denen
außerdem das SQL nicht korrigierbar ist, brauchen den Isolation Level
<code>SERIALIZABLE</code>.</p>


	
    </article>
</div>



            <footer>
    <p>
	&copy; Copyright 2021 Someone or something
    </p>
</footer>


        </main>

	





<script src="/js/bootstrap.js"></script>




<script src="/js/lunr.js"></script>





<script src="/js/app.js"></script>


    </body>
</html>
