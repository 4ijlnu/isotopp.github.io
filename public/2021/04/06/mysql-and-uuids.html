<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<title>Die wunderbare Welt von Isotopp - MySQL and UUIDs</title>
<meta name="description" content="">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="manifest" href="site.webmanifest">
<link rel="apple-touch-icon" href="icon.png">
<link rel="favicon.ico" rel="icon" type="image/ico">





	



<link rel="stylesheet" href="/style.min.c5e5cd61f54911f9aafd1dbe09c2f90667957bfe1002126c87aace57759f3446.css">


    </head>
    <body>
        

        <nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container-fluid">
	<a class="navbar-brand" href="" rel="home" title=".Site.Title">
	    Die wunderbare Welt von Isotopp
	</a>
	<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
	</button>

	<div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
		
		
		<li class="nav-item ">
                    <a class="nav-link" href="/about/">
			
			<span>About</span>
			<span class="visually-hidden">(Current)</span>
		    </a>
		    
		</li>
            </ul>
            
	</div>
    </div>
</nav>


        <main role="main" class="container-fluid">

            


<div class="page">
    <article class="mysql-and-uuids-page">
	<h1 class="title">
            MySQL and UUIDs
	</h1>

	<p>In [ALTER TABLE for UUID]({% link _posts/2020-09-22-alter-table-for-uuid.md %}) we discuss currently proper way to store and handle UUID in MySQL. Currently it works, even in a performant way, but it still hurts. It should not.</p>
<h2 id="definition-of-uuid">
    <a href="#definition-of-uuid">
	Definition of UUID
    </a>
</h2>
<p>The <a href="https://tools.ietf.org/html/rfc4122" target="_blank" rel="noopener">RFC 4122</a>

 defines various types of UUID, and how they are being formatted for presentation and as a bit field on the wire. As this document was written bei Leach and Salz, among others, RFC 4122 UUIDs are also called &ldquo;Leach-Salz UUIDs&rdquo; (for example in the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html" target="_blank" rel="noopener">Java Documentation</a>

).</p>
<p>There are other UUID variants, used in other systems (NCS, and Microsoft &ldquo;backwards compatibility&rdquo;).</p>
<p>A RFC 4122 UUID is a special 128 bit long value (<a href="https://tools.ietf.org/html/rfc4122#section-4" target="_blank" rel="noopener">&ldquo;16 octets&rdquo;</a>

). It is supposed to be laid out like this:</p>
<pre><code class="language-console" data-lang="console"> 0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          time_low                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       time_mid                |         time_hi_and_version   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         node (2-5)                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>The high bits in <code>clk_seq_hi_res</code> define the variant, and anything starting with the bit sequence <code>10</code> is a RFC 4122 compliant UUID.</p>
<p>The high nibble in <code>time_hi_and_version</code> defines the RFC 4122 Type (or version), the algorithm used. RFC 4122 itself defines versions 1 to 5 (version 0 is unused).</p>
<p>There is an <a href="https://tools.ietf.org/html/draft-peabody-dispatch-new-uuid-format-00" target="_blank" rel="noopener">expired draft</a>

 that defines a version 6, which is specifically designed to use a primary key for databases. It uses the same timestamp value as Type 1, but stores the bytes so that ordering by creation time is preserved. It also relaxes the requirements on the node field, officially allowing different sources for bits than the MAC address. Sample implementations are <a href="http://gh.peabody.io/uuidv6/" target="_blank" rel="noopener">available</a>

 in various languages.</p>
<p>UUIDs are all over the place in Windows and also in Java. Databases have to handle them as &ldquo;application generated primary keys&rdquo;. That&rsquo;s why they are important and should be treated with some attention.</p>
<h2 id="handling-uuid-in-mysql-8">
    <a href="#handling-uuid-in-mysql-8">
	Handling UUID in MySQL 8
    </a>
</h2>
<p>MySQL provides functions to generate UUIDs, to check if a thing is a validly formatted string that looks like a UUID, and to convert UUIDs to 128 bit bitstrings and back.</p>
<p>The latter two functions have a special flag to improve performance with InnoDB. This flag is by default off. No attempt is made to automatically do the right thing dependent on the UUID type.</p>
<h3 id="uuid-function">
    <a href="#uuid-function">
	UUID function
    </a>
</h3>
<p>The MySQL function <a href="https://dev.mysql.com/doc/refman/8.0/en/miscellaneous-functions.html#function_uuid" target="_blank" rel="noopener">UUID()</a>

 returns a RFC 4122 Type 1 UUID.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">select</span> uuid_to_bin(uuid()) <span style="color:#66d9ef">as</span> uuid;
<span style="color:#f92672">+</span><span style="color:#75715e">------------------------------------+
</span><span style="color:#75715e"></span><span style="color:#f92672">|</span> uuid                               <span style="color:#f92672">|</span>
<span style="color:#f92672">+</span><span style="color:#75715e">------------------------------------+
</span><span style="color:#75715e"></span><span style="color:#f92672">|</span> <span style="color:#ae81ff">0</span>x80462D3C96AB11EB94BBBA2278F258E1 <span style="color:#f92672">|</span>
<span style="color:#f92672">+</span><span style="color:#75715e">------------------------------------+
</span><span style="color:#75715e"></span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">row</span> <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">set</span> (<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span> sec)
</code></pre></div><p>Formatted like in the RFC, we get the following values:</p>
<pre><code class="language-console" data-lang="console">80462D3C
96AB 1 1EB
9 4 BB B A22
78F258E1
</code></pre><p>Specifically, the <code>clk_seq_hi_res</code> contains the variant value, <code>9</code>, and the <code>time_hi_and_version</code> contains the version, <code>1</code>.</p>
<p>According to the RFC, the <a href="https://tools.ietf.org/html/rfc4122#section-4.1.1" target="_blank" rel="noopener">variant</a>

 <code>9</code> = <code>1001</code> = <code>10x</code> (a RFC 4122 compliant UUID).</p>
<p>Of the Versions defined in RFC 4122, it is Version 1 or <a href="https://tools.ietf.org/html/rfc4122#section-4.1.3" target="_blank" rel="noopener">Type 1</a>

, &ldquo;The time-based version in this document&rdquo;. The generation algorithm is defined in <a href="https://tools.ietf.org/html/rfc4122#section-4.2" target="_blank" rel="noopener">section 4.2</a>

 of that RFC.</p>
<p>So a MySQL generated UUID is always a RFC 4122 Type 1 (time based) UUID.</p>
<h3 id="java-generated-uuid-values">
    <a href="#java-generated-uuid-values">
	Java generated UUID values
    </a>
</h3>
<p>Compare with the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html" target="_blank" rel="noopener">Java UUID Class</a>

:</p>
<p>We have <code>randomUUID()</code>, returning a Type 4 UUID and  <code>nameUUIDFromBytes()</code> for Type 3 and a generic Constructor that takes any 128 bit value. So what we get from Java is likely <a href="https://tools.ietf.org/html/rfc4122#section-4.3" target="_blank" rel="noopener">name based</a>

 or <a href="https://tools.ietf.org/html/rfc4122#section-4.4" target="_blank" rel="noopener">random UUIDs</a>

 generated by the application.</p>
<p>Name based UUIDs are fixed for a fixed name, so they pose no problem when used with MySQL as a primary key.</p>
<p>Random UUIDs are completely random. There is nothing to optimize for MySQL here.</p>
<p>Neither is a good choice to use as a kind of application controlled distributed primary key.</p>
<p>Based on the reasoning in [ALTER TABLE for UUID]({% link _posts/2020-09-22-alter-table-for-uuid.md %}), Java developers that are using UUID for this purpose would be well advised to implement and use a Type 1 UUID. It seems that such an implementation is not available by default as part of <code>java.lang.util</code>, but <a href="https://stackoverflow.com/questions/18244897/how-to-generate-time-based-uuids" target="_blank" rel="noopener">other implementations exist</a>

.</p>
<h2 id="is_uuid-function">
    <a href="#is_uuid-function">
	IS_UUID() function
    </a>
</h2>
<p>The <a href="https://dev.mysql.com/doc/refman/8.0/en/miscellaneous-functions.html#function_is-uuid" target="_blank" rel="noopener">IS_UUID()</a>

 predicate returns <code>1</code> for all strings that can be parsed as a UUID.</p>
<p>That is, it checks for one of three ways to write the UUID, and that it contains only valid hex digits in the places that actually contain data. No attempt is made to validate any of the bits. Code is <a href="https://github.com/mysql/mysql-server/blob/7ed30a748964c009d4909cb8b4b22036ebdef239/sql/item_strfunc.cc#L2837" target="_blank" rel="noopener">here</a>

, and the actual parsing happens <a href="https://github.com/mysql/mysql-server/blob/f8cdce86448a211511e8a039c62580ae16cb96f5/libbinlogevents/src/uuid.cpp#L56" target="_blank" rel="noopener">here</a>

.</p>
<h2 id="uuid_to_bin-function">
    <a href="#uuid_to_bin-function">
	UUID_TO_BIN() function
    </a>
</h2>
<p>MySQL allows three ways to write UUIDs, as a 128 bit hex string (<code>6ccd780cbaba102695645b8c656024db</code>), as a 128 bit hex string with dashes in the right places (<code>6CCD780C-BABA-1026-9564-5B8C656024DB</code>) and as a 128 bit hex string with dashes in the right places and enclosed in curly braces (<code>{6CCD780C-BABA-1026-9564-5B8C656024DB}</code>).</p>
<p>This is not a particular dense packing of data for storage. The <a href="https://dev.mysql.com/doc/refman/8.0/en/miscellaneous-functions.html#function_uuid-to-bin" target="_blank" rel="noopener">UUID_TO_BIN()</a>

 function takes any of these strings and returns a <code>VARBINARY(16)</code> for storage.</p>
<p>The function has an optional second parameter, the <code>swap_flag</code>. When applied to a Type 1 UUID, the time bytes are being swapped around so that chronological ascending UUIDs from the same node are also having numerically ascending values. This optimizes storage with InnoDB.</p>
<ul>
<li><em>Type 1 UUID:</em> It is recommended you define UUID columns as <code>VARBINARY(16)</code> and use the<code>UUID_TO_BIN(uuid_string, 1)</code> function to store data.</li>
<li><em>Type 6 UUID:</em> You should use <code>UUID_TO_BIN(uuid_string, 0)</code> to store Type 6 UUIDs, because Type 6 has been specifically created to avoid the swapping of time bytes around.</li>
<li>Other types: These do not profit from swapping, so also use <code>UUID_TO_BIN(uuid_string, 0)</code>.</li>
</ul>
<h2 id="bin_to_uuid-function">
    <a href="#bin_to_uuid-function">
	BIN_TO_UUID function
    </a>
</h2>
<p>The inverse function to UUID_TO_BIN is <a href="https://dev.mysql.com/doc/refman/8.0/en/miscellaneous-functions.html#function_bin-to-uuid" target="_blank" rel="noopener">BIN_TO_UUID()</a>

. It needs the same <code>swap_flag</code> value as has been used at write time in order to unpack the data correctly.</p>
<h1 id="it-should-hurt-less">
    <a href="#it-should-hurt-less">
	It should hurt less
    </a>
</h1>
<p>This all should hurt less.</p>
<ul>
<li>MySQL should have a native <code>UUID</code> column type, which stores data internally in a <code>VARBINARY(16)</code> (or <code>BINARY(16)</code>).</li>
<li>It should accept all three notations as input (hex string, with dashes, with curly braces and dashes). It should return a hex string without dashes or curlies.</li>
<li>It should validate variant and type (version), allowing Types 1 to 6.</li>
<li>It should auto-convert (swap) data for Type 1, but not for any other type.</li>
<li>There should be a formatting function that turns a hex string without dashes into a UUID string with dashes, or a UUID string with dashes and curlies.</li>
</ul>
<p>That is, I want to be able to</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> u ( u uuid <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span>, dummy integer );
mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> u <span style="color:#66d9ef">values</span> (uuid(), <span style="color:#ae81ff">1</span>);
mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">select</span> u <span style="color:#66d9ef">from</span> u<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">G</span>
u: <span style="color:#ae81ff">6</span>ccd780cbaba102695645b8c656024db
mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">select</span> format_uuid(u, <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">as</span> u <span style="color:#66d9ef">from</span> u<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">G</span>
u: <span style="color:#ae81ff">6</span>CCD780C<span style="color:#f92672">-</span>BABA<span style="color:#f92672">-</span><span style="color:#ae81ff">1026</span><span style="color:#f92672">-</span><span style="color:#ae81ff">9564</span><span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>B8C656024DB
mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">select</span> format_uuid(u) <span style="color:#66d9ef">as</span> u <span style="color:#66d9ef">from</span> u<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">G</span>
u: <span style="color:#ae81ff">6</span>CCD780C<span style="color:#f92672">-</span>BABA<span style="color:#f92672">-</span><span style="color:#ae81ff">1026</span><span style="color:#f92672">-</span><span style="color:#ae81ff">9564</span><span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>B8C656024DB
mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">select</span> format_uuid(u, <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">as</span> u <span style="color:#66d9ef">from</span> u<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">G</span>
u: <span style="color:#960050;background-color:#1e0010">{</span><span style="color:#ae81ff">6</span>CCD780C<span style="color:#f92672">-</span>BABA<span style="color:#f92672">-</span><span style="color:#ae81ff">1026</span><span style="color:#f92672">-</span><span style="color:#ae81ff">9564</span><span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>B8C656024DB<span style="color:#960050;background-color:#1e0010">}</span>
</code></pre></div><p>and internally, this is stored as 0x1026BABA6CCD780C95645B8C656024DB, because variant is RFC 4122 and Type is 1.</p>
<p>For any other Type of the RFC 4122 the internal swapping does not happen.</p>
<p>Trying to store anything that is not a RFC 4122 variant is an error. Trying to store anything that is a RFC 4122 variant but not a Type 1 to 6 is an error.</p>


	
    </article>
</div>



            <footer>
    <p>
	&copy; Copyright 2021 Someone or something
    </p>
</footer>


        </main>

	





<script src="/js/bootstrap.js"></script>




<script src="/js/lunr.js"></script>





<script src="/js/app.js"></script>


    </body>
</html>
