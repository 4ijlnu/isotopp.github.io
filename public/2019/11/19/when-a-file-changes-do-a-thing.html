<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<title>Die wunderbare Welt von Isotopp - When a file changes, do a thing</title>
<meta name="description" content="">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="manifest" href="site.webmanifest">
<link rel="apple-touch-icon" href="icon.png">
<link rel="favicon.ico" rel="icon" type="image/ico">





	



<link rel="stylesheet" href="/style.min.c5e5cd61f54911f9aafd1dbe09c2f90667957bfe1002126c87aace57759f3446.css">


    </head>
    <body>
        

        <nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container-fluid">
	<a class="navbar-brand" href="" rel="home" title=".Site.Title">
	    Die wunderbare Welt von Isotopp
	</a>
	<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
	</button>

	<div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
		
		
		<li class="nav-item ">
                    <a class="nav-link" href="/about/">
			
			<span>About</span>
			<span class="visually-hidden">(Current)</span>
		    </a>
		    
		</li>
            </ul>
            
	</div>
    </div>
</nav>


        <main role="main" class="container-fluid">

            


<div class="page">
    <article class="when-a-file-changes-do-a-thing-page">
	<h1 class="title">
            When a file changes, do a thing
	</h1>

	<p>When developing there is often an edit-compile-test cycle, or an
edit-distribute-changes cycle or a similar repetetive task. You
could poll changes, for example with cron every minute or
similarly, but that is wasteful and slow.</p>
<p>All modern operating systems have mechanisms for processes to
subscribe to file or directory changes. In MacOS, we do have the
<a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/FSEvents_ProgGuide/TechnologyOverview/TechnologyOverview.html#//apple_ref/doc/uid/TP40005289-CH3-SW1" target="_blank" rel="noopener">File System Events</a>


API since 10.5, in Linux we got three different implementations
(as described in <a href="https://lwn.net/Articles/604686/" target="_blank" rel="noopener">LWN</a>

): The
original dnotify, its replacement inotify and the even more
recent fanotify (which got its own <a href="https://lwn.net/Articles/605128/" target="_blank" rel="noopener">LWN
article</a>

). BSD has kqueue.</p>
<p>The idea is that you subscribe to a directory and get notified
for change/create/delete/rename events inside that directory
and/or all events recursively beneath that starting point (a
&lsquo;root&rsquo;). You would be interested into the type of change and the
name of the file path that changes, and you would probably want
to be able to retrieve lists of these changes in batch.</p>
<p>To make that useful, you would need a shell interface to this,
and there are quite a few by now.</p>
<ul>
<li>The most convenient seems to be
<a href="https://github.com/clibs/entr" target="_blank" rel="noopener">entr</a>

, because it works most
closely with shell programs.</li>
<li>There is also <a href="https://facebook.github.io/watchman/" target="_blank" rel="noopener">watchman</a>

,
but this requires submitting jobs and processing results in
Javascript to fully use its potential.</li>
<li>One of the first programs to use filesystem subscriptions is
<a href="https://github.com/emcrisostomo/fswatch/wiki/How-to-Use-fswatch" target="_blank" rel="noopener">fswatch</a>

,
but while highly portable, it is cumbersome to use. Instead of
running commands, it just reports filenames to feed into a
pipe to handle.</li>
<li>Ruby seems to have a library called
<a href="https://github.com/guard/guard" target="_blank" rel="noopener">Guard</a>

 that also comes with
an interface to shell, but can also being used as a ruby gem.</li>
<li><a href="http://hackage.haskell.org/package/spy" target="_blank" rel="noopener">spy</a>

 is a weird piece
of Haskell that produces a small binary that can run commands
on file system changes.</li>
</ul>
<p>Python seems to come with a bunch of modules and interfaces in
various states of disrepair,
<a href="https://github.com/rvoicilas/inotify-tools" target="_blank" rel="noopener">inotify-tools</a>

, the
very tiny wrapper <a href="https://pypi.org/project/inotify_simple/" target="_blank" rel="noopener">inotify_simple</a>


(the simple here refers to the fact that it is a very thing
wrapper around the C library, not simple to use), the more
convenient <a href="https://pypi.org/project/inotify/" target="_blank" rel="noopener">inotify</a>

 and the
high level wrapper
<a href="https://pythonhosted.org/watchdog/quickstart.html#a-simple-example" target="_blank" rel="noopener">watchdog</a>

.</p>
<h2 id="a-test-scenario">
    <a href="#a-test-scenario">
	A test scenario
    </a>
</h2>
<p>As a test scenario I have a <code>ship-to-kvm</code> command that I want to
run on every file change. It looks like this:</p>
<pre><code class="language-console" data-lang="console">rsync -e ssh -t -v --delete --delete-excluded --exclude='.git' -r \
  ~/git_tree/myproject \
  devuser@devbox.example.com:myproject
</code></pre><p>when I save my local file from my local editor so that the tree
myproject is made available on my devbox.</p>
<h2 id="entr">
    <a href="#entr">
	entr
    </a>
</h2>
<p>With <a href="https://github.com/clibs/entr" target="_blank" rel="noopener">entr</a>

, that is rather
simple. The package <code>entr</code> is available in Homebrew on MacOS
(<code>brew install entr</code>) or as a package in Linux (<code>yum install -y entr</code>, <code>apt install entr</code>).</p>
<p>You ask entr to watch a list of files or a directory, and when
things change to run a command. You can hit space to force
execution even when nothing changed, or <code>q</code> to end the command.</p>
<p>Various ways to handle changes are provided:</p>
<pre><code class="language-console" data-lang="console">$ ls *.js | entr -r node myproject.js
</code></pre><p>The <code>-r</code> option here will SIGTERM the node instance, wait for it
to complete and then restart it.</p>
<p>To get notification of new and deleted files, you need to watch
directories, which are inferred from a file list. This is done
with the <code>-d</code> option and in fact the command terminates so you
need to wrap it in a loop:</p>
<pre><code class="language-console" data-lang="console">$ while :; do
&gt;   ls | entr -d ship-to-kvm
&gt; done
</code></pre><p>There are a few other options, but these two should cover the
most common use cases.</p>
<h2 id="watchman">
    <a href="#watchman">
	watchman
    </a>
</h2>
<p><a href="https://facebook.github.io/watchman/" target="_blank" rel="noopener">watchman</a>

 is the facebook
take on things. It consists of a daemon that is automatically
started when you are using the frontend command, and a frontend
command that actually does not expose all the functionality
unless you feed it JSON job files. All command results are also
JSON.</p>
<p>watchman has the concept of roots, filesystem subtrees that are
being watched, and then triggers that are attached to roots or
subtrees of roots, and are being run on change. A simple
predicate language and a selection of regex libraries can be
used to formulate conditions for triggers.</p>
<pre><code class="language-console" data-lang="console">$ watchman watch ~/git_tree/myproject # this will start the daemon
$ watchman -j ship-to-kvm.json        # this defines the job
...
</code></pre><p>and the actual job definition is then something like</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">[
  <span style="color:#e6db74">&#34;trigger&#34;</span>, <span style="color:#e6db74">&#34;~/git_tree/myproject&#34;</span>,
  {
    <span style="color:#e6db74">&#34;name&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;ship-to-kvm&#34;</span>,
    <span style="color:#e6db74">&#34;expression&#34;</span><span style="color:#f92672">:</span> [ <span style="color:#e6db74">&#34;pcre&#34;</span>, <span style="color:#e6db74">&#34;^[a-zA-Z0-9]&#34;</span> ],
    <span style="color:#e6db74">&#34;command&#34;</span><span style="color:#f92672">:</span> [ <span style="color:#e6db74">&#34;ship-to-kvm&#34;</span> ]
  }
]
</code></pre></div><p>This may look nicer to developers, but I seem to prefer the entr
way of doing things.</p>
<h2 id="python-watchdog">
    <a href="#python-watchdog">
	Python watchdog
    </a>
</h2>
<p>The Python library
<a href="https://pythonhosted.org/watchdog/quickstart.html#a-simple-example" target="_blank" rel="noopener">watchdog</a>


provides a convenient programmatic interface to inotify and friends
by defining an Observer class and scheduling operations to the
observer when there are events outstanding.</p>
<p>The example from the manual looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#! /usr/bin/env python</span>

<span style="color:#f92672">import</span> sys
<span style="color:#f92672">import</span> time
<span style="color:#f92672">import</span> logging

<span style="color:#f92672">from</span> watchdog.observers <span style="color:#f92672">import</span> Observer
<span style="color:#f92672">from</span> watchdog.events <span style="color:#f92672">import</span> LoggingEventHandler

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
    logging<span style="color:#f92672">.</span>basicConfig(level<span style="color:#f92672">=</span>logging<span style="color:#f92672">.</span>INFO,
        format<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%(asctime)s</span><span style="color:#e6db74"> - </span><span style="color:#e6db74">%(message)s</span><span style="color:#e6db74">&#39;</span>,
        datefmt<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;%Y-%m-</span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> %H:%M:%S&#39;</span>)
    path <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> len(sys<span style="color:#f92672">.</span>argv) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">else</span> <span style="color:#e6db74">&#39;.&#39;</span>

    event_handler <span style="color:#f92672">=</span> LoggingEventHandler()

    observer <span style="color:#f92672">=</span> Observer()
    observer<span style="color:#f92672">.</span>schedule(event_handler, path, recursive<span style="color:#f92672">=</span>True)
    observer<span style="color:#f92672">.</span>start()

    <span style="color:#66d9ef">try</span>:
        <span style="color:#66d9ef">while</span> True:
            time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">KeyboardInterrupt</span>:
        observer<span style="color:#f92672">.</span>stop()

    observer<span style="color:#f92672">.</span>join()
</code></pre></div><p>and when run does things like this for a <code>touch keks; sleep 1; rm keks</code> in a secondary shell:</p>
<pre><code class="language-console" data-lang="console">2019-11-19 14:36:40 - Modified directory: ./.git
2019-11-19 14:36:44 - Created file: ./keks
2019-11-19 14:36:44 - Modified directory: .
2019-11-19 14:36:44 - Modified directory: ./.git
2019-11-19 14:36:53 - Deleted file: ./keks
2019-11-19 14:36:53 - Modified directory: .
2019-11-19 14:36:53 - Modified directory: ./.git
</code></pre><p>The actual observer selection allows a rich palette of event
classes and filters, so dispatching and filtering events is easy.</p>


	
    </article>
</div>



            <footer>
    <p>
	&copy; Copyright 2021 Someone or something
    </p>
</footer>


        </main>

	





<script src="/js/bootstrap.js"></script>




<script src="/js/lunr.js"></script>





<script src="/js/app.js"></script>


    </body>
</html>
