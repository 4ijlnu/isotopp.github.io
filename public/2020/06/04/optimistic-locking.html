<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<title>Die wunderbare Welt von Isotopp - Optimistic locking</title>
<meta name="description" content="">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="manifest" href="site.webmanifest">
<link rel="apple-touch-icon" href="icon.png">
<link rel="favicon.ico" rel="icon" type="image/ico">





	



<link rel="stylesheet" href="/style.min.c5e5cd61f54911f9aafd1dbe09c2f90667957bfe1002126c87aace57759f3446.css">


    </head>
    <body>
        

        <nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container-fluid">
	<a class="navbar-brand" href="" rel="home" title=".Site.Title">
	    Die wunderbare Welt von Isotopp
	</a>
	<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
	</button>

	<div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
		
		
		<li class="nav-item ">
                    <a class="nav-link" href="/about/">
			
			<span>About</span>
			<span class="visually-hidden">(Current)</span>
		    </a>
		    
		</li>
            </ul>
            
	</div>
    </div>
</nav>


        <main role="main" class="container-fluid">

            


<div class="page">
    <article class="optimistic-locking-page">
	<h1 class="title">
            Optimistic locking
	</h1>

	<p>A <a href="https://www.reddit.com/r/mysql/comments/gwc0ry/concurrent_queries_with_mysql/" target="_blank" rel="noopener">question</a>

 from Reddit&rsquo;s /r/mysql:</p>
<blockquote>
<p>Hey, I was planning to make a dashboard, where Users are subjected to make edits on their profiles every now and then, and I expect a high volume of requests to the database.</p>
<p>Having worked previously with MySQL for another Dashboard, I encountered errors for:</p>
<ul>
<li>
<p>Maximum user connections - when I connected to the database only while query was to be executed</p>
</li>
<li>
<p>Lock wait timeout exceeded; try restarting transaction - when I connected to the database whenever a user logged into the dashboard, and ended the connection when he ended the session.</p>
</li>
</ul>
<p>Both the approaches resulted in different errors, that too when I had a small user base, but they were active at the same time. Since, for the New Dashboard, I expect way more oscillating traffic, depending upon events, is there any way I can optimize my process of queries so that I can prevent the errors.</p>
</blockquote>
<p>I am having trouble understanding what was being tried. The host language was not stated, but that choice could influence system behavior because of the way the host language connects to the database.</p>
<p>Assuming a 2-tier system where the web frontend contains the host language directly or indirectly (any of Perl, PHP, Python, Ruby as module or FCGI process), we will see as many connections to the database as there are web server processes or FCGI workers. Each connection spawns a thread in the database, and that will, when idle consume some 500 KB or so of memory in the database server. Obviously, the <code>max_connections</code> value must be higher or equal to the maximum number of workers.</p>
<p>There is no way for this to stall &ldquo;when I connected to the database only while query was to be executed&rdquo;. By default, each worker has one database connection and query execution is synchronous, the worker is stalled while the database is working on the query. This could be different, if a language such as Java or Javascript (node.js?) is being used, and a connection pool has been configured. In this case, if queries stall, the connection pool may be undersized.</p>
<p>The &ldquo;Lock wait timeout exceeded&rdquo; means an InnoDB row lock has been held for a transaction duration longer than 50 seconds. This seems to be either a deadlock (two transactions trying to change an overlapping set of rows) that is not properly detected, or it is an attempt to hold a lock over a human user interface transactions - always an error.</p>
<p>For the latter problem often an optimistic locking approach is successful. That is: No locking when generating the data entry screen for the UI. When the data entry screen is comitted, start the transaction and guard it with a version number or the full data set.</p>
<p>Let&rsquo;s look at this in a concrete fashion, using Python and a Flask app, using the ideas of Miguel Grinberg&rsquo;s <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iii-web-forms" target="_blank" rel="noopener">The Flask Mega-Tutorial</a>

 as a foundation.</p>
<p>We want to edit some dummy table without timing out. The table is defined like so:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#f92672">`</span>editme<span style="color:#f92672">`</span> (
  <span style="color:#f92672">`</span>id<span style="color:#f92672">`</span> bigint unsigned <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> AUTO_INCREMENT,
  <span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> varchar(<span style="color:#ae81ff">200</span>) <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>,
  <span style="color:#f92672">`</span>city<span style="color:#f92672">`</span> varchar(<span style="color:#ae81ff">200</span>) <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>,
  <span style="color:#66d9ef">UNIQUE</span> <span style="color:#66d9ef">KEY</span> <span style="color:#f92672">`</span>id<span style="color:#f92672">`</span> (<span style="color:#f92672">`</span>id<span style="color:#f92672">`</span>)
)
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#f92672">`</span>editme<span style="color:#f92672">`</span> <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#39;Name 1&#39;</span>,<span style="color:#e6db74">&#39;City 1&#39;</span>);
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#f92672">`</span>editme<span style="color:#f92672">`</span> <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#39;Name 2&#39;</span>,<span style="color:#e6db74">&#39;City 2&#39;</span>);
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#f92672">`</span>editme<span style="color:#f92672">`</span> <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">3</span>,<span style="color:#e6db74">&#39;Name 3&#39;</span>,<span style="color:#e6db74">&#39;City 3&#39;</span>);
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#f92672">`</span>editme<span style="color:#f92672">`</span> <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">4</span>,<span style="color:#e6db74">&#39;Name 4&#39;</span>,<span style="color:#e6db74">&#39;City 4&#39;</span>);
</code></pre></div><p>It has an integer field <code>id</code>, which is the primary key, and two data fields, <code>name</code>, and <code>city</code>. We do not care what that means, it is just an example. We provide some sample data.</p>
<p>The web form shows these values, and as hidden fields, also preserves the pre-edit values. So we get the <code>id</code> field to identify rows, and then hidden fields <code>oldname</code> and <code>oldcity</code>, and the matching visible edit fields <code>name</code> and <code>city</code>.</p>
<pre><code class="language-html{%" data-lang="html{%">{% extends &quot;base.html&quot; %}
{% block content %}
	{% for row in table %}
	&lt;tr&gt;
		&lt;form action=&quot;&quot; method=&quot;post&quot; novalidate&gt;
		{{ form.csrf_token }}
		{{ form.id(value=row.id) }}
		{{ form.oldname(value=row.name) }}
		{{ form.oldcity(value=row.city) }}
		&lt;td&gt;{{ form.name(value=row.name, size=40) }}&lt;/td&gt;
		&lt;td&gt;{{ form.city(value=row.city, siz=40) }}&lt;/td&gt;
		&lt;td&gt;{{ form.submit() }}&lt;/td&gt;
		&lt;/form&gt;
	&lt;/tr&gt;
	{% endfor %}
{% endblock %}
{% endraw %}```

![](/uploads/2020/06/optimistic-locking-1.png)

Flask and WTForms demand a Form Class to handle this. We name it `EditForm` and define our hidden and visible fields:

```python
#! /usr/bin/env python

from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField, HiddenField
from wtforms.validators import DataRequired


class EditForm(FlaskForm):
    id = HiddenField(&quot;id&quot;, validators=[DataRequired()])
    oldname = HiddenField(&quot;oldname&quot;, validators=[DataRequired()])
    oldcity = HiddenField(&quot;oldcity&quot;, validators=[DataRequired()])
    name = StringField(&quot;name&quot;, validators=[DataRequired()])
    city = StringField(&quot;city&quot;, validators=[DataRequired()])
    submit = SubmitField(&quot;Save&quot;)
</code></pre><p>Finally we can put all the cabling into our routes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#! /usr/bin/env python</span>

<span style="color:#f92672">from</span> flask <span style="color:#f92672">import</span> render_template, flash
<span style="color:#f92672">from</span> app <span style="color:#f92672">import</span> app
<span style="color:#f92672">from</span> app.forms <span style="color:#f92672">import</span> EditForm
<span style="color:#f92672">from</span> app.data <span style="color:#f92672">import</span> FormUpdater  <span style="color:#75715e"># this is where the optimistic locking happens</span>


<span style="color:#a6e22e">@app.route</span>(<span style="color:#e6db74">&#34;/&#34;</span>, methods<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;GET&#34;</span>, <span style="color:#e6db74">&#34;POST&#34;</span>])
<span style="color:#a6e22e">@app.route</span>(<span style="color:#e6db74">&#34;/index&#34;</span>, methods<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;GET&#34;</span>, <span style="color:#e6db74">&#34;POST&#34;</span>])
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">index</span>():
    f <span style="color:#f92672">=</span> FormUpdater()
    table <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>fetch()   <span style="color:#75715e"># load table into memory</span>
    form <span style="color:#f92672">=</span> EditForm()   <span style="color:#75715e"># show an edit form</span>
    <span style="color:#66d9ef">if</span> form<span style="color:#f92672">.</span>validate_on_submit():   <span style="color:#75715e"># if the form has been submitted back,</span>
        modified <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>update(form)   <span style="color:#75715e"># save the data, remember the number of changed rows</span>
        table <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>fetch()           <span style="color:#75715e"># reload the data for checking</span>
        flash(f<span style="color:#e6db74">&#34;Updated {modified} rows.&#34;</span>)
    <span style="color:#66d9ef">else</span>:
        flash(<span style="color:#e6db74">&#34;No data received.&#34;</span>)
    <span style="color:#75715e"># show the form</span>
    <span style="color:#66d9ef">return</span> render_template(<span style="color:#e6db74">&#34;index.html&#34;</span>, title<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Home&#34;</span>, table<span style="color:#f92672">=</span>table, form<span style="color:#f92672">=</span>form)
</code></pre></div><p>We register only one action, for the routes <code>/</code> and <code>/index</code>. This route loads the data from the database, by creating a <code>FormUpdater</code> and calling <code>fetch()</code> on it.</p>
<p>In case this form has been edited and the <code>Save</code> button pressed, we end up in the if-branch for <code>validate_on_submit()</code>. Here we call <code>update()</code> on the <code>FormUpdater</code>, and the re-fetch the data to make sure we show the updates. We also remember the number of modified rows in <code>modified</code>.</p>
<p>In any case, we show the table as a form.</p>
<p>Now, the <code>FormUpdater</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#! /usr/bin/env python</span>

<span style="color:#f92672">import</span> MySQLdb
<span style="color:#f92672">import</span> MySQLdb.cursors


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FormUpdater</span>:
    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>connect()

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">connect</span>(self):
        self<span style="color:#f92672">.</span>db <span style="color:#f92672">=</span> MySQLdb<span style="color:#f92672">.</span>connect(host<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;localhost&#34;</span>, user<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;root&#34;</span>, db<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;kris&#34;</span>)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fetch</span>(self):
        cur <span style="color:#f92672">=</span> MySQLdb<span style="color:#f92672">.</span>cursors<span style="color:#f92672">.</span>DictCursor(self<span style="color:#f92672">.</span>db)
        query <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;select id, name, city from editme&#34;</span>
        cur<span style="color:#f92672">.</span>execute(query)
        <span style="color:#66d9ef">return</span> cur<span style="color:#f92672">.</span>fetchall()

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">update</span>(self, form):
        query <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;update editme set name = </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">, city = </span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> where id = </span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> and name = </span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> and city = </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span>
        data <span style="color:#f92672">=</span> (
            form<span style="color:#f92672">.</span>name<span style="color:#f92672">.</span>data,
            form<span style="color:#f92672">.</span>city<span style="color:#f92672">.</span>data,
            form<span style="color:#f92672">.</span>id<span style="color:#f92672">.</span>data,
            form<span style="color:#f92672">.</span>oldname<span style="color:#f92672">.</span>data,
            form<span style="color:#f92672">.</span>oldcity<span style="color:#f92672">.</span>data,
        )
        cur <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>db<span style="color:#f92672">.</span>cursor()
        cur<span style="color:#f92672">.</span>execute(query, data)
        modified <span style="color:#f92672">=</span> cur<span style="color:#f92672">.</span>rowcount
        self<span style="color:#f92672">.</span>db<span style="color:#f92672">.</span>commit()

        <span style="color:#66d9ef">return</span> modified
</code></pre></div><p>The <code>fetch()</code> method simply runs <code>select id, name, city from editme</code> and returns all rows. In order to make our life easier, we are using a <code>DictCursor</code>, so we get named columns.</p>
<p>The <code>update()</code> method generates a query that sets the new values for <code>name</code> and <code>city</code>, identifying the row by <code>id</code>. The where-clasuse of the update statement contains the additional condition <code>AND name = %s AND city = %s</code>, where we put the old name and old city into the placeholders.</p>
<p>So when we generate the form, we do not lock the record, and we put the old name and old city into the form itself in hidden fields. When we accept the form, we check if the name and city are unchanged by comparing them against the old name and old city as they have been submitted back.</p>
<p>In case they have been changed, the update fails and the user edits are lost. Otherwise the update statement goes through. We report back the number of rows changes, 0 or 1.</p>
<p>More intelligence could be put into the function: In case we do not modify any row, we could reload the row and check if the oldname still matches - if yes, we could accept any user edit on the name field, as there is no collision. Then we could do the same with the city.</p>
<p>More intelligence could be put into the editor: In case we have any collision, we could flash and highlight the collision and allow the user to resubmit their change, resolving the conflict.</p>


	
    </article>
</div>



            <footer>
    <p>
	&copy; Copyright 2021 Someone or something
    </p>
</footer>


        </main>

	





<script src="/js/bootstrap.js"></script>




<script src="/js/lunr.js"></script>





<script src="/js/app.js"></script>


    </body>
</html>
