<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>datenbanken on Die wunderbare Welt von Isotopp</title>
    <link>/tags/datenbanken.html</link>
    <description>Recent content in datenbanken on Die wunderbare Welt von Isotopp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 25 Aug 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/datenbanken/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL: NULL is NULL</title>
      <link>/2020/08/25/null-is-null.html</link>
      <pubDate>Tue, 25 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/08/25/null-is-null.html</guid>
      <description>Question: Hey, I got a UNIQUE INDEX, but I can store multiple rows with the same value, NULL. That is surprising. Is that a bug?
 This is a rewrite of [the same in German from 9 years ago]({% link _posts/2011-11-04-null-is-null.md %}).
 root@localhost [kris]&amp;gt; create table t ( a integer, b integer, unique (a,b)); Query OK, 0 rows affected (0.09 sec) root@localhost [kris]&amp;gt; insert into t values (1, 2); Query OK, 1 row affected (0.</description>
    </item>
    
    <item>
      <title>Filling disk space fast</title>
      <link>/2019/11/11/filling-disk-space-fast.html</link>
      <pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/11/11/filling-disk-space-fast.html</guid>
      <description>Some of the databases at work are a tad on the large side, in the high 2-digit terabytes of size. Copying these to new machines at the moment takes a rather long time, multiple days, up to a week. Speeding it up pays twice, because with shorter copy times there is also less binlog to catch up.
I have been looking into disk copy speeds in order to better understand the limits.</description>
    </item>
    
    <item>
      <title>Load, Load Testing and Benchmarking</title>
      <link>/2017/02/16/load-load-testing-and-benchmarking.html</link>
      <pubDate>Thu, 16 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/02/16/load-load-testing-and-benchmarking.html</guid>
      <description>(This article also available in [german language]({% link _posts/2012-08-28-load-load-testing-und-benchmarks.md %}).)
So you have a new system and want to know what the load limits are. For that you want to run a benchmark.
Basic Benchmarking   The main plan looks like this:
The basic idea: Find a box, offer load, see what happens, learn.
You grab a box and find a method to generate load. Eventually the box will be fully loaded and you will notice this somehow.</description>
    </item>
    
    <item>
      <title>House und Heisenberg revisited</title>
      <link>/2012/09/25/house-und-heisenberg-revisited.html</link>
      <pubDate>Tue, 25 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>/2012/09/25/house-und-heisenberg-revisited.html</guid>
      <description>Ich habe heute an dem Problem weiter geforscht und wir haben etabliert, dass die Ursache nicht der Quelltext des betreffenden Diamond-Collectors sein kann.
Auf allen betroffenen Kisten habe ich dann gesehen, daß die entsprechenden Queries gegen Performance-Schema ein
mysql&amp;gt; select \* from performance_schema.threads; Empty set (0.01 sec) zurück liefern.
Weitere Untersuchung stellt heraus: P_S ist aber an. Jedoch:
mysql&amp;gt; select \* from performance_schema.setup_instruments; Empty set (0.03 sec) mysql&amp;gt; select \* from performance_schema.</description>
    </item>
    
    <item>
      <title>Der Herr House und der Herr Heisenberg haben Replication Delay</title>
      <link>/2012/09/24/der-herr-house-und-der-herr-heisenberg-haben-replication-delay.html</link>
      <pubDate>Mon, 24 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>/2012/09/24/der-herr-house-und-der-herr-heisenberg-haben-replication-delay.html</guid>
      <description>Heute erreicht mich eine Mail, in der ein DBA sich über steigende Replication Delay in einer bestimmten Replikationshierarchie beschwert.
Das ist schlecht, denn die betreffende Hierarchie ist wichtig. Also die &amp;lsquo;Wenn die nicht geht schlafen Leute unter Brücken&amp;rsquo;-Art von wichtig.
Die Theorie war, daß die Änderungsrate in dieser Hierarchie so hoch ist, daß die Schreiblast von MySQL Replikation, die ja Single Threaded ist, nicht mehr bewältigt werden kann. Für diese Theorie sprach nach dem ersten Augenschein, daß alle betroffenen Kisten keine lokalen Platten hatten, sondern auf einem Filer lagen, und Filer sterben wegen der hohen Kommunikationslatenz im SAN bei uns in der Regel weit vor lokalen Platten, wenn es um Replikation geht: Filer sind mehr so beim parallelen Schreiben mit mehreren Threads gut.</description>
    </item>
    
    <item>
      <title>Zu Besuch bei Redis</title>
      <link>/2012/09/23/zu-besuch-bei-redis.html</link>
      <pubDate>Sun, 23 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>/2012/09/23/zu-besuch-bei-redis.html</guid>
      <description>&lt;p&gt;Hier ist eine wichtige Zahl: Ein Coredump von einem MySQL auf einer Maschine
mit knapp unter 200G Speicher dauert 15 Minuten.  Auf SSD.  Auf eine
Festplatte dauert der gleiche Coredump dann knapp über 30 Minuten.&lt;/p&gt;
&lt;p&gt;Warum ist das eine wichtige Zahl?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Load, Load Testing und Benchmarks</title>
      <link>/2012/08/28/load-load-testing-und-benchmarks.html</link>
      <pubDate>Tue, 28 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>/2012/08/28/load-load-testing-und-benchmarks.html</guid>
      <description>(Diesen Artikel gibt es auch in [englischer Sprache]({% link _posts/2017-02-16-load-load-testing-and-benchmarking.md %}).)
So. Du willst also wissen, was genau die Leistungsgrenzen Deines Systems sind. Und dazu möchtest Du einen Lasttest fahren, um Ergebnisse zu ermitteln.
Die Grundidee Deines Plans sieht so aus:
Du nimmt Deine Kiste und findest eine Methode, um Last zu generieren. Dann wirst Du schon merken, wie weit das geht und wann die Kiste ausgelastet ist.
Der erste Fehler: Den Lastgenerator auf der zu testenden Kiste laufen lassen.</description>
    </item>
    
    <item>
      <title>Logging</title>
      <link>/2012/05/28/logging.html</link>
      <pubDate>Mon, 28 May 2012 00:00:00 +0000</pubDate>
      
      <guid>/2012/05/28/logging.html</guid>
      <description>&amp;ldquo;Kris&amp;rdquo;, fragt man mich, &amp;ldquo;Kris, gibt es außer &amp;lsquo;Volltextsuche&amp;rsquo; noch andere Gründe, für neue Anwendungen noch MyISAM zu verwenden? Im konkreten Fall geht es um eine verhältnismäßig einfache Datenstruktur, in die nur streng sequenziell geschrieben wird, nie gelöscht wird und viel und kreativ gelesen wird.&amp;rdquo; Na, das ist doch mal ein weites Feld.
Teile davon habe ich in [Ein paar Gedanken zu Zeitreihendaten]({% link _posts/2009-10-28-ein-paar-gedanken-zu-zeitreihendaten.md %}) und [Wie man einen Graph plottet]({% link _posts/2012-03-12-wie-man-einen-graph-plottet.</description>
    </item>
    
    <item>
      <title>Grundsätze verteilter Datenbanken</title>
      <link>/2012/03/15/grunds-tze-verteilter-datenbanken.html</link>
      <pubDate>Thu, 15 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>/2012/03/15/grunds-tze-verteilter-datenbanken.html</guid>
      <description>Wonka&amp;gt; Die Toppoint z.B. wird vermutlich nie was haben, was in nennenswerte Last-Regionen kommt, aber ich will - akademisches Interesse und so - schon wissen, wie man das da am besten täte. Was mich auch für die Toppoint interessiert: irgendeine Sorte Redundant Array of Inexpensive Databases :)
Lalufu&amp;gt; MySQL mit Replication? Alternativ mit DRBD?
Isotopp&amp;gt; Mit DRBD. Nicht mit Replikation.
Wonka&amp;gt; Lalufu: Hm, Master-Master-Replication geht ja nur mit Zweien. Wenn man nun mehr als das haben will, kann man zwar Ringe bauen, aber nur einfach verkettete.</description>
    </item>
    
    <item>
      <title>NULL is NULL</title>
      <link>/2011/11/04/null-is-null.html</link>
      <pubDate>Fri, 04 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/11/04/null-is-null.html</guid>
      <description>Q&amp;gt; Sag mal, NULL zählt nicht bei einem UNIQUE INDEX? Zum Beispiel ein UNIQUE INDEX auf (a,b) und dann
a b 1 2 1 2 Das geht nicht, da Duplikate Key. Aber
a b 1 NULL 1 NULL wird zugelassen.
Kris&amp;gt; Du kaufst bitte mal SQL für Smarties: Advanced SQL Programming und ißt das dann auf.
mysql&amp;gt; select * from t; +----+------+ | id | d | +----+------+ | 1 | NULL | | 2 | 2 | | 3 | 3 | | 4 | NULL | +----+------+ 4 rows in set (0.</description>
    </item>
    
    <item>
      <title>Checkpoint Blues</title>
      <link>/2011/09/19/checkpoint-blues.html</link>
      <pubDate>Mon, 19 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/09/19/checkpoint-blues.html</guid>
      <description>Wer [dies]({% link _posts/2008-01-30-die-innodb-storage-engine.md %}) und [dies]({% link _posts/2008-02-03-die-innodb-storage-engine-konfiguration.md %}) gelesen hat, versteht mehr.
InnoDB ist eine Storage Engine, die mit Hilfe von MVCC Transaktionen implementiert. Transaktionen zu implementieren bedeutet, daß man in der Lage ist, mehrere Änderungen zusammenzufassen und als eine Einheit als gültig zu markieren oder zurück zu nehmen. Damit das Ganze trotzdem schnell ist, muß man ein wenig herumtricksen.
Angenommen, wir wollen eine Spalte in einer Zeile in der Tabelle t ändern:</description>
    </item>
    
    <item>
      <title>Neue Releases im Datenbankland</title>
      <link>/2011/09/13/neue-releases-im-datenbankland.html</link>
      <pubDate>Tue, 13 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/09/13/neue-releases-im-datenbankland.html</guid>
      <description>MongoDB 2.0 ist draußen, und implementiert eine Reihe interessanter neuer Dinge, die ich anderswo gerne hätte, insbesondere im Bereich Replica Sets .
Postgres hat das Release 9.1 draußen. Die versprochene synchrone Replikation ist jetzt verfügbar, sie ist grob vergleichbar mit der Semisynchronen Replikation in MySQL 5.5. Ein wesentlicher Unterschied ist, daß man bei Postgres einzelne, bestimmte Server als synchrone Slaves benennen kann, während MySQL nur garantiert, daß es mindestens einen (wechselnden) Slave gibt, der synchron repliziert hat.</description>
    </item>
    
    <item>
      <title>NoSQL and No Security </title>
      <link>/2011/08/10/nosql-and-no-security.html</link>
      <pubDate>Wed, 10 Aug 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/08/10/nosql-and-no-security.html</guid>
      <description>Drüben bei Securosis arbeitet man die Black Hat 2011 unter dem Titel NoSQL and No Security auf. Es geht um die Beobachtung, daß die meisten NoSQL-Datenbanken nicht nur keinerlei Authentication haben (hat jemand so verstrahltes Zeugs schon mal in einer PCI Zone deployed?), sondern außerdem viele von ihnen auch anfällig für Server-Side JavaScript Injection (SSJI) sind.
Das soll heißen, daß die Abfragesprache der Wahl bei vielen dieser Dinge Javascript ist, daß im Datenbankserver interpretiert wird.</description>
    </item>
    
    <item>
      <title>MySQL Undo Log</title>
      <link>/2011/04/28/mysql-undo-log.html</link>
      <pubDate>Thu, 28 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/04/28/mysql-undo-log.html</guid>
      <description>&amp;ldquo;Kris, kannst Du bitte mal gucken?&amp;rdquo;
Seit heute morgen, 10:00 Uhr, wächst das Undo Log immer weiter an.
Immer wenn InnoDB Daten schreibt wird die alte Version einer Zeile aus der Tabelle in das Undo-Log verschoben, also physikalisch von der ibd-Datei der Tabelle in die ibdata1 im Datadir von MySQL. In der Tabelle wird in der veränderten Zeile ein Zeiger von der neuen Version auf die alte Version der Zeile im Undo-Log installiert, der Roll(back)-Pointer.</description>
    </item>
    
    <item>
      <title>Zusammenfassung &#39;Schemaless&#39;</title>
      <link>/2011/04/20/zusammenfassung-schemaless.html</link>
      <pubDate>Wed, 20 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/04/20/zusammenfassung-schemaless.html</guid>
      <description>Die Antwort: ALTER TABLE vs. Schemaless   ALTER TABLE in MySQL nervt. Das tut es in erster Linie, weil es die Tabellen, die es verändert, mit einem exklusiven Lock (Write Lock) belegt, während es die Änderung durchführt, und weil es die Änderung durch Umkopieren der Daten und Indices durchführt, was bei einer großen bestehenden Datenmenge doch recht lange dauern kann.
Es gibt inzwischen eine Reihe von Verbesserungen in MySQL 5.</description>
    </item>
    
    <item>
      <title>Schemaless?</title>
      <link>/2011/04/19/schemaless.html</link>
      <pubDate>Tue, 19 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/04/19/schemaless.html</guid>
      <description>Die Frage:   Ich brauche einmal Hilfe. Von Euch. Ich verstehe nämlich ein Konzept nicht. Es geht um den Begriff &amp;ldquo;Schemaless&amp;rdquo;, der im Zusammenhang mit einigen NoSQL-Datenbanken verwendet wird.
Ich kann verstehen, daß für einige Leute ein ALTER TABLE wie in MySQL ein Problem ist, weil es Tabellen während der Schemaänderung lockt. Da ALTER TABLE in vielen Fällen die Daten zur Durchführung der Änderung umkopieren muß, kann dieses Lock entsprechend lange bestehen bleiben, wenn die Daten nur hinreichend groß sind.</description>
    </item>
    
    <item>
      <title>Verteilte Datenbanken: Der Sonderfall Filialsysteme</title>
      <link>/2010/08/18/verteilte-datenbanken-der-sonderfall-filialsysteme.html</link>
      <pubDate>Wed, 18 Aug 2010 00:00:00 +0000</pubDate>
      
      <guid>/2010/08/18/verteilte-datenbanken-der-sonderfall-filialsysteme.html</guid>
      <description>In einem Kommentar zu [Master-Master]({% link _posts/2010-08-16-master-master-und-distributed-transactions.md %}) schrieb ich:
 Für den von Dir genannten Sonderfall der Filialsysteme habe ich noch einen deutschen Artikel in der Warteschlange, ich muß nur Zeit finden ihn zu schreiben.
 Normalerweise sieht MySQL Replikation so aus:
MySQL Replikation - Architekturübersicht
Master Binlog   Auf dem Master ist mit der Konfigurationsanweisung log_bin das Binlog aktiviert.
Das Binlog loggt bei Statement Based Replication (SBR) alle Anweisungen, die Daten verändern (also quasi alles außer SELECT).</description>
    </item>
    
    <item>
      <title>Die relationale Datenbank wird 40.</title>
      <link>/2010/06/08/die-relationale-datenbank-wird-40.html</link>
      <pubDate>Tue, 08 Jun 2010 00:00:00 +0000</pubDate>
      
      <guid>/2010/06/08/die-relationale-datenbank-wird-40.html</guid>
      <description>Nicht nur wird PHP im Juni 15 Jahre alt, sondern ein anderer, älterer Begleiter von PHP feiert ebenfalls ein Jubiläum:
Im Juni 1970 erschien in den Communications of the ACM der Artikel &amp;ldquo;A Relational Model of Data for Large Shared Data Banks &amp;rdquo; von E.F.Codd. Dieser Artikel ist die theoretische Grundlage für das, was später SQL und relationale Datenbanken werden sollte.
Seitdem MySQL und PHP vor 15 Jahren ausgezogen sind, das Web zu revolutionieren, ist SQL eine Haushaltssprache geworden - es ist inzwischen echt schwierig, Webspace zu kaufen, bei dem man nicht auch Zugriff auf eine MySQL-Datenbank hat, und entsprechend gehen HTML-, PHP- und SQL-Kenntnisse inzwischen einher.</description>
    </item>
    
    <item>
      <title>Ein paar Gedanken zu Zeitreihendaten</title>
      <link>/2009/10/28/ein-paar-gedanken-zu-zeitreihendaten.html</link>
      <pubDate>Wed, 28 Oct 2009 00:00:00 +0000</pubDate>
      
      <guid>/2009/10/28/ein-paar-gedanken-zu-zeitreihendaten.html</guid>
      <description>Ich sitze hier auf der Open Source Monitoring Conference und unterhalte mich mit ein paar Nagios bzw. Icinga Entwicklern. Dabei hörte ich einen Haufen Flüche über NDO - Nagios Data Out. Ich schaue mir gerade die Dokumentation zum NDO Schema an und stelle fest, daß die Ideen hier auf eine Weise viele Fehler teilen, die auch dem MySQL Enterprise Manager Schema zugrunde liegen (Noch, das MEM-Team bastelt das grad um).</description>
    </item>
    
    <item>
      <title>Ein paar Gedanken zu Foreign Key Constraints</title>
      <link>/2009/10/20/ein-paar-gedanken-zu-foreign-key-constraints.html</link>
      <pubDate>Tue, 20 Oct 2009 00:00:00 +0000</pubDate>
      
      <guid>/2009/10/20/ein-paar-gedanken-zu-foreign-key-constraints.html</guid>
      <description>Ich lese gerade SQLite Foreign Key Support und ich muß sagen, ich kann mir ein leichtes Grinsen nicht verkneifen.
Also, ich finds ja gut, daß SQLite die Option für Foreign Key Constraints implementiert und ich finds sogar noch besser, daß mit DEFERRABLE INITIALLY DEFERRED sogar die einzig sinnvolle Weise das zu tun bereitgestellt wird, aber ich frag mich schon, wozu das gut sein soll.
Foreign Keys   Aber von vorne.</description>
    </item>
    
    <item>
      <title>Zehn Zentimeter</title>
      <link>/2007/08/11/zehn-zentimeter.html</link>
      <pubDate>Sat, 11 Aug 2007 00:00:00 +0000</pubDate>
      
      <guid>/2007/08/11/zehn-zentimeter.html</guid>
      <description>Kristian, wenn Du über Performance redest, dann redest Du immer von [verteilten, asynchronen Systemen]({% link _posts/2006-07-30-leben-mit-fehlern-der-schl-ssel-zum-scaleout.md %}). Verteilte, asynchrone Systeme sind doof, schwer zu programmieren und laufen der Theorie zuwider, die ich an der Uni gelernt habe. Ich warte glaube ich lieber auf schnellere Prozessoren.
 Viel Spaß beim Warten. Godot wird Dir Deine neue CPU bestimmt bald bringen.
Ein Gigahertz ist ein Takt pro Nanosekunde. Bei Lichtgeschwindigkeit kommt das Signal in einer Nanosekunde in etwa 30cm weit.</description>
    </item>
    
    <item>
      <title>Dateisysteme und Datenbanken</title>
      <link>/2004/06/06/dateisysteme-und-datenbanken.html</link>
      <pubDate>Sun, 06 Jun 2004 00:00:00 +0000</pubDate>
      
      <guid>/2004/06/06/dateisysteme-und-datenbanken.html</guid>
      <description>Der Artikel Filesysteme sind Datenbanken von Matthias Leisi regt mich an, hier mal ein paar Sachen aufzuschreiben, die ich schon länger vor mir her kullere.
Die meisten Unix-Dateisysteme trennen eine &amp;ldquo;Gruppiere Blocks in Dateien&amp;rdquo;-Ebene (Blockverwaltung) und die &amp;ldquo;Gruppiere Dateien in Hierarchien&amp;rdquo;-Ebene (Namensraumverwaltung) voneinander. Die Blockverwaltung ist relativ gut verstanden und der I/O-Layer von Datenbanken überlegen. Die durch WinFS ausgelöste Diskussion findet stattdessen im Bereich Namensraumverwaltung statt.
Blockverwaltung und die Überlegenheit der Filesystem API   Die Ebene der Blockverwaltung bei Dateisystemen ist sehr hoch optimiert und muß akzeptable Performance unter extrem variablen Benutzungspatterns abliefern können.</description>
    </item>
    
  </channel>
</rss>
