<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linux on Die wunderbare Welt von Isotopp</title>
    <link>/tags/linux.html</link>
    <description>Recent content in linux on Die wunderbare Welt von Isotopp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 28 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>fork, exec, wait and exit</title>
      <link>/2020/12/28/fork-exec-wait-and-exit.html</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/12/28/fork-exec-wait-and-exit.html</guid>
      <description>This is the [english version of a 2007 article]({% link _posts/2007-01-07-fork-exec-wait-und-exit.md %}).
In de.comp.os.unix.linux.misc somebody asked:
  Are commands in a script executed strictly sequentially, that is, will the next command only be executed when the previous command has completed, or will the shell automatically start the next command if the system has spare capacity? Can I change the default behavior - whatever it may be - in any way?</description>
    </item>
    
    <item>
      <title>But is it atomic?</title>
      <link>/2018/11/29/but-is-it-atomic.html</link>
      <pubDate>Thu, 29 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/11/29/but-is-it-atomic.html</guid>
      <description>From Pluspora But is it atomic?   So a few days ago, a colleague asked “Why do we love files on disk?” and in the course of that discussion, I made a comment that, among other things, used the assumption that somebody is updating some file on some Linux system atomically. I wrote:
Let&amp;rsquo;s assume we are using local files, and we do so in a managed, sane way:</description>
    </item>
    
    <item>
      <title>15 Jahre zuvor...</title>
      <link>/2011/12/05/15-jahre-zuvor.html</link>
      <pubDate>Mon, 05 Dec 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/12/05/15-jahre-zuvor.html</guid>
      <description>Dezember 1996  Silvesterfeier mit dem &amp;ldquo;Hohen Rath der 13. Weisen vom Feed&amp;rdquo; und der &amp;ldquo;Allianz wieder den Hohen Rath der 13 Weisen vom Feed&amp;rdquo; in der Wassilystraße in Kiel. Ich verfasse gerade den RfD rmgroup de.talk.bizarre.
Linker Bildschirm: Linux-System, Mitte: NeXTstation (Graustufen-Display, 25 MHz 68040, 20 MB RAM, 1 GB HDD), Rechts: Storage, Tape und CD-ROM für NeXTstation.
Auf dem Schild am Regal über mir steht: &amp;ldquo;Das Kopieren von Programmen ist aus urheberrechtlichen Gründen nicht gestattet.</description>
    </item>
    
    <item>
      <title>X11 auf dem Weg nach draußen</title>
      <link>/2011/05/10/x11-auf-dem-weg-nach-drau-en.html</link>
      <pubDate>Tue, 10 May 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/05/10/x11-auf-dem-weg-nach-drau-en.html</guid>
      <description>Im September 1987 wurde die Version 11 des X-Protokolls erfunden. Damals war alles schlimm: Wir hatten keinen Speicher, keine leistungsfähigen CPUs, keine Fonts, schon gar keine Vektorfonts, keine Farbe, schon gar keine Echtfarbe ohne Paletten, keine Transparency und vor allen Dingen keine Ahnung.
X11 war für Unix das Displaysystem der Wahl. Es macht eine ganze Menge Dinge falsch: Zum Beispiel lebt es unter der Annahme, daß das Grafiksubsystem des Rechners keine Rechenpower und wenig Speicher hat.</description>
    </item>
    
    <item>
      <title>Wieviel Speicher brauchst Du denn?</title>
      <link>/2009/10/09/wieviel-speicher-brauchst-du-denn.html</link>
      <pubDate>Fri, 09 Oct 2009 00:00:00 +0000</pubDate>
      
      <guid>/2009/10/09/wieviel-speicher-brauchst-du-denn.html</guid>
      <description>Linux mapped die Speicherseiten zweiter Prozesse. Dabei wird speicher geteilt, oder Seiten sind noch ungeladen. Manche Seiten werden beim ersten Schreibzugriff kopiert (Copy-on-Write).
Manchmal muß man viel erklären, um eine einfache Frage beantworten zu können: Wieviel Speicher belegt ein Programm in Linux? Diese Frage war bisher überraschend schwer zu beantworten. Da ist einmal die Ausgabe von ps axuwww oder top:
[root@mc01bpmdb-02 ~]# ps axu | egrep &#39;(mysql[d]|USER)&#39; USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND .</description>
    </item>
    
    <item>
      <title>Unix-&#34;Standards&#34;</title>
      <link>/2009/07/26/unix-standards.html</link>
      <pubDate>Sun, 26 Jul 2009 00:00:00 +0000</pubDate>
      
      <guid>/2009/07/26/unix-standards.html</guid>
      <description>Die Geschichte von Unix ist eine Geschichte der gescheiterten oder unbrauchbaren Standards - ihre Zahl ist Legion.
Egal in welche Richtung man schaut: Sun zum Beispiel hatte einmal einen auf Postscript basierenden Desktop - NeWS , der in gewissser Weise X11 um Jahrzehnte voraus war, sich aber nie hat durchsetzen können, unter anderem deswegen, weil das Ding von Sun als Waffe gegen andere Unix-Anbieter verwendet worden war und quasi tot-lizensiert wurde, gefolgt vonOpen Look und dann dem Motif-basierenden CDE .</description>
    </item>
    
    <item>
      <title>Neue Ideen in Dateisystemen (oder: BTRFS in Fedora 11)</title>
      <link>/2009/02/06/neue-ideen-in-dateisystemen-oder-btrfs-in-fedora-11.html</link>
      <pubDate>Fri, 06 Feb 2009 00:00:00 +0000</pubDate>
      
      <guid>/2009/02/06/neue-ideen-in-dateisystemen-oder-btrfs-in-fedora-11.html</guid>
      <description>There are two kinds of fool. One says, “This is old, and therefore good..” And one says “This is new, and therefore better..”	—John Brunner, in The Shockwave Rider
 Neue Ideen in Dateisystemen sind so eine Sache. Es handelt sich bei einem Dateisystem ja um Infrastrukturcode par excellence, und so reden die meisten Leute gerne von ihrem letzten Datenverlust, wenn man sie nach Dateisystemen befragt. Das ist nicht neu, ich habe in [The Importance Of FAIL]({% link _posts/2008-05-30-the-importance-of-fail.</description>
    </item>
    
    <item>
      <title>Was bringt ext4?</title>
      <link>/2009/01/23/was-bringt-ext4.html</link>
      <pubDate>Fri, 23 Jan 2009 00:00:00 +0000</pubDate>
      
      <guid>/2009/01/23/was-bringt-ext4.html</guid>
      <description>Der Linux-Kernel 2.6.28 enthält das ext4-Dateisystem standardmäßig und sowohl Fedora als auch Ubuntu werden es unterstützen. Was bringt ext4 an Änderungen?
Ein Dateisystem ist für die meisten Benutzer eine quasi unsichtbare Sache. Es sind halt Dateien da und wenn man auf diese zugreift hat man halt Daten. So sind Dateisystem-Features für die meisten Leute also eine sehr unspektakuläre Sache. Die folgende Übersicht ist also etwas geekzentrisch.
Extents   ext2 und ext3 sind sehr traditionelle Dateisysteme, die intern im Grunde auf Technik von 1984 basieren.</description>
    </item>
    
    <item>
      <title>Historische Kernelsourcen</title>
      <link>/2008/05/27/historische-kernelsourcen.html</link>
      <pubDate>Tue, 27 May 2008 00:00:00 +0000</pubDate>
      
      <guid>/2008/05/27/historische-kernelsourcen.html</guid>
      <description>In anderen Artikeln habe ich ja schon an Hand von http://lxr.linux.no/ Strukturen im Linux-Kernel referenziert und in Erklärungen verwendet.
Auf Tamacom gibt es zum Vergleich die Quellen von Linux 2.6, FreeBSD 7, NetBSD 4.x, OpenBSD 4.x, GNU Hurd 0.3 und OpenSolaris zum verlinken. Auch liegen dort ein UNIX V7 Kernel und ein 4.3BSD rum.
Minnie hat eine schöne Sequenz wirklich alter Unix-Trees, der die Entwicklung der 70er Jahre und einige BSD-Trees miteinander vergleicht.</description>
    </item>
    
    <item>
      <title>fork und exec vs. CreateProcess</title>
      <link>/2007/01/07/fork-und-exec-vs-createprocess.html</link>
      <pubDate>Sun, 07 Jan 2007 00:00:00 +0000</pubDate>
      
      <guid>/2007/01/07/fork-und-exec-vs-createprocess.html</guid>
      <description>Disclaimer: Meine Windows-Kenntnisse sind beschränkt, veraltet und ausschließlich theoretischer Natur. Im Zweifel erzählt dieser Artikel Unsinn nach Hörensagen.
Nach dem Artikel [form, exec, wait und exit]({% link _posts/2007-01-07-fork-exec-wait-und-exit.md %}) habe ich mir aber einmal meine Kopie von Jeffrey Richters Windows - Programmierung für Experten (Advanced Windows) (1997) gegriffen und dort nachgeschlagen, wie man sich das mit den Prozessen und Programmen unter Windows vorstellt (oder jedenfalls vor 10 Jahren vorgestellt hat).</description>
    </item>
    
    <item>
      <title>fork, exec, wait und exit</title>
      <link>/2007/01/07/fork-exec-wait-und-exit.html</link>
      <pubDate>Sun, 07 Jan 2007 00:00:00 +0000</pubDate>
      
      <guid>/2007/01/07/fork-exec-wait-und-exit.html</guid>
      <description>In de.comp.os.unix.linux.misc fragte jemand:
  Werden in einem Skript die Befehle streng sequentiell ausgeführt, d.h. der nächste erst bearbeitet, wenn der Vorgänger vollständig ausgeführt ist, oder wird automatisch bei unvollständiger Auslastung des Systems bereits der nächste Befehl angefangen? Läßt sich das Standardverhalten - wie auch immer es sein mag - bei Bedarf ändern?   Wenn man in ein Shellbuch schaut, wird einem an der einen oder anderen Stelle möglicherweise erläutert, daß die Shell jeden Befehl in einem eigenen Prozeß abarbeitet.</description>
    </item>
    
    <item>
      <title>Dynamisch geladener Code</title>
      <link>/2005/10/08/dynamisch-geladener-code.html</link>
      <pubDate>Sat, 08 Oct 2005 00:00:00 +0000</pubDate>
      
      <guid>/2005/10/08/dynamisch-geladener-code.html</guid>
      <description>Inzwischen bin ich so weit, daß ich viele Unix-Kommandozeilenprogramme zwar nützlich finde, aber in einem größeren Maßstab als unhandlich und schlecht wiederzuverwenden ansehe. Das liegt daran, daß das Konzept der Pipeline und der Kommandozeile zwar sehr mächtig sind, insbesondere wenn man sie mit einer guten Shell verwendet, aber einen nur so weit bringen.
Manchmal muß man doch richtigen Code schreiben, und wenn man dann den Compiler oder auch nur eine Scriptsprache schwingen muß, dann nützen einem die ganzen Kommandozeilen-Utilities gar nichts mehr.</description>
    </item>
    
  </channel>
</rss>
