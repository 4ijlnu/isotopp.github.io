<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>architektur on Die wunderbare Welt von Isotopp</title>
    <link>/tags/architektur.html</link>
    <description>Recent content in architektur on Die wunderbare Welt von Isotopp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 15 Aug 2012 00:00:00 +0000</lastBuildDate><atom:link href="/tags/architektur/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Materialized View</title>
      <link>/2012/08/15/materialized-view.html</link>
      <pubDate>Wed, 15 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>/2012/08/15/materialized-view.html</guid>
      <description>Daten in einer SQL-Datenbank werden in einer Tabelle abgelegt, also einer Struktur mit Spalten, die Namen und in vielen Fällen auch einen Datentyp haben. Eine Tabelle besteht dann aus 0 oder mehr Zeilen, die in dieses Spaltenschema passen.
Für das Schreiben von Daten möchte man diese dann Normalform bringen, um Anomalien bei Änderungen von Daten zu verhindern und um die Datenmenge kompakt zu halten. Kompakte Daten haben den Vorteil, daß sie von der Datenbank ganz oder in wesentlichen Teilen im Speicher gehalten werden können, sodaß lediglich tatsächliche Schreibzugriffe irgendwann die Platte treffen.</description>
    </item>
    
    <item>
      <title>Automatisierung und Skalierung - Teil 2</title>
      <link>/2011/02/18/automatisierung-und-skalierung-teil-2.html</link>
      <pubDate>Fri, 18 Feb 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/02/18/automatisierung-und-skalierung-teil-2.html</guid>
      <description>Dies ist der 2. Teil zum Thema Automatisierung von Systemverwaltungsaufgaben. [Den ersten Teil gibt es hier]({% link _posts/2011-02-17-automatisierung-und-skalierung.md %}).
In jenem Text habe ich mit dem Beispiel eines Installationsservers gearbeitet und ich schrieb darüber:
 Was also wie ein wenig Gescripte aussieht, ist in Wirklichkeit die Definition und Realisierung eines Prozesses - genau genommen die Formalisierung eines Prozesses &amp;ldquo;Server aufsetzen&amp;rdquo; in der Firma. Das Ziel des Prozesses ist die Produktion einer neuen Maschine, die einer gewissen Spezifikation möglichst gut entsprechen soll.</description>
    </item>
    
    <item>
      <title>Automatisierung und Skalierung</title>
      <link>/2011/02/17/automatisierung-und-skalierung.html</link>
      <pubDate>Thu, 17 Feb 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/02/17/automatisierung-und-skalierung.html</guid>
      <description>Ich hatte im Vorfeld der OSDC 2011 eine interessante Unterhaltung mit Julian Hein zum Thema Automatisierung. Er wollte, daß ich einmal erkläre, warum man das eigentlich tut - und was man da eigentlich tut.
Die Antwort ist ein wenig länger, und weil ich dieses Jahr nicht zur OSDC fahren kann und dort auch nicht reden kann, will ich einmal versuchen, meinen Text zumindest in groben Zügen hier aufzuschreiben.
 Die Zusammenfassung ist jedenfalls, daß Automatisierung kein technisches Problem ist.</description>
    </item>
    
    <item>
      <title>The Importance Of FAIL</title>
      <link>/2008/05/30/the-importance-of-fail.html</link>
      <pubDate>Fri, 30 May 2008 00:00:00 +0000</pubDate>
      
      <guid>/2008/05/30/the-importance-of-fail.html</guid>
      <description>Wenn man mit Featureentwicklern spricht, dann reden sie immer gerne über tolle neue Dinge die sie gerade eingebaut haben.
Ich bin bei Featureentwicklern und Projektmanagern echt unbeliebt.
Ich rede gerne über Kosten, und über FAIL. Das habe ich mit vielen anderen Sysadmins, Bibliotheksentwicklern und Kernelcodern gemeinsam. Wenn man dort einmal mithört - zum Beispiel auf der Linux Kernel Mailingliste oder unter Stammtischgesprächen von Sysadmins - dann fällt einem bald etwas auf: Dort redet man in der Regel nicht von tollen neuen Features oder was jetzt optimiert worden ist, sondern dort redet man in der Regel von Fehlern, die aufgetreten sind oder von schlechtesten Fällen, und wie man sie triggert.</description>
    </item>
    
    <item>
      <title>Leben mit Fehlern - der Schlüssel zum Scaleout</title>
      <link>/2006/07/30/leben-mit-fehlern-der-schl-ssel-zum-scaleout.html</link>
      <pubDate>Sun, 30 Jul 2006 00:00:00 +0000</pubDate>
      
      <guid>/2006/07/30/leben-mit-fehlern-der-schl-ssel-zum-scaleout.html</guid>
      <description>Scaling Patterns
In 2004 habe ich auf dem Linuxtag einen kleinen Vortrag zum Thema Skalierbarkeit gehalten. Schon damals war die Message an verschiedenen Stellen im Vortrag &amp;ldquo;Jedes Readproblem ist ein Caching-Problem, jedes Schreibproblem ist ein Verteilungs- und Batchproblem&amp;rdquo;:
Zum Skalieren muß man seine Anwendung in Teilanwendungen unterteilen und die Daten replizieren. Die Replikation muß asynchron erfolgen, ohne Two Phase Commit (2PC), sonst gewinnt man wenig bis nichts. Schreibzugriffe müssen verzögert und gebatched werden, damit sie effizienter abgewickelt werden können.</description>
    </item>
    
  </channel>
</rss>
