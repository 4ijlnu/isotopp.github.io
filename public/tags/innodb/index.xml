<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>innodb on Die wunderbare Welt von Isotopp</title>
    <link>/tags/innodb.html</link>
    <description>Recent content in innodb on Die wunderbare Welt von Isotopp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 25 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/innodb/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL: automatic partitions surely would be nice</title>
      <link>/2020/09/25/mysql-dynamic-partitions-suck.html</link>
      <pubDate>Fri, 25 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/09/25/mysql-dynamic-partitions-suck.html</guid>
      <description>In [Deleting data]({% link _posts/2020-09-24-mysql-deleting-data.md %}) we have been looking at a process that loads data into MySQL, leveraging partitions to make it easier and faster to later get rid of the data again. For this, we created three processes, a data loader process, and two observers - one for creating partitions, and one for deleting them.
The observer processes have been running ANALYZE TABLES and then polling INFORMATION_SCHEMA.PARTITIONS every 1/10th of a second to check if intervention is needed.</description>
    </item>
    
    <item>
      <title>MySQL: Deleting data</title>
      <link>/2020/09/24/mysql-deleting-data.html</link>
      <pubDate>Thu, 24 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/09/24/mysql-deleting-data.html</guid>
      <description>Completing the data lifecycle is often harder than originally expected: Deleting data can cost sometimes way more than inserting it in the first place. MySQL Partitions can offer a way out. We have an [earlier post]({% link _posts/2020-05-13-deleting-data-from-mysql.md %}) on the subject.
A sample table, and a problem statement   Let&amp;rsquo;s define a kind of log table, to which data is added with an auto_increment id value and some data.</description>
    </item>
    
    <item>
      <title>MySQL: Encoding fields for great profit.</title>
      <link>/2020/09/18/mysql-encoding-fields-for-great-profit.html</link>
      <pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/09/18/mysql-encoding-fields-for-great-profit.html</guid>
      <description>Iterating schemas over time is not an uncommon thing. Often requirements emerge only after you have data, and then directed action is possible. Consequently, working on existing data, and structuring and cleaning it up is a common task.
In todays example we work with a log table that logged state transitions of things in freeform VARCHAR fields. After some time the log table grew quite sizeable, and the log strings are repeated rather often, contributing to the overall size of the table considerably.</description>
    </item>
    
    <item>
      <title>MySQL from a Developers Perspective</title>
      <link>/2020/09/07/mysql-from-a-developers-perspective.html</link>
      <pubDate>Mon, 07 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/09/07/mysql-from-a-developers-perspective.html</guid>
      <description>So this has turned into a small series, explaining how to work with MYSQL from a developers perspective. This post is intended as a directory for the individual articles. It will be amended and re-dated as necessary.
The code for the series is also available in isotopp/mysql-dev-examples on GitHub.
The Tag #mysqldev will reference all articles from this series.
  [MySQL Transactions - the physical side]({% link _posts/2020-07-27-mysql-transactions.md %}). Looking at how MySQL InnoDB handles transactions on the physical media, enabling rollback and commit.</description>
    </item>
    
    <item>
      <title>MySQL Foreign Key Constraints and Locking</title>
      <link>/2020/08/04/mysql-foreign-key-constraints-and-locking.html</link>
      <pubDate>Tue, 04 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/08/04/mysql-foreign-key-constraints-and-locking.html</guid>
      <description>Since we now know how to look at the state of locking in a live database, let&amp;rsquo;s look at what happens when we run a normal insert or update and an insert or update with foreign key relationships defined, and compare.
We will be using the tables and structures from our previous examples, a simple 1:n relationship between a and b:
CREATE TABLE a ( a_id int NOT NULL AUTO_INCREMENT, PRIMARY KEY (a_id) ); INSERT INTO a VALUES (10), (20), (30), (40); CREATE TABLE b ( b_id int NOT NULL AUTO_INCREMENT, a_id int NOT NULL, PRIMARY KEY (b_id), KEY `a_id` (a_id), CONSTRAINT a_id_exists FOREIGN KEY (a_id) REFERENCES a (a_id) ON DELETE RESTRICT ON UPDATE RESTRICT ); INSERT INTO b VALUES (10,10), (40,40); or the same definition for b without the constraint.</description>
    </item>
    
    <item>
      <title>MySQL Foreign Keys and Foreign Key Constraints</title>
      <link>/2020/08/03/mysql-foreign-keys-and-foreign-key-constraints.html</link>
      <pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/08/03/mysql-foreign-keys-and-foreign-key-constraints.html</guid>
      <description>Foreign Keys are what links tables together and turns a set of tables into a model. Foreign Key Constraints are conditions that must be true for the content of the tables to be an internally consistent model. Foreign Key Constraints can be defined and enforced in InnoDB, but this comes at a considerable price, and for some it may hurt more than it is worth.
A very simple shop as a ER-model.</description>
    </item>
    
    <item>
      <title>MySQL Deadlocks with INSERT</title>
      <link>/2020/08/02/mysql-deadlocks-with-insert.html</link>
      <pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/08/02/mysql-deadlocks-with-insert.html</guid>
      <description>Support Channel. &amp;ldquo;Hi, I am getting deadlocks in the database and they occur when I have to rollback the transactions but if we don&amp;rsquo;t have to roll back all transactions get executed.&amp;rdquo; Wait, what? After some back and forth it becomes clear that the Dev experiences deadlocks and has data:
mysql&amp;gt; pager less mysql&amp;gt; show engine innodb status\G ... MySQL thread id 142531, OS thread handle 139990258222848, query id 4799571 somehost.</description>
    </item>
    
    <item>
      <title>MySQL: Locks and Deadlocks</title>
      <link>/2020/08/01/mysql-locks-and-deadlocks.html</link>
      <pubDate>Sat, 01 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/08/01/mysql-locks-and-deadlocks.html</guid>
      <description>In a [previous article]({% link _posts/2020-07-30-mysql-transactions&amp;mdash;writing-data.md %}) we wrote data to the database using atomic update statements, and then using transactions with SELECT ... FOR UPDATE. In this article we will look at what happens when we continue doing this, in a more complicated way. Source code for this article is also available on github.com .
A simple row lock   But first let&amp;rsquo;s do things manually: We create a table kris with an integer primary key column and a secondary unindexed data column.</description>
    </item>
    
    <item>
      <title>MySQL Transactions - writing data</title>
      <link>/2020/07/30/mysql-transactions-writing-data.html</link>
      <pubDate>Thu, 30 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/07/30/mysql-transactions-writing-data.html</guid>
      <description>Using the framework for testing we created in earlier articles, let&amp;rsquo;s try to modify some data. We are writing a small program that increments a counter. Our table looks like this, and contains 10 counters:
CREATE TABLE `demo` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT, `counter` int NOT NULL DEFAULT &amp;#39;0&amp;#39;, UNIQUE KEY `id` (`id`) ) INSERT INTO `demo` VALUES (1,0); INSERT INTO `demo` VALUES (2,0); ... INSERT INTO `demo` VALUES (10,0); We are using some very simple programming to increment a counter:</description>
    </item>
    
    <item>
      <title>MySQL Transactions - the logical side</title>
      <link>/2020/07/29/mysql-transactions-the-logical-view.html</link>
      <pubDate>Wed, 29 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/07/29/mysql-transactions-the-logical-view.html</guid>
      <description>After having a look [how MySQL handles transactions physically]({% link _posts/2020-07-27-mysql-transactions.md %}), let&amp;rsquo;s have a look at what is going on from a logical point of view.
We are using a test table called demo with an id and a counter field, both integer. In it we have 10 counters, all set to 0.
CREATE TABLE `demo` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT, `counter` int NOT NULL DEFAULT &amp;#39;0&amp;#39;, UNIQUE KEY `id` (`id`) ) INSERT INTO `demo` VALUES (1,0); INSERT INTO `demo` VALUES (2,0); .</description>
    </item>
    
    <item>
      <title>MySQL Commit Size and Speed</title>
      <link>/2020/07/27/mysql-commit-size-and-speed.html</link>
      <pubDate>Mon, 27 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/07/27/mysql-commit-size-and-speed.html</guid>
      <description>When writing data to disk, for small transactions the cost of writing the commit out do disk dominates the execution time of the script. In order to show that, I wrote a little bit of Python.
The script creates a test table in a database and writes 10.000 rows of test data into it, in commit sizes of 1, 2, 4, &amp;hellip;, 1024 rows.
$ ./mysql.py --help Usage: mysql.py [OPTIONS] COMMAND [ARGS].</description>
    </item>
    
    <item>
      <title>MySQL Transactions - the physical side</title>
      <link>/2020/07/27/mysql-transactions.html</link>
      <pubDate>Mon, 27 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/07/27/mysql-transactions.html</guid>
      <description>So you talk to a database, doing transactions. What happens actually, behind the scenes? Let’s have a look.
There is a test table and we write data into it inside a transaction:
CREATE TABLE t ( id serial, data varbinary(255) ) START TRANSACTION READ WRITE INSERT INTO t ( id, data ) VALUES (NULL, RANDOM_BYTES(255)) COMMIT The MySQL test instance we are talking to is running on a Linux machine, and otherwise idle to make observation easier.</description>
    </item>
    
    <item>
      <title>A blast from the past</title>
      <link>/2019/11/18/a-blast-from-the-past.html</link>
      <pubDate>Mon, 18 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/11/18/a-blast-from-the-past.html</guid>
      <description>TL:DR: If you have long running transactions, MySQL does not deal well with this, and it will slow down the box. That&amp;rsquo;s okay as long as you are basically alone on your box, but if you aren&amp;rsquo;t, the others will hate you.
The database machine &amp;lsquo;somehierarchy-02&amp;rsquo; in a general purpose load balancer pool for somehierarchy had replication delay.
It&amp;rsquo;s a MySQL replica and is receiving the same write workload than all the other boxen in that pool.</description>
    </item>
    
    <item>
      <title>MySQL 5.6.7-RC: GTID vs. MyISAM</title>
      <link>/2012/10/02/mysql-5-6-7-rc-gtid-vs-myisam.html</link>
      <pubDate>Tue, 02 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>/2012/10/02/mysql-5-6-7-rc-gtid-vs-myisam.html</guid>
      <description>So we tested the 5.6.7-RC. And ran into a strange problem:
Because of a test, a preexisting configuration with GTID enabled existed, and suddenly we did not have properly initialized grants in mysql.* created for a new installation. Turns out: GTID and non-transactional tables are no friends, and that is even documented .
 When using GTIDs, updates to tables using nontransactional storage engines such as MyISAM are not supported. This is because updates to such tables mixed with updates to tables that use a transactional storage engine such as InnoDB can result in multiple GTIDs being assigned to the same transaction.</description>
    </item>
    
    <item>
      <title>Zu Besuch bei Redis</title>
      <link>/2012/09/23/zu-besuch-bei-redis.html</link>
      <pubDate>Sun, 23 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>/2012/09/23/zu-besuch-bei-redis.html</guid>
      <description>&lt;p&gt;Hier ist eine wichtige Zahl: Ein Coredump von einem MySQL auf einer Maschine
mit knapp unter 200G Speicher dauert 15 Minuten.  Auf SSD.  Auf eine
Festplatte dauert der gleiche Coredump dann knapp über 30 Minuten.&lt;/p&gt;
&lt;p&gt;Warum ist das eine wichtige Zahl?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Checkpoint Blues</title>
      <link>/2011/09/19/checkpoint-blues.html</link>
      <pubDate>Mon, 19 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/09/19/checkpoint-blues.html</guid>
      <description>Wer [dies]({% link _posts/2008-01-30-die-innodb-storage-engine.md %}) und [dies]({% link _posts/2008-02-03-die-innodb-storage-engine-konfiguration.md %}) gelesen hat, versteht mehr.
InnoDB ist eine Storage Engine, die mit Hilfe von MVCC Transaktionen implementiert. Transaktionen zu implementieren bedeutet, daß man in der Lage ist, mehrere Änderungen zusammenzufassen und als eine Einheit als gültig zu markieren oder zurück zu nehmen. Damit das Ganze trotzdem schnell ist, muß man ein wenig herumtricksen.
Angenommen, wir wollen eine Spalte in einer Zeile in der Tabelle t ändern:</description>
    </item>
    
    <item>
      <title>MySQL Undo Log</title>
      <link>/2011/04/28/mysql-undo-log.html</link>
      <pubDate>Thu, 28 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/04/28/mysql-undo-log.html</guid>
      <description>&amp;ldquo;Kris, kannst Du bitte mal gucken?&amp;rdquo;
Seit heute morgen, 10:00 Uhr, wächst das Undo Log immer weiter an.
Immer wenn InnoDB Daten schreibt wird die alte Version einer Zeile aus der Tabelle in das Undo-Log verschoben, also physikalisch von der ibd-Datei der Tabelle in die ibdata1 im Datadir von MySQL. In der Tabelle wird in der veränderten Zeile ein Zeiger von der neuen Version auf die alte Version der Zeile im Undo-Log installiert, der Roll(back)-Pointer.</description>
    </item>
    
    <item>
      <title>Covering indexes und MVCC</title>
      <link>/2010/09/09/covering-indexes-und-mvcc.html</link>
      <pubDate>Thu, 09 Sep 2010 00:00:00 +0000</pubDate>
      
      <guid>/2010/09/09/covering-indexes-und-mvcc.html</guid>
      <description>Für viele MySQL-Anwendungen sind Covering Indexes eine wichtige Sache. Domas hat einen Artikel darüber Wie Wikipedia von Covering Indexes profitiert , und auch sonst sind solche Indices für viele MySQLer ein täglicher Bestandteil der Optimierungsarbeit.
Nun las ich neulich in einem Artikel eine Seitenbemerkung, daß Postgres keine Covering Indices unterstützt und das scheint tatsächlich der Fall zu sein , auch wenn ich in der Doku selber keine Hinweise darauf gefunden habe.</description>
    </item>
    
  </channel>
</rss>
