<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>shell on Die wunderbare Welt von Isotopp</title>
    <link>https://blog.koehntopp.info/tags/shell.html</link>
    <description>Recent content in shell on Die wunderbare Welt von Isotopp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 08 Nov 2021 16:29:28 +0000</lastBuildDate><atom:link href="https://blog.koehntopp.info/tags/shell/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>#!/bin/bash -- Brace Expansion</title>
      <link>https://blog.koehntopp.info/2005/10/08/bin-bash-brace-expansion.html</link>
      <pubDate>Sat, 08 Oct 2005 08:43:57 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2005/10/08/bin-bash-brace-expansion.html</guid>
      <description>&lt;p&gt;Eine Unix-Kommandoshell nimmt die Benutzereingabe und unterteilt sie in Worte.
Das erste Wort einer Zeile ist ein Kommando, der Rest sind die Parameter des Kommandos.
So weit so langweilig.&lt;/p&gt;
&lt;p&gt;Interessant wird die Sache, weil eine Unix Shell gut mit Worten umgehen kann.
So kann sie Worte ersetzen und dabei auch neue Worte generieren.
Dies nennt man Expansion, und die Bash hat sehr viele Expansion-Mechanismen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brace expansion,&lt;/li&gt;
&lt;li&gt;tilde expansion,&lt;/li&gt;
&lt;li&gt;parameter expansion,&lt;/li&gt;
&lt;li&gt;variable expansion,&lt;/li&gt;
&lt;li&gt;arithmetic expansion,&lt;/li&gt;
&lt;li&gt;command substitution,&lt;/li&gt;
&lt;li&gt;word splitting und&lt;/li&gt;
&lt;li&gt;pathname expansion, sowie&lt;/li&gt;
&lt;li&gt;process substitution&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;werden in dieser Reihenfolge auf den Worten einer Zeile durchgeführt.
Nicht alle diese Mechanismen sind in einer klassischen &lt;code&gt;#!/bin/sh&lt;/code&gt; enthalten.&lt;/p&gt;
&lt;p&gt;Wenn man schnell mal ein paar Pfadnamen braucht, ist
&lt;a href=&#34;http://ebergen.net/wordpress/?p=80&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bash Brace Expansion&lt;/a&gt;


echt nützlich.
Die Grundidee ist diese:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~&amp;gt; echo a{b,c,d}e
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;abe ace ade
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das kann man benutzen, um ähnliche Dinge aufzuzählen, ohne mehr schreiben zu müssen:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/Source/tidy/src&amp;gt;ls parser.{c,h,o,lo}
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;parser.c  parser.h  parser.lo  parser.o
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Dabei ist es durchaus erlaubt, einen Teilausdruck leer zu lassen:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@h3118:/etc/httpd&amp;gt; ls -1 httpd.conf{,.old}
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;httpd.conf
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;httpd.conf.old
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Aber Brace Expansion kann noch mehr: Bestandteil des Konzeptes sind auch Ranges.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~&amp;gt; mkdir x; for i in {0..10}; do mkdir x/$i; done; ls x
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;0  1  10  2  3  4  5  6  7  8  9
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~&amp;gt; mkdir y; for i in {a..z}; do mkdir y/$i; done; ls y
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Da die Erweiterung reihenfolgetreu ist, ist es sehr leicht, zum Beispiel alte Logfiles zu rotieren. Das geht dann so:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/x&amp;gt; touch a.log
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/x&amp;gt; for i in {9..0}; do olog=a.log.$i; nlog=a.log.$(( $i+1 )); [ -f $olog ] &amp;amp;&amp;amp; mv $olog $nlog; done; mv a.log a.log.0; touch a.log; ls
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;a.log  a.log.0
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/x&amp;gt; for i in {9..0}; do olog=a.log.$i; nlog=a.log.$(( $i+1 )); [ -f $olog ] &amp;amp;&amp;amp; mv $olog $nlog; done; mv a.log a.log.0; touch a.log; ls
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;a.log  a.log.0  a.log.1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das letzte Beispiel verwendet eine weitere Bash-Expansion, Arithmethic Expansion.
Hier wird ein Ausdruck, der in &lt;code&gt;$(( ... ))&lt;/code&gt; steht, ausgerechnet und durch das Rechenergebnis ersetzt.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

