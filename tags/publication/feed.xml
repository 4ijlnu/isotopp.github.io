<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>publication on Die wunderbare Welt von Isotopp</title>
    <link>https://blog.koehntopp.info/tags/publication.html</link>
    <description>Recent content in publication on Die wunderbare Welt von Isotopp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 13 Nov 2021 19:52:56 +0000</lastBuildDate><atom:link href="https://blog.koehntopp.info/tags/publication/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Webserver Security</title>
      <link>https://blog.koehntopp.info/2000/05/01/webserver-security.html</link>
      <pubDate>Mon, 01 May 2000 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2000/05/01/webserver-security.html</guid>
      <description>&lt;p&gt;&lt;strong&gt;aus: iX 5/2000.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;webserver-security&#34;&gt;
    &lt;a href=&#34;#webserver-security&#34;&gt;
	Webserver Security
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;In den vergangenen Monaten haben Zeitschriften des Heise-Verlages immer wieder über Sicherheitslöcher in Installationen bekannter Serverbetreiber oder Webhoster berichtet.
Offensichtlich existieren tausende von Webanwendungen, die mit heißer Nadel gestrickt und online gebracht worden sind und die - wenn überhaupt - nur unzulänglich getestet worden sind.
Was ist die Ursache der beobachteten Probleme und wie kann man sie für seinen eigenen Server vermeiden?
Kann man als Verbraucher und Benutzer erkennen, ob der Server eines Anbieters elementaren Qualitätsanforderungen an die Sicherheit im Web genügt?&lt;/p&gt;
&lt;p&gt;Eine Analyse der gemeldeten Fehler zeigt, daß sich die weitaus meisten Probleme in nur drei Fehlerklassen einteilen lassen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Der Server bietet zu viele Dienste an.&lt;/li&gt;
&lt;li&gt;Der Server lagert vertrauliche Daten in zugänglichen Verzeichnissen.&lt;/li&gt;
&lt;li&gt;Der Server vertraut Eingabeparametern aus Webformularen ohne Grund.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ein-server-bietet-zu-viele-dienste-an&#34;&gt;
    &lt;a href=&#34;#ein-server-bietet-zu-viele-dienste-an&#34;&gt;
	Ein Server bietet zu viele Dienste an
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Häufig hat sich ein Betreiber einer Maschine seinen Server noch niemals mit einem der gängigen Portscanner von außen angesehen und läßt auf seinem Server Dienste laufen, die für die Benutzung der Anwendung nicht benötigt werden oder nicht von allen IP-Adressen aus zugänglich sein müssen.
Ein prominentes Beispiel der vergangenen Wochen, über das wir berichteten war ein Server, der vollständig ohne Firewall betrieben wurde und nach außen komplette Dateisysteme mit dem Sun Network Filesystem exportierte und dessen Oracle Server von jedermann kontaktiert werden konnte.
Praktischerweise fanden sich die für Oracle benötigten Paßworte auf den exportierten Netzwerklaufwerken.&lt;/p&gt;
&lt;p&gt;Oft wird dieser Fehler mit der Verwendung unsicherer und abhörbarer Übertragungsprotokolle für Wartungszugänge kombiniert:
So findet man oft auf Webserver auch POP3-Zugänge zum Abruf von Bestellmails, FTP-Zugänge zum Upload von neuen Webseiten oder gar Datenbankzugänge zum Upload neuer Bestandsdaten.
Diese Protokolle bieten vielfach nur unzulängliche Verschlüsselung von Benutzernamen und Paßworten an, von einer Verschlüsselung der eigentlichen Nutzdaten ganz zu schweigen - der msql-Datenbankserver zum Beispiel bietet nur rudimentäre bis gar keine Sicherung des Zugangs an, FTP und POP3 übertragen Paßworte oft unverschlüsselt.&lt;/p&gt;
&lt;p&gt;Ein Webmaster ist gut beraten, sich einen Zugang außerhalb seines eigentlichen Providers und Webmasters zu besorgen und sich seinen eigenen Server einmal mit den Augen und Tools eines Angreifers anzusehen.
Oft ist es so, daß Dienste in der Default-Konfiguration der Servermaschine ab Werk enthalten sind, die vom Serverbetreiber nicht erkannt und nicht abgeschaltet worden sind.
Beliebte Fehlerquellen sind zum Beispiel Webserver auf Nichtstandardports, die die Handbücher des Systems anbieten.
Diese Server enthalten sehr oft fehlerhafte CGI-Scripte oder können auf andere Weise zum Sicherheitsrisiko werden.
Eine andere beliebte Fehlerquelle ist der SNMP-Dienst (Simple Network Management Protocol), der einem potenziellen Angreifer viele Informationen über das Zielsystem liefert.
Auch Dienste, die nur zur Erstinstallation benötigt wurden, werden oft vergessen und für den Wirkbetrieb nicht abgeschaltet.&lt;/p&gt;
&lt;p&gt;Natürlich muß nicht nur der Webserver geschützt werden: Auch alle anderen Maschinen, die außerhalb der Firewall im Produktions-LAN stehen, müssen denselben Sicherheitslevel erfüllen.&lt;/p&gt;
&lt;h2 id=&#34;nmap-scan-httpwwwinsecureorgnmap&#34;&gt;
    &lt;a href=&#34;#nmap-scan-httpwwwinsecureorgnmap&#34;&gt;
	nmap-Scan (&lt;a href=&#34;http://www.insecure.org/nmap/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.insecure.org/nmap/&lt;/a&gt;

)
    &lt;/a&gt;
&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# nmap -sS -T Agressive -p 1-10000 www.beispiel1.de| grep open
Port    State       Protocol  Service
21      open        tcp       ftp
22      open        tcp       ssh
25      open        tcp       smtp
80      open        tcp       http
111     open        tcp       sunrpc
119     open        tcp       nntp
3306    open        tcp       mysql
4333    open        tcp       msql
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;&lt;code&gt;beispiel1.de&lt;/code&gt;, eigentlich ein Web- und FTP-Server, bietet außerdem die Dienste ftp, ssh, smtp, sunrpc, nntp, mysql und msql an. Davon ist ssh, ein mit starker Kryptographie verschlüsselndes und authentisierendes Protokoll, unbedenklich. Die Protokolle httpd, ftp, smtp und nntp sind die eigentlichen Dienste des Servers und müssen angeboten werden. Solange ftp nur als FTP-Server für Anon-FTP eingesetzt wird, werden keine abhörbaren Paßworte übertragen. Die sunrpc, mysql und msql-Ports von außen zugänglich zu machen ist nicht nötig. Die Ports gehören in einer Firewall oder mit einen Paketfilter gesperrt.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bei den Diensten, die man nach außen anbietet sollte man unbedingt auf aktuelle Versionen der Server achten: Buffer-Overflows und andere Probleme sind von ssh, von vielen FTP-Servern und auch von alten sendmail- und INN-Versionen bekannt.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Manchmal findet man einen offenen Port, kann aber nicht sagen, welches Programm diesen Port benutzt.
Hier ist ein Tool wie &lt;code&gt;lsof&lt;/code&gt; sehr nützlich.
Alle lokal offenen Ports und die dazugehörigen Programme kann man mit dem Kommando &lt;code&gt;lsof -P -n -i&lt;/code&gt; auflisten.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# lsof -P -n -i
COMMAND    PID USER   FD   TYPE DEVICE SIZE NODE NAME
xfstt       46 root    4u  IPv4     30       TCP *:7100 (LISTEN)
httpd      199 root   19u  IPv4     99       TCP 193.102.57.12:80 (LISTEN)
...
smbd     11741 root    5u  IPv4  28694       UDP 127.0.0.1:1180
smbd     11741 root    6u  IPv4  28689       TCP 193.102.57.3:139-&amp;gt;193.102.57.2:1044 (ESTABLISHED)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Durch die Angabe von Suchoptionen kann man gezielt nach Protokoll und Port suchen:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# lsof -P -n -i tcp:139
COMMAND   PID USER   FD   TYPE DEVICE SIZE NODE NAME
smbd      276 root    5u  IPv4    175       TCP *:139 (LISTEN)
smbd    11741 root    6u  IPv4  28689       TCP 193.102.57.3:139-&amp;gt;193.102.57.2:1044 (ESTABLISHED)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;dump-einer-zone-mit-nslookup&#34;&gt;
    &lt;a href=&#34;#dump-einer-zone-mit-nslookup&#34;&gt;
	Dump einer Zone mit nslookup
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Um festzustellen, welche Rechner in einer Domain stehen, kann man mit einem Tool wie nmap das ganze Teilnetz durchprüfen, in dem ein Server steht.
Alternativ kann man sich auch die Daten im DNS ansehen, die ein Serverbetreiber über seine Domain veröffentlicht.&lt;/p&gt;
&lt;p&gt;Am Beispiel der Domain &lt;code&gt;beispiel1.de&lt;/code&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# nslookup

&amp;gt; set type=ns
&amp;gt; www.beispiel1.de.
Server:  nuki.netuse.de
Address:  193.98.110.1

beispiel1.de
        origin = ns.beispiel1.de
        mail addr = postmaster.ns.beispiel1.de
        serial = 2000032201
        refresh = 10800 (3H)
        retry   = 3600 (1H)
        expire  = 604800 (1W)
        minimum ttl = 86400 (1D)
&amp;gt; server ns.beispiel1.de
Default Server:  ns.beispiel1.de
Address:  192.168.254.37

&amp;gt; ls beispiel1.de.
[ns.beispiel1.de]
$ORIGIN beispiel1.de.
@                       1D IN A         192.168.253.131
wwwtest                 1D IN A         192.168.253.135
news                    1D IN A         192.168.253.136
localhost               1D IN A         127.0.0.1
listserv                1D IN A         192.168.253.136
...
igate                   1D IN A         192.168.254.34
daiquiri                1D IN A         192.168.254.61
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Durch &lt;code&gt;set type=ns&lt;/code&gt; (Nameserver) sagen wir &lt;code&gt;nslookup&lt;/code&gt;, daß wir ausschließlich Informationen über Nameserver einer Domain haben möchten.
Wir fragen dann mit &lt;code&gt;www.beispiel1.de.&lt;/code&gt; nach den Nameservern der Domain &lt;code&gt;beispiel1.de&lt;/code&gt;.
Dies ist nur ein einzelner Server, nämlich &lt;code&gt;ns.beispiel1.de&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Wir sagen nun mit Hilfe des Kommandos &lt;code&gt;server ns.beispiel1.de&lt;/code&gt;, daß &lt;code&gt;nslookup&lt;/code&gt; alle weiteren Fragen an diesen Server richten soll.
Mit Hilfe des Kommandos &lt;code&gt;ls beispiel1.de&lt;/code&gt; fordern wir ein Listing der gesamten Zone &lt;code&gt;beispiel1.de&lt;/code&gt; an.
Wir erhalten eine Liste aller Hostnamen und IP-Nummern, die der Betreiber der Domain &lt;code&gt;beispiel1.de&lt;/code&gt; veröffentlicht.&lt;/p&gt;
&lt;p&gt;Besser konfigurierte Nameserver erlauben ab BIND8, Zonetransfers auf die Secondary-Server einer Domain einzuschränken.
&lt;code&gt;ls&lt;/code&gt;-Kommandos von anderen Hosts schlagen dann fehl.
Hat eine Domain mehrere Nameserver, ist es unter Umständen lohnend, diese nacheinander durchzuprobieren:
Vielfach ist der Primary Nameserver restriktiv konfiguriert, aber die Secondaries geben einem dennoch ein Listing der Zone.&lt;/p&gt;
&lt;p&gt;Sicherheitsbewußte Netzbetreiber setzen Nameserver für das Internet und ihr Intranet getrennt auf.
Schließlich braucht es niemanden zu interessieren, welche Rechner in den Büros einer Firma laufen und wie diese heißen.
Stattdessen ist vollkommen ausreichend, die Namen und Nummern der Rechner zu publizieren, die Dienste für die Öffentlichkeit bringen, also etwa der Web-, der Name- und der Mailserver einer Domain.&lt;/p&gt;
&lt;h2 id=&#34;netzwerk-kartierung-mit-cheops&#34;&gt;
    &lt;a href=&#34;#netzwerk-kartierung-mit-cheops&#34;&gt;
	Netzwerk-Kartierung mit Cheops
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/05/net.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Mit Hilfe des Gnome-Programmes Cheops bekommt man schnell einen graphischen Netzplan mit Rechnertypen und Verbindungen.
Das Programm kann auch eingesetzt werden, um Portscans von Rechnern durchzuführen, ist hier aber nicht so vielseitig wie nmap.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;unverschlüsselte-verbindung-in-ethereal&#34;&gt;
    &lt;a href=&#34;#unverschl%c3%bcsselte-verbindung-in-ethereal&#34;&gt;
	Unverschlüsselte Verbindung in Ethereal
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/05/ethereal.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Mit Hilfe des Netzwerkmonitors Ethereal ist die Analyse von Netzwerkpaketen möglich. Mit Hilfe der Stromverfolgung können dabei die Klartextpaßworte in Protokollen wie TELNET, FTP, POP3 und anderen sehr gut sichtbar gemacht werden.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;rpcinfo-anfrage-an-wwwbeispiel1deh3a&#34;&gt;
    &lt;a href=&#34;#rpcinfo-anfrage-an-wwwbeispiel1deh3a&#34;&gt;
	rpcinfo-Anfrage an &lt;a href=&#34;http://www.beispiel1.de&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;www.beispiel1.de&lt;/a&gt;

&lt;/h3&gt;&lt;/a&gt;
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Mit Hilfe der Tools &lt;code&gt;rpcinfo&lt;/code&gt; und &lt;code&gt;showmount&lt;/code&gt; (Linux: auch &lt;code&gt;kshowmount&lt;/code&gt;) kann man abfragen, welche Dienste der &lt;code&gt;sunrpc&lt;/code&gt;-Dienst  erbringt.
Falls das SUN Network Filesystem (NFS) zu diesen Diensten gehört, kann man weiterfragen, welche Dateisysteme und für wen exportiert werden.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# rpcinfo -p www.beispiel1.de
   program vers proto   port
    100000    4   tcp    111  portmapper
    100000    3   tcp    111  portmapper
    100000    2   tcp    111  portmapper
    100000    4   udp    111  portmapper
    100000    3   udp    111  portmapper
    100000    2   udp    111  portmapper
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Wie man sieht, redet der &lt;code&gt;sunrpc&lt;/code&gt;-Dienst von &lt;code&gt;www.beispiel1.de&lt;/code&gt; mit externen Rechnern.
Das ist nicht notwendig und der Dienst kann blockiert werden, etwa durch eine Firewall oder durch Konfiguration entsprechender Filtermechanismen.&lt;/p&gt;
&lt;p&gt;Eine sehr häufige Fehlkonfiguration besteht darin, Verzeichnisse mit NFS weltweit les- und schreibbar freizugeben.
Beispielhaft unsicher die Server von &lt;code&gt;beispiel2.de&lt;/code&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# /usr/sbin/kshowmount -e rzserv2.beispiel2.de
Export list for rzserv2.beispiel2.de:
/usr/lib/cobol       (everyone)
/usr/sys/inst.images (everyone)
/stadtinf            (everyone)
/var/spool/mail      (everyone)
/usr/lpp/info        (everyone)
/usr/local           (everyone)
/pd-software         (everyone)
/u1                  (everyone)
/user                (everyone)
/fix                 (everyone)
/u                   (everyone)
/ora                 rzws01
/install             (everyone)
/ora-client          192.168.252.20
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Die mit &lt;code&gt;everyone&lt;/code&gt; gelisteten Verzeichnisse, darunter die Mail und die Homeverzeichnisse der Benutzer, sind weltweit les- und schreibbar.
Durch Zugriffe auf die &lt;code&gt;/usr/local&lt;/code&gt; und &lt;code&gt;/usr/lib/cobol&lt;/code&gt;-Verzeichnisse lassen sich Systembibiotheken und Systemprogramme austauschen, sodaß das ganze System ohne nennenswerten Widerstand sofort einnehmbar ist.
Tauscht man Daten im &lt;code&gt;/install&lt;/code&gt;-Verzeichnis aus, sind auch alle Clients subvertiert, die von dieser Maschine installiert werden.
Das System ist durch seine fahrlässig offene Konfiguration also die ideale Ausgangsbasis für weitere Angriffe gegen andere Netzwerke.&lt;/p&gt;
&lt;h2 id=&#34;snmp-abfragen-an-ein-entferntes-system&#34;&gt;
    &lt;a href=&#34;#snmp-abfragen-an-ein-entferntes-system&#34;&gt;
	SNMP-Abfragen an ein entferntes System
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;SNMP gehört zu den Diensten, die einem Angreifer ein Höchstmaß an Information liefern können und die in Standardinstallationen oft nicht abgeschaltet und unzureichend gesichert werden.
Zudem läuft der Dienst über UDP, das von vielen Portscannern nicht per Default gescannt wird.
Daher taucht der Dienst auf dem Radar vieler Systemadministratoren nicht auf.&lt;/p&gt;
&lt;p&gt;Wieder dienen die Server von &lt;code&gt;beispiel2.de&lt;/code&gt; als abschreckendes Beispiel:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# snmpwalk rzserv2.beispiel2.de public
system.sysDescr.0 = OCTET STRING: &amp;quot;Fore Systems ATM Host (AIX 1 000005016600)&amp;quot;
system.sysObjectID.0 = OBJECT IDENTIFIER: enterprises.326.2.1
system.sysUpTime.0 = Timeticks: (0) 0:00:00
system.sysContact.0 = OCTET STRING: &amp;quot;&amp;quot;
system.sysName.0 = OCTET STRING: &amp;quot;rzserv2.&amp;quot;
system.sysLocation.0 = OCTET STRING: &amp;quot;&amp;quot;
system.sysServices.0 = INTEGER: 72
interfaces.ifNumber.0 = INTEGER: 7
interfaces.ifTable.ifEntry.ifIndex.1 = INTEGER: 1
interfaces.ifTable.ifEntry.ifIndex.2 = INTEGER: 2
interfaces.ifTable.ifEntry.ifIndex.3 = INTEGER: 3
interfaces.ifTable.ifEntry.ifIndex.4 = INTEGER: 4
interfaces.ifTable.ifEntry.ifIndex.5 = INTEGER: 5
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Wir erfahren hier nicht nur den Typ und Patchlevel des Systems, sondern (nicht gezeigt) auch eine Liste der Interfaces und Routingkonfiguration des Systems - wir bekommen also detaillierte Information über die Topologie des Zielnetzes.
Zusammen mit Daten aus dem DNS gibt uns das einen genauen Netzplan des potentiellen Opfers.
Wenn weitere Management Module installiert sind, bekommen Zugriff auf weitere Subsysteme, etwa Oracle, SAP oder andere fernzuüberwachende Einheiten.
SNMP wird auch in vielen Routern und in RMON Netzwerkprobes eingesetzt - ein Eindringling kann so sogar Verkehrsdaten aus dem Netz erfahren, wenn diese nicht gesichert worden sind.&lt;/p&gt;
&lt;h2 id=&#34;ein-server-lagert-vertrauliche-daten-in-zugänglichen-verzeichnissen&#34;&gt;
    &lt;a href=&#34;#ein-server-lagert-vertrauliche-daten-in-zug%c3%a4nglichen-verzeichnissen&#34;&gt;
	Ein Server lagert vertrauliche Daten in zugänglichen Verzeichnissen
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Eine weitere beliebte Fehlerklasse besteht in vertraulichen Daten, die in durch den Webserver zugänglichen Verzeichnissen gelagert werden.
Häufig bieten Webspace-Provider virtuelle Webserver an, bei denen die Wurzel des durch den Anwender beschreibbaren Bereiches (etwa: &lt;code&gt;/home/www/servers/www.kunde.de/&lt;/code&gt;, für den Kunden sichtbar als &lt;code&gt;/&lt;/code&gt;) auch die Wurzel des virtuellen Servers ist (etwa: &lt;code&gt;http://www.kunde.de/&lt;/code&gt;).
Legt der Kunde jetzt Daten unterhalb seines Wurzelverzeichnisses ab (etwa eine Datei &lt;code&gt;/passwd&lt;/code&gt;) dann ist diese Datei auch durch den Webserver abrufbar, denn sie liegt ja unterhalb der Document Root und hat eine URL (etwa: &lt;code&gt;http://www.kunde.de/passwd&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Viele Webshops schreiben Bestellungen in ein oder mehrere Logverzeichnisse oder haben Konfigurationsdateien mit Paßworten und Artikeldaten.
Liegen diese Daten unterhalb der Document Root, dann haben sie URLs und sind zunächst einmal prinzipiell über das Web abrufbar, sofern es einem Angreifer gelingt den Namen zu raten.
Kennt man den Namen und die Version der verwendeten Websoftware, ist dies meist sehr einfach zu machen.&lt;/p&gt;
&lt;p&gt;Prinzipielle Abhilfe schaffen hier nur Hostingumgebungen, bei denen die Document Root des Webservers tiefer als die Wurzel des Kundenverzeichnisses liegt (etwa ab &lt;code&gt;/home/www/servers/www.kunde.de/pages&lt;/code&gt;).
Nun kann der Kunde weitere Verzeichnisse oberhalb der Document Root anlegen (etwa: &lt;code&gt;/home/www/servers/www.kunde.de/shop&lt;/code&gt;) und seine vertraulichen Daten dort speichern.
Da diese Verzeichnisse über das Wartungs-FTP, nicht aber mit HTTP zugänglich sind, können sie nicht so einfach abgerufen werden.&lt;/p&gt;
&lt;p&gt;Alternativ legt man Verzeichnisse unterhalb der Document Root an und verbietet den Zugriff per HTTP auf das Verzeichnis durch Anlegen einer &lt;code&gt;.htaccess&lt;/code&gt;-Datei (Apache-Webserver).
Die Datei sollte den Zugriff von überall verbieten:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ cat /shop/.htaccess
order deny, allow
deny from all
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Daten können dann nur noch über FTP abgerufen werden. Für FTP gelten &lt;code&gt;.htaccess&lt;/code&gt;-Dateien nicht.&lt;/p&gt;
&lt;h2 id=&#34;ein-server-vertraut-eingabeparametern-aus-webformularen-ohne-grund&#34;&gt;
    &lt;a href=&#34;#ein-server-vertraut-eingabeparametern-aus-webformularen-ohne-grund&#34;&gt;
	Ein Server vertraut Eingabeparametern aus Webformularen ohne Grund
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Die dritte häufige Fehlerklasse besteht darin, in CGI-Programmen Parameter aus dem Web zu übernehmen und ohne Prüfung zu verwenden.&lt;/p&gt;
&lt;p&gt;Eine Webanwendung besteht aus Komponenten die innerhalb der Firewall liegen und als vertrauenswürdig gelten können, weil sie durch den lokalen Administrator kontrolliert werden.
Dazu gehören etwa die lokalen Scripte, die Datenbank, der Webserver und lokale Datendateien.
Dazu kommen dann weitere Komponenten, die außerhalb der Firewall liegen und die grundsätzlich als nicht vertrauenswürdig gelten können.
Das ist hauptsächlich der Browser des Anwenders, wenn er denn einen benutzt und seinen Webrequest zwecks Hackangriff nicht direkt in ein Telnet tippt.
Die Firewall markiert eine Vertrauensgrenze, eine Trust Boundary.&lt;/p&gt;
&lt;p&gt;Daten von jenseits der Vertrauensgrenze kann eine Webanwendung nicht ohne Prüfung vertrauen.
Dazu gehören alle Parameter, die dem CGI-Script übergeben werden, also alle GET-, POST- oder COOKIE-Parameter, der HTTP_REFERER, der HTTP_USER_AGENT und alle weiteren Werte von außen.
Alle diese Werte müssen vor der Verwendung durch ein CGI-Script durch eine Gültigkeitsprüfung, in der sichergestellt wird, daß die Daten auch das erwartete Format haben und gültige Werte besitzen.&lt;/p&gt;
&lt;p&gt;Zum Beispiel ist es gängige Praxis, daß bestimmte Scripte Werte nur dann akzeptieren, wenn bei der Übergabe der HTTP_REFERER des Aufrufes korrekt ist.
Auf diese Weise versucht sich das Script gegen gefälschte Aufrufe zu schützen.
Natürlich ist es für einen potentiellen Angreifer überhaupt gar kein Problem außer den Scriptparametern auch noch jeden gewünschten HTTP_REFERER mit zu übergeben - der Schutz ist also wirkungslos.
Korrekt wäre, wenn das Script jeden übergebenen Parametern einzeln prüft.&lt;/p&gt;
&lt;p&gt;Eine andere häufig verwendete Technik besteht darin, Parameter von einer Seite zur nächsten als &lt;code&gt;&amp;lt;INPUT TYPE=&amp;quot;HIDDEN&amp;quot;&amp;gt;&lt;/code&gt; mitzuschleifen.
Dabei wird interner Zustand der Anwendung im Browser des Anwenders gehalten, also jenseits der Trust Boundary.
Für den Anwender ist es ein leichtes, den Zustand einer solchen Anwendung zu manipulieren und jeden gewünschten Effekt zu bewirken.
Korrekt wäre, eine Plattform zu verwenden, die Sessionvariablen bietet und den Zustand der Anwendung auf dem Webserver halten kann (etwa: Microsoft ASP mit dem Session-Objekt, PHP3 mit PHPLIB, PHP4 mit den
&lt;code&gt;session_*()&lt;/code&gt;-Funktionen oder einen richtigen Application-Server).&lt;/p&gt;
&lt;h2 id=&#34;fazit&#34;&gt;
    &lt;a href=&#34;#fazit&#34;&gt;
	Fazit
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Webmaster sind gut beraten, alle ihre Installationen auf diese drei Fehlerklassen abzuprüfen und ihre Anwendungen gegebenenfalls anzupassen.
Gestohlene Kreditkartendaten oder gar geknackte Server, die als Ausgangspunkt für weitere Angriffe dienen, sind nicht nur peinlich:
Derartige Installationen sind fahrlässig unsicher und dem betroffenen Betreiber stehen mit großer Wahrscheinlichkeit Klagen auf Schadenersatz oder Beihilfe zum Computereinbruch ins Haus.&lt;/p&gt;
&lt;p&gt;Für den Laien ist dies keine Alternative:
Die Sicherheit eines Servers zu verifizieren setzt nicht nur umfassende technische Kenntnisse, sondern auch Zugang zum Server voraus.
Letztendlich kann nur ein technisches Gütesiegel, das auf Grundlage einer technischen Überprüfung der Server und aller darauf laufenden Anwendungen erteilt wird dem Verbraucher mitteilen, daß er es mit einer seriösen Installation zu tun hat.&lt;/p&gt;
&lt;h1 id=&#34;referenzen&#34;&gt;
    &lt;a href=&#34;#referenzen&#34;&gt;
	Referenzen:
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href=&#34;http://www.koehntopp.de/kris/artikel/webtune/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.koehntopp.de/kris/artikel/webtune/&lt;/a&gt;

:&lt;/dt&gt;
&lt;dd&gt;&amp;ldquo;Webserver verstehen und tunen&amp;rdquo;&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&#34;http://www.koehntopp.de/php/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.koehntopp.de/php/&lt;/a&gt;

:&lt;/dt&gt;
&lt;dd&gt;&amp;ldquo;de.comp.lang.php - Häufig gestellte Fragen&amp;rdquo;&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&#34;http://www.insecure.org/nmap/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.insecure.org/nmap/&lt;/a&gt;

:&lt;/dt&gt;
&lt;dd&gt;&amp;ldquo;NMAP Port Scanner&amp;rdquo;&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&#34;http://ethereal.zing.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://ethereal.zing.org/&lt;/a&gt;

:&lt;/dt&gt;
&lt;dd&gt;&amp;ldquo;Ethereal Network Monitor&amp;rdquo;&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&#34;http://www.marko.net/cheops/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.marko.net/cheops&lt;/a&gt;

:&lt;/dt&gt;
&lt;dd&gt;&amp;ldquo;Ceops Network Mapper&amp;rdquo;&lt;/dd&gt;
&lt;dt&gt;&lt;a href=&#34;http://freshmeat.net/appindex/1998/04/06/891857252.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://freshmeat.net/appindex/1998/04/06/891857252.html&lt;/a&gt;

:&lt;/dt&gt;
&lt;dd&gt;&amp;ldquo;lsof - list open files&amp;rdquo;&lt;/dd&gt;
&lt;dt&gt;&amp;ldquo;TCP/IP Illustrated, Volume 1: The Protocols&amp;rdquo;:&lt;/dt&gt;
&lt;dd&gt;W. Richard Stevens, Addison-Wesley&lt;/dd&gt;
&lt;dt&gt;&amp;ldquo;Hacking Exposed - Network Security Secrets &amp;amp; Solutions&amp;rdquo;:&lt;/dt&gt;
&lt;dd&gt;McClure, Scambray and Kurtz, Osborne&lt;/dd&gt;
&lt;dt&gt;&amp;ldquo;Maximum Linux Security&amp;rdquo;:&lt;/dt&gt;
&lt;dd&gt;Anonymous, Sams&lt;/dd&gt;
&lt;/dl&gt;
</description>
    </item>
    
    <item>
      <title>Samba</title>
      <link>https://blog.koehntopp.info/1996/01/11/samba.html</link>
      <pubDate>Thu, 11 Jan 1996 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/1996/01/11/samba.html</guid>
      <description>&lt;p&gt;&lt;strong&gt;erschienen in der iX 1/96&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#samba-19&#34;&gt;Text des Artikels&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#samba-im-internet&#34;&gt;Samba im Internet&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#eine-standardkonfiguration&#34;&gt;Eine Standardkonfiguration&lt;/a&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;samba-19&#34;&gt;
    &lt;a href=&#34;#samba-19&#34;&gt;
	Samba 1.9
    &lt;/a&gt;
&lt;/h1&gt;
&lt;h4 id=&#34;samba-ist-ein-softwarepaket-für-unix-das-microsoft-lan-manager-server-funktionen-erbringt-ursprünglich-von-andrew-tridgell-einem-studenten-an-der-australian-national-university-canberra-erstellt-ist-es-inzwischen-unter-der-gnu-general-public-license-verfügbar&#34;&gt;
    &lt;a href=&#34;#samba-ist-ein-softwarepaket-f%c3%bcr-unix-das-microsoft-lan-manager-server-funktionen-erbringt-urspr%c3%bcnglich-von-andrew-tridgell-einem-studenten-an-der-australian-national-university-canberra-erstellt-ist-es-inzwischen-unter-der-gnu-general-public-license-verf%c3%bcgbar&#34;&gt;
	Samba ist ein Softwarepaket für Unix, das Microsoft Lan Manager Server-Funktionen erbringt. Ursprünglich von Andrew Tridgell, einem Studenten an der Australian National University, Canberra erstellt, ist es inzwischen unter der GNU General Public License verfügbar.
    &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;Andrew Tridgell, ein Student an der Australian National University Canberra, stand Ende 1991 vor dem Problem, einen Fileserver für SUN Workstations haben zu müssen, der zu DEC Pathworks für kompatibel ist.
Ohne Informationen über die Art des verwendeten Protokolls zu haben, gelang es ihm schon nach wenigen Tagen, das verwendete Protokoll in Teilen zu reverse engineeren.
Erst nachdem eine allererste Version seines Servers schon fertiggestellt war, wies man ihn auf das in RFC 1001 und 1002 definierte &amp;ldquo;NetBIOS on a TCP/UDP transport&amp;rdquo; Protokoll hin.
Im Januar wurde die erste Version seines &amp;ldquo;Server 0.1&amp;rdquo; Paketes auf dem Netz veröffentlicht.
Es sollte jedoch noch bis Ende 1993 dauern, bis Tridgell durch den Einsatz von Linux und die Notwendigkeit, mit PCs unter DOS, Windows und OS/2 zu kommunizieren, die Weiterentwicklung von Samba wieder aufnahm.&lt;/p&gt;
&lt;p&gt;Heute ist Samba ein relativ ausgereiftes, standardkonformes und vor allen Dingen hochportables Softwarepaket, das auf den meisten UNIX-Versionen problemlos installierbar ist und die Möglichkeit bietet, Verzeichnisse und Drucker an PC-Betriebssysteme zu exportieren.
Samba konkurriert hier mit dem von SUN definierten Network File System (NFS).&lt;/p&gt;
&lt;p&gt;Für den Systemadministrator in einem heterogenen Netzwerk von UNIX-Servern und Client-PCs ist Samba dabei wahrscheinlich attraktiver als NFS, denn in den meisten Fällen stehen wenigen UNIX-Servern viele Client-PCs gegenüber.
Beim Einsatz von NFS könnte zwar das mit den meisten UNIX-Versionen mitgelieferte Serverpaket verwendet werden, aber für die Clients müßten nicht nur viele Client-Lizenzen von PC-NFS oder etwas vergleichbarem angeschafft werden, sondern diese Software müßte auch netzwerkweit installiert und gewartet werden.
Windows für Workgroups, Windows 95, Windows NT und OS/2 sprechen aber schon von Haus aus das Lan Manager Protokoll und so ist es effizienter, den wenigen Servern dieses Protokoll beizubringen und auf den Clients mitgelieferte Software zu verwenden.
Diesen Weg geht Samba.&lt;/p&gt;
&lt;p&gt;Da der Samba-Server ein reiner Usermode-Server ist, also ein ganz normales Anwendungsprogramm, ist es möglich, auch Verzeichnisse per Samba zu reexportieren, die der Server per NFS gemountet hat.
Auf diese Weise entsteht eine Protokollbrücke von NFS nach SMB.
Dabei ist natürlich der Performanceverlust durch doppelten Netzzugriff in Kauf zu nehmen.
Auf der anderen Seite ist Samba unter der GNU GPL frei zur Verfügung stehende Software und so steht der Installation des Samba-Servers auf allen Servermaschinen nichts im Weg.&lt;/p&gt;
&lt;p&gt;Es soll jedoch nicht verschwiegen werden, daß Samba aus der Sicht eines UNIX-Systemverwalters schwerwiegende Nachteile hat.
Als Protokoll, das in der PC-Welt entstanden ist, kennt Samba kein Konzept eines Dateieigentümers.
Die Zugriffe auf Ressourcen erfolgen oft mit unklaren Userrechten oder scheinbar willkürlich gewählten Paßworten.
Betriebssysteme wie Windows für Workgroups und Windows&#39;95, die dem Benutzer zwar einen Namen geben, dann aber Netzwerkzugriffe ohne oder unter anderen Namen erzeugen, machen die Sache nicht leichter.
Dazu kommt, daß die Familie der Windows-Betriebssysteme die Groß-/Kleinschreibung von Paßworten in einigen Kombinationen von Betriebssystem/Paßwort verändern.
Samba hat eine ganze Reihe Mechanismen, um diesem Problem abzuhelfen, aber der Verwaltungsaufwand ist anfangs trotzdem höher als bei einer typischen NFS-Installation.&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1996/01/SuperNOS.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Novell hat versucht, das Super Network Operating System durch Verschmelzung der zugekauften UNIX-Quellen mit ihrem eigenen Serverbetriebssystem zu bauen und ist gescheitert. Klammheimlich hat das frei verfügbare Linux gelernt, die meisten Netzwerkprotokolle zu sprechen und ist auf dem besten Wege, eben dieses SuperNOS zu werden.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;installation&#34;&gt;
    &lt;a href=&#34;#installation&#34;&gt;
	Installation
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Die Installation gestaltet sich relativ einfach.
Nach dem Auspacken ist das Makefile im &lt;code&gt;source/&lt;/code&gt;-Verzeichnis nach den eigenen Wünschen anzupassen.
Dabei ist es hilfreich, nicht nur die gewünschten Pfadnamen einzutragen, sondern auch schon den Namen der gewünschten Arbeitsgruppe in der Variablen &lt;code&gt;WORKGROUP&lt;/code&gt; einzutragen und einen speziellen  Gastaccount, der nur für SMB genutzt wird, in &lt;code&gt;GUESTACCOUNT&lt;/code&gt; einzucompilieren.
Diese Defaults sind zwar auch zur Laufzeit änderbar, aber anpassen im Quelltext erspart das Schreiben von Konfigurationsdateien.
Weiterhin sind noch die gewünschten &lt;code&gt;make&lt;/code&gt;-Optionen für den verwendeten Betriebssystemtyp zu aktivieren.
Danach steht einem &lt;code&gt;make&lt;/code&gt; nichts mehr im Wege.&lt;/p&gt;
&lt;p&gt;Erzeugt werden die Programme&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;nmbd:&lt;/dt&gt;
&lt;dd&gt;NetBios Name Server. Der Name Server ist in der Lage, Hostnamen auf IP-Nummern abzubilden. Gleichzeitig steuert das Programm aber auch das Browsing, d.h. die Anzeige von exportierten Diensten und übernimmt damit Aufgaben, die bei NFS der &lt;code&gt;mountd&lt;/code&gt; wahrnehmen würde.&lt;/dd&gt;
&lt;dt&gt;nmblookup:&lt;/dt&gt;
&lt;dd&gt;NetBios Name Lookup. Das Programm nimmt in etwa dieselbe Funktion wahr wie &lt;code&gt;nslookup&lt;/code&gt; für das DNS, fragt jedoch einen &lt;code&gt;nmbd&lt;/code&gt; ab.&lt;/dd&gt;
&lt;dt&gt;smbclient:&lt;/dt&gt;
&lt;dd&gt;Samba Client. Dient dazu, auf Linux-Seite einen SMB Server zu connecten und Dateien zu übertragen. Die Steuerung erfolgt ähnlich wie bei FTP. Linux bietet auch ein echtes, kernelbasiertes &lt;code&gt;smbfs&lt;/code&gt; an, mit dem man einen Server richtig mounten kann. Andere Betriebssysteme sind auf den &lt;code&gt;smbclient&lt;/code&gt; angewiesen.&lt;/dd&gt;
&lt;dt&gt;smbd:&lt;/dt&gt;
&lt;dd&gt;Der eigentliche Fileserver.&lt;/dd&gt;
&lt;dt&gt;smbpasswd:&lt;/dt&gt;
&lt;dd&gt;Ein Hilfsprogramm des &lt;code&gt;smbd&lt;/code&gt;, mit dem Benutzer vom Client aus ihr Paßwort ändern können sollen. Es hat nur dann Funktion, wenn Samba mit der &lt;code&gt;libdes&lt;/code&gt; und verschlüsselten Paßworten (siehe &lt;strong&gt;Samba im Internet&lt;/strong&gt;) übersetzt wurde.&lt;/dd&gt;
&lt;dt&gt;smbrun:&lt;/dt&gt;
&lt;dd&gt;Ein Hilfsprogramm des &lt;code&gt;smbd&lt;/code&gt;, mit dem Samba zu Beginn und Ende einer Serverconnection Logbucheinträge erzeugt.&lt;/dd&gt;
&lt;dt&gt;smbstatus:&lt;/dt&gt;
&lt;dd&gt;Ein sehr einfaches Programm zur Anzeige des Status aller zum Server bestehenden Verbindungen.&lt;/dd&gt;
&lt;dt&gt;smbtar:&lt;/dt&gt;
&lt;dd&gt;Ein Shellscript, das &lt;code&gt;smbclient&lt;/code&gt; verwendet und das ein von einem PC exportiertes Verzeichnis mit &lt;code&gt;tar&lt;/code&gt; auf dem Bandlaufwerk des UNIX-Servers sichert.&lt;/dd&gt;
&lt;dt&gt;testparm:&lt;/dt&gt;
&lt;dd&gt;Syntaxchecker für die Konfigurationsdatei.&lt;/dd&gt;
&lt;dt&gt;testprns:&lt;/dt&gt;
&lt;dd&gt;Syntaxchecker für die Druckerkonfiguration.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1996/01/programme.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Samba besteht aus einer Reihe von Programmen, die zum Betrieb des Servers (Server-Tools) oder zu seinem Test (Client-Tools) dienen.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Ein &lt;code&gt;make install&lt;/code&gt; installiert diese Programme und die Manualpages dann im gewünschten Verzeichnis.
Damit der Server in Betrieb genommen werden kann, müssen &lt;code&gt;nmbd&lt;/code&gt; und &lt;code&gt;smbd&lt;/code&gt; entweder als permanent laufende Dämonen gestartet werden oder über passende Einträge in der &lt;code&gt;/etc/inetd.conf&lt;/code&gt; bei Bedarf hochgezogen werden.&lt;/p&gt;
&lt;p&gt;Für letzteres sind die Einträge&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;netbios-ns      137/tcp                         # NETBIOS Name Service
netbios-ns      137/udp
netbios-dgm     138/tcp                         # NETBIOS Datagram Service
netbios-dgm     138/udp
netbios-ssn     139/tcp                         # NETBIOS session service
netbios-ssn     139/udp
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;in der Datei &lt;code&gt;/etc/services&lt;/code&gt; notwendig. Dazu passen dann die Zeilen&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#
# SMB Samba File Server
#
netbios-ssn stream tcp  nowait  root    /usr/local/samba/bin/smbd smbd 
netbios-ns  dgram  udp  wait    root    /usr/local/samba/bin/nmbd nmbd -H /usr/local/samba/lib/lmhosts
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;in der &lt;code&gt;/etc/inetd.conf&lt;/code&gt;.
Der &lt;code&gt;inetd&lt;/code&gt; muß nach einer Änderung in seiner Konfigurationsdatei durch ein &lt;code&gt;SIGHUP&lt;/code&gt; geweckt werden, damit er die Datei neu einliest.&lt;/p&gt;
&lt;h2 id=&#34;tests-mit-einer-einfachen-konfiguration&#34;&gt;
    &lt;a href=&#34;#tests-mit-einer-einfachen-konfiguration&#34;&gt;
	Tests mit einer einfachen Konfiguration
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Durch die Verwendung einer &lt;code&gt;lmhosts&lt;/code&gt;-Datei kann der Samba-Server als Nameserver für ein Lan Manager Netzwerk dienen.
Die &lt;code&gt;lmhosts&lt;/code&gt;-Datei entspricht dabei in ihren ersten beiden Spalten einer normalen Hosts-Datei:
In der ersten Spalte wird eine IP-Nummer genannt, der in der zweiten Spalte ein Name zugeordnet wird.
Mit einer optionalen, dritten Spalte können für einzelne Namen bestimmte Flags gesetzt werden:
Der Buchstabe &lt;code&gt;G&lt;/code&gt; kennzeichnet einen Namen als den Namen der eigenen Arbeitsgruppe.
Die zugehörige Adresse ist die Broadcast-Adresse der betreffenden Arbeitsgruppe.
Das Flag &lt;code&gt;S&lt;/code&gt; kennzeichnet die Namen und Broadcastadressen weiterer Arbeitsgruppen, in denen die Dienste unseres Servers ebenfalls angepriesen (registriert) werden sollen.
Und das Flag &lt;code&gt;M&lt;/code&gt; schließlich kennzeichnet diesen Eintrag als den defaultmäßigen Netbios-Namen dieser Maschine.&lt;/p&gt;
&lt;p&gt;Der nächste Schritt ist die Erzeugung der zentralen Konfigurationsdatei.
Wenn Samba im Defaultverzeichnis &lt;code&gt;/usr/local/samba&lt;/code&gt; installiert worden ist, muß diese Datei in &lt;code&gt;/usr/local/samba/lib/smb.conf&lt;/code&gt; angelegt werden.
Ihr Aufbau gleicht syntaktisch dem einer WIN.INI-Datei von MS-Windows:
Sie besteht aus Abschnitten, die jeweils durch einen Namen in eckigen Klammern eingeleitet wird.
Jeder Abschnitt enthält dann eine Reihe von Zuweisungen der Form &lt;code&gt;Parameter = Wert&lt;/code&gt;.
Parameter dürfen genau wie Abschnittnamen Leerzeichen enthalten, die Samba ignoriert.
Ebenso spielt Gross- und Kleinschreibung keine Rolle.&lt;/p&gt;
&lt;p&gt;Jeder Abschnitt der &lt;code&gt;smb.conf&lt;/code&gt; definiert einen Service, der von Samba exportiert wird.
Ein Service kann dabei ein Drucker oder - häufiger - ein Verzeichnis sein.
Samba kennt drei Abschnitte, die besondere Bedeutung haben:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;[global]:&lt;/dt&gt;
&lt;dd&gt;In diesem Abschnitt werden besondere, globale Einstellungen für den Server getroffen.&lt;/dd&gt;
&lt;dt&gt;[printers]:&lt;/dt&gt;
&lt;dd&gt;In diesem Abschnitt kann man alle Drucker der &lt;code&gt;/etc/printcap&lt;/code&gt; exportieren.&lt;/dd&gt;
&lt;dt&gt;[homes]:&lt;/dt&gt;
&lt;dd&gt;In diesem Abschnitt kann man alle Homeverzeichnisse des Servers exportieren.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Samba bietet nun buchstäblich Dutzende von Parametern, mit denen man den Server seinen Bedürfnissen anpassen kann.
Zum Glück sind die Defaults jedoch so eingestellt, daß man nur wenige dieser Parameter wirklich anpassen muß.&lt;/p&gt;
&lt;p&gt;Zum Testen sollte man eine minimale &lt;code&gt;smb.conf anlegen.&lt;/code&gt;Sie könnte zum Beispiel so aussehen:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[global]
        guest account = smbguest

[tmp]
        comment = temporary files 
        path = /tmp
        read only = yes
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Der Account &lt;code&gt;smbguest&lt;/code&gt; ist dabei ein User mit minimalen Rechten.
Der Abschnitt &lt;code&gt;[tmp]&lt;/code&gt; exportiert das lokale &lt;code&gt;/tmp&lt;/code&gt;-Verzeichnis read-only an die Welt.&lt;/p&gt;
&lt;p&gt;Die Korrektheit dieser Konfigurationsdatei kann mit dem Kommando&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ SAM=/usr/local/samba
$ $SAM/bin/testparm $SAM/lib/smb.conf | more
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;schnell überprüft werden.
&lt;code&gt;testparm&lt;/code&gt; liest die Datei ein und zeigt an, ob die Datei syntaktisch korrekt ist.
Danach werden die Werte aller internen Konfigurationsvariablen ausgegeben.
Auf diese Weise kann man schnell sehen, mit welchen internen Parameterwerten Samba wirklich operiert.&lt;/p&gt;
&lt;p&gt;Mit dem &lt;code&gt;smbclient&lt;/code&gt; kann man nun ausprobieren, ob das gewünschte Verzeichnis wirklich exportiert wird:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$SAM/bin/smbclient -L localhost -U%
Server time is Thu Nov 23 11:17:01 1995
Timezone is UTC+1.0
Domain=[DAHEIM] OS=[Unix] Server=[Samba 1.9.15p3]

Server=[localhost] User=[smbguest] Workgroup=[DAHEIM] Domain=[DAHEIM]

        Sharename      Type      Comment
        ---------      ----      -------
        tmp            Disk      temporary files
        IPC$           IPC       IPC Service (Samba 1.9.15p3)


This machine has a browse list:

        Server               Comment
        ---------            -------
        WHITE                Samba 1.9.15p3
        MAHAKI               
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Die Meldung &amp;ldquo;bad password&amp;rdquo; an dieser Stelle würde anzeigen, daß der Gastaccount von Samba nicht richtig gesetzt ist oder nicht verwendet werden kann.
Auch &amp;ldquo;hosts allow&amp;rdquo; und &amp;ldquo;hosts deny&amp;rdquo;-Einträge, die unseren eigenen Rechner ausschließen, oder &amp;ldquo;valid users&amp;rdquo; und &amp;ldquo;invalid users&amp;rdquo;, die zu strikt gesetzt sind, können zu der Fehlermeldung führen.&lt;/p&gt;
&lt;p&gt;Die Meldung &amp;ldquo;connection refused&amp;rdquo; deutet dagegen darauf hin, daß auf den Samba-Sockets kein Dämon zuhört.
Ein häufiger Fehler ist es, den inetd nach Änderungen an der Konfigurationsdatei nicht mit &lt;code&gt;SIGHUP&lt;/code&gt; zu wecken.
&lt;code&gt;netstat -a&lt;/code&gt; zeigt an, ob jemand auf dem Port &lt;code&gt;netbios-ssn&lt;/code&gt; zuhört.&lt;/p&gt;
&lt;p&gt;Ähnlich kann man die Funktionsfähigkeit des &lt;code&gt;nmbd&lt;/code&gt; überprüfen:
Das Kommando&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ $SAM/bin/nmblookup -B localhost __SAMBA__
Sending queries to 127.0.0.1
193.102.57.4 __SAMBA__
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;sollte die IP-Adresse des eigenen Servers zurückliefern. Ebenso sollte ein&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ $SAM/bin/nmblookup -B mahaki &#39;*&#39;
Sending queries to 193.102.57.2
193.102.57.2 *
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;die Adresse des Clients zurückliefern.
Und schließlich sollten sich bei einem&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ $SAM/bin/nmblookup -d 2 &#39;*&#39;
Netmask for eth0 = 255.255.255.0
Derived broadcast address 193.102.57.255
Using broadcast 193.102.57.255
Sending queries to 193.102.57.255
Got a positive name query response from 193.102.57.2 (193.102.57.2)
Got a positive name query response from 193.102.57.4 (193.102.57.4)
193.102.57.4 *
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;alle Teilnehmer des lokalen Netzes melden, falls sie schnell genug sind.
Falls Server und Client nicht auf demselben Subnetz sind, ist es notwendig, die korrekte Broadcast-Adresse des entfernten Subnetzes mit der Option -B anzugeben.&lt;/p&gt;
&lt;p&gt;Wenn man so sichergestellt hat, daß sich alle Rechner untereinander kennen und einander erreichen können, kann man versuchen, erst einmal lokal auf die exportierten Ressourcen
zuzugreifen:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ $SAM/bin/smbclient &amp;quot;\\\\localhost\\tmp&amp;quot;
Server time is Thu Nov 23 11:28:06 1995
Timezone is UTC+1.0
Password: 
Domain=[DAHEIM] OS=[Unix] Server=[Samba 1.9.15p3]
smb: \&amp;gt; dir
  isdnctrl0                                226942  Thu Nov 23 10:14:14 1995
  crond_running                                 0  Thu Nov 23 11:28:01 1995
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Der Name der verwendeten Ressource wird DOS-Konform mit &lt;code&gt;\\rechner\ressource&lt;/code&gt; bezeichnet.
Die verwendete Shell macht es jedoch notwendig, Backslashes als &lt;code&gt;\\&lt;/code&gt; zu escapen.
Die Schreibweise des Kommandos erscheint so etwas merkwürdig.
Samba versucht sich unter dem normalen Usernamen anzumelden.
Das verlangte Paßwort ist also das normale Paßwort des Accounts.
Möchte man unter einem anderen Benutzernamen testen, ist die Option &lt;code&gt;-U username&lt;/code&gt; hinter dem Namen der Ressource anzugeben.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;smbclient&lt;/code&gt; arbeitet ähnlich wie &lt;code&gt;ftp&lt;/code&gt; und versteht Kommandos wie &amp;ldquo;help&amp;rdquo;, &amp;ldquo;get&amp;rdquo;, &amp;ldquo;put&amp;rdquo; und &amp;ldquo;quit&amp;rdquo;.
Wegen der Option &lt;code&gt;read only = yes&lt;/code&gt; in der &lt;code&gt;smb.conf&lt;/code&gt; schlägt ein &amp;ldquo;put&amp;rdquo; wie erwartet fehl:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;smb: \&amp;gt; put username.map
ERRDOS - ERRnoaccess (Access denied.) opening remote file \username.map
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Wenn dies alles funktioniert, kann man versuchen, vom PC aus auf das Verzeichnis zuzugreifen.
Aus einem DOS-Fenster sollte man die exportierten Ressourcen mit&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;E:\users\default&amp;gt;net view &amp;quot;\\white&amp;quot;
Freigegebene Ressourcen auf \\white

Samba 1.9.15p3

Name         Typ          Lokal    Beschreibung

-------------------------------------------------------------------------------
tmp          Platte                temporary files
Der Befehl wurde erfolgreich ausgeführt.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ansehen. Mit&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;E:\users\default&amp;gt;net use &amp;quot;\\white\tmp&amp;quot; /user:kris
Das Kennwort für \\white\tmp ist ungültig.

Geben Sie das Kennwort für \\white\tmp ein:
Der Befehl wurde erfolgreich ausgeführt.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;kann man sich dann beim Server anmelden.
Programme, die erweiterte Pfadnamen mit &lt;code&gt;\\rechnername&lt;/code&gt; verstehen, können jetzt schon auf das Laufwerk zugreifen.
Der Samba-Server sollte nun auch im Dateimanager unter &amp;ldquo;Datenträger&amp;rdquo;, &amp;ldquo;Netzwerklaufwerk verbinden&amp;rdquo; sichtbar sein.&lt;/p&gt;
&lt;p&gt;Die Bemerkung &amp;ldquo;Das Kennwort für &amp;hellip; ist ungültig&amp;rdquo; des Windows NT-Servers aus dem Beispiel tritt übrigens auf, weil der Samba Server ohne verschlüsselte Paßworte  übersetzt wurde.
Wir der Server mit der &lt;code&gt;libdes&lt;/code&gt; und der Option &lt;code&gt;encrypted passswords = yes&lt;/code&gt; in der &lt;code&gt;smb.conf&lt;/code&gt; installiert, erfolgt das Login ohne Rückfrage.&lt;/p&gt;
&lt;h2 id=&#34;geschwindigkeit&#34;&gt;
    &lt;a href=&#34;#geschwindigkeit&#34;&gt;
	Geschwindigkeit
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Samba verwendet ein verbindungsorientiertes und asynchrones Protokoll und unterliegt so nicht den Einschränkungen, die die Geschwindigkeit von NFS begrenzen.
Auf der anderen Seite ist der Samba-Server so natürlich nicht so datensicher wie ein NFS-Server.
In der Praxis sollte das wenig ausmachen, da die Clients PCs sind und so vermutlich häufiger abstürzen&amp;hellip;&lt;/p&gt;
&lt;p&gt;Geschwindigkeitsprobleme kann es beim Einloggen geben, wenn der Client ein Windows für Workgroups ist und Samba das Loginpaßwort raten muß (siehe Kasten &amp;ldquo;Eine Standardkonfiguration&amp;rdquo;).
Falls das richtige Paßwort mehrere Großbuchstaben enthält und die &lt;code&gt;crypt()&lt;/code&gt;-Routine des Servers hinreichend langsam ist, können so einige Sekunden vergehen.&lt;/p&gt;
&lt;p&gt;Der Text &lt;code&gt;SPEED.txt&lt;/code&gt; aus der Samba-Dokumentation enthält außerdem einige weitere Tips, mit der man die Geschwindigkeit des Servers unter Umständen weiter verbessern kann:
Niedrige Debug-Level, große Puffer und überlappende Zugriffe auf Platte und Netzwerk können die Serverperformance weiter steigern.&lt;/p&gt;
&lt;p&gt;Alles in allem erreicht Samba so eine Performance, die einem Windows NT Server oder einem Pathworks Server vergleichbar ist.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;samba-im-internet&#34;&gt;
    &lt;a href=&#34;#samba-im-internet&#34;&gt;
	Samba im Internet
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Die zur Zeit der Entstehung dieses Artikels aktuelle Version von
Samba ist 1.9.15, Patch 3.&lt;/p&gt;
&lt;p&gt;Das Homeverzeichnis von Samba ist &lt;a href=&#34;ftp://nimbus.anu.edu.au/pub/tridge/samba&#34;&gt;ftp://nimbus.anu.edu.au/pub/tridge/samba&lt;/a&gt;

.
Da jedoch die Internet-Anbindung von Australien aus der Sicht von Deutschland nicht überragend ist, ist es vorteilhaft, sich Samba von einem der offiziellen Mirrors zu kopieren.
Die Dokumentation nennt dazu unter anderem
&lt;a href=&#34;ftp://sunsite.unc.edu/pub/Linux/system/Network/Samba&#34;&gt;ftp://sunsite.unc.edu/pub/Linux/system/Network/Samba&lt;/a&gt;


und
&lt;a href=&#34;ftp://ftp.uni-trier.de/pub/unix/network/samba&#34;&gt;ftp://ftp.uni-trier.de/pub/unix/network/samba&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;Das Paket liegt außerdem auf vielen deutschen Sunsite-Mirrors und ist praktisch auf jeder besseren Linux CD-ROM auch im Quelltext archviert.
Diese Versionen hinken jedoch, wie üblich, um einige Minor-Releases hinterher.&lt;/p&gt;
&lt;p&gt;Nicht alle Mirrors archivieren
&lt;a href=&#34;ftp://nimbus.anu.edu.au/pub/tridge/libdes/libdes.tar.92-10-13.gz&#34;&gt;ftp://nimbus.anu.edu.au/pub/tridge/libdes/libdes.tar.92-10-13.gz&lt;/a&gt;

,
weil dies administrative Probleme beim FTP-Verkehr von und nach USA machen würde.
Diese Bibliothek ist notwendig, wenn man mit verschlüsselten Paßworten auf dem Netz arbeiten möchte.
Clients und Server unter Windows NT verhalten sich ohne verschlüsselte Paßworte jedoch eigenartig.&lt;/p&gt;
&lt;p&gt;Samba hat eine eigene Newsgroup im USENET, &lt;code&gt;comp.protocols.smb&lt;/code&gt;,
die glücklicherweise nicht sehr überlaufen ist.
Außerdem findet man in den einschlägigen Linux-Newsgroups ebenfalls massenweise Fragen und Antworten rund um Samba.&lt;/p&gt;
&lt;p&gt;Wer an aktuellen Informationen über Samba interessiert ist, kann sich auf der Mailingliste &lt;code&gt;samba-announce&lt;/code&gt; eintragen lassen.
Dazu ist es notwendig, eine Mail an &lt;code&gt;listproc@listproc.anu.edu.au&lt;/code&gt; zu senden, die im Text (nicht im Subject!) das Kommando &lt;code&gt;subscribe samba-announce Vorname Nachname&lt;/code&gt; enthält.&lt;/p&gt;
&lt;p&gt;Es existiert eine weitere Mailingliste, &lt;code&gt;samba&lt;/code&gt;, die der Weiterentwicklung von Samba dient.
Um sich dort einzuschreiben, ist &lt;code&gt;subscribe samba Vorname Nachname&lt;/code&gt; an die oben angegebene Adresse zu senden.&lt;/p&gt;
&lt;p&gt;Die Samba Home-Page ist &lt;a href=&#34;http://lake.canberra.edu.au/pub/samba/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lake.canberra.edu.au/pub/samba/&lt;/a&gt;

&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;eine-standardkonfiguration&#34;&gt;
    &lt;a href=&#34;#eine-standardkonfiguration&#34;&gt;
	Eine Standardkonfiguration
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Die folgende Konfigurationsdatei dürfte die meisten
einfachen Anwendungsfälle abdecken:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[global]
  ; Gastaccount zuweisen
  guest account = smbguest
  ; Nicht alle User auf dem UNIX-Rechner heißen auf dem Windows NT gleich
  ; Format:
  ; unixuser = dosalias dosalias2 dosalias3...
  ; root = administrator admin
  username map = /usr/local/samba/lib/username.map
  ; Windows NT erfordert libdes und encrypted passwords, siehe Dokumentation
  encrypt passwords = yes
  ; Samba soll Domain Master und Browse Master sein.
   os level = 33
   domain master = yes
  ; nur Verbindungen von vertrauenswürdigen Hosts zulassen
  allow hosts = black, white, mahaki
  ; DOS &amp;quot;share&amp;quot; locking simulieren
  locking = yes
  share modes = yes
  ; Windows NT Protokoll verwenden
  ; Optionen sind CORE, COREPLUS, LANMAN1, LANMAN2 und NT1
  protocol = NT1
  
  ; Dies ist die Workgroup, der wir angehören
  workgroup = DAHEIM
  
[tmp]
  comment = Zwischenablage
  path = /tmp
  read only = no

[faq]
  comment = Haeufig gestellte Fragen (aus USENET)
  path = /scratch/faq
  read only = yes

[homes]
  comment = Homeverzeichnisse
  browseable = no
  read only = no
  create mode = 0750

[printers]
  comment = Alle Drucker aus /etc/printcap
  printing = bsd
  browseable = no
  load printers = yes
  read only = yes
  printable = yes
  path = /tmp
  public = yes
  create mode = 0700
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Diese &lt;code&gt;smb.conf``  versucht einen minimalen Sicherheitslevel herzustellen, indem nur Verbindungen von Hosts von vertrauenswürdigen zugelassen werden. Sie exportiert zwei gewöhnliche Verzeichnisse: &lt;/code&gt;/tmp&lt;code&gt;read-write und&lt;/code&gt;/scratch/faq` read-only.&lt;/p&gt;
&lt;p&gt;Außerdem werden die Drucker der &lt;code&gt;/etc/printcap&lt;/code&gt; durch den besonderen Abschnitt &lt;code&gt;[printers]&lt;/code&gt; und die Home-Verzeichnisse aller Benutzer durch &lt;code&gt;[homes]&lt;/code&gt; exportiert.
Beide Abschnitte sind nicht als Browseable gekennzeichnet.
Dadurch erscheint nur das Home-Verzeichnis des auf dem Windows-Rechner angemeldeten Benutzers in der Browse-List des Dateimanagers.
Ebenso wird nicht &lt;code&gt;[printers]&lt;/code&gt; selbst im Druckmanager angezeigt, sondern die Drucker der &lt;code&gt;/etc/printcap&lt;/code&gt; werden durch das &lt;code&gt;load printers&lt;/code&gt; einzeln angezeigt.&lt;/p&gt;
&lt;p&gt;Dadurch, daß das NT1-Protkoll verwendet wird, ist es möglich, auch lange Dateinamen mit Groß-/Kleinschreibung zu verwenden.
Auch das LANMAN2-Protokoll kann dies.
Windows für Workgroups wandelt alle Paßworte in reine Großschrift um, wenn ein höheres Protokoll als COREPLUS verwendet wird.
In diesem Fall versucht Samba, das Paßwort zu raten, indem das übermittelte Paßwort in Groß- und Kleinschrift ausprobiert wird.
Mit der Option &lt;code&gt;password level = zahl&lt;/code&gt; kann man Samba dazu bewegen, auch Kombinationen von Groß- und Kleinbuchstaben zu testen.
Die Zahl bestimmt dabei die maximale Anzahl von Großbuchstaben im Paßwort.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Robots Dictionary</title>
      <link>https://blog.koehntopp.info/1995/03/01/datenuebertragung-glossar.html</link>
      <pubDate>Wed, 01 Mar 1995 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/1995/03/01/datenuebertragung-glossar.html</guid>
      <description>&lt;h4 id=&#34;dieser-text-ist-eine-verkürzte-form-des-textes-a-robots-dictionary-von-megrmblsaarde-martin-emmerich-er-erschien-zusammen-mit-anderen-artikeln-im-sonderheft-dfü-der-dos-international-dmv-verlag&#34;&gt;
    &lt;a href=&#34;#dieser-text-ist-eine-verk%c3%bcrzte-form-des-textes-a-robots-dictionary-von-megrmblsaarde-martin-emmerich-er-erschien-zusammen-mit-anderen-artikeln-im-sonderheft-df%c3%bc-der-dos-international-dmv-verlag&#34;&gt;
	Dieser Text ist eine verkürzte Form des Textes »A Robots Dictionary« von &lt;a href=&#34;mailto:me@grmbl.saar.de&#34;&gt;me@grmbl.saar.de&lt;/a&gt;

 (Martin Emmerich). Er erschien zusammen mit anderen Artikeln im Sonderheft DFÜ der DOS International (DMV Verlag).
    &lt;/a&gt;
&lt;/h4&gt;
&lt;h1 id=&#34;a&#34;&gt;
    &lt;a href=&#34;#a&#34;&gt;
	A
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;Akustikkoppler:&lt;/dt&gt;
&lt;dd&gt;eine besondere Bauform des Modems, die über Muffen an
den Hörer und Mikrofon des Telefonapparates gekoppelt wird.&lt;/dd&gt;
&lt;dt&gt;ANSI:&lt;/dt&gt;
&lt;dd&gt;American National Standards Institute, Amerikanisches
Normungsinstitut, ähnlich dem DIN-Institut.&lt;/dd&gt;
&lt;dt&gt;Answer-Modus:&lt;/dt&gt;
&lt;dd&gt;Modem-Betriebsart. Gegenstück zum Originate-Modus.&lt;/dd&gt;
&lt;dt&gt;ASCII:&lt;/dt&gt;
&lt;dd&gt;American Standard Code for Information Interchange, amerikanischer
Zeichencode zum Informationsaustausch. Der meistverwendete Code in der
Datenkommunikation.&lt;/dd&gt;
&lt;dt&gt;asynchrone Verbindung:&lt;/dt&gt;
&lt;dd&gt;Verbindung ohne Übertragung eines Datentaktes.
Anfang und Ende eines Datenworts muessen durch Start- und Stopbits
markiert werden.&lt;/dd&gt;
&lt;dt&gt;AT-Befehlssatz:&lt;/dt&gt;
&lt;dd&gt;Kommandosprache zur Modemansteuerung,&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;b&#34;&gt;
    &lt;a href=&#34;#b&#34;&gt;
	B
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;Bandbreite:&lt;/dt&gt;
&lt;dd&gt;hier Frequenzbandbreite des Telefons: Die Größe des
Frequenzbereiches, der über Telefon übertragen werden kann. Bei einem
Frequenzbereich von typisch 300 bis 3400Hz ist die Bandbreite 3100Hz. Da
die Grenzbereiche teilweise abgeschwächt werden (Dämpfung), sind etwa
3000Hz nutzbar.&lt;/dd&gt;
&lt;dt&gt;Baudrate:&lt;/dt&gt;
&lt;dd&gt;gibt die Anzahl der Zustandswechsel des übertragenen Signals pro
Sekunde an. Die Baudrate (auch Schrittgeschwindigkeit) wird in der
Einheit Baud gemessen. Multipliziert man die Anzahl der Bits pro Zustand
mit der Baudrate, so erhält man die Bitrate.
Nur wenn die Anzahl der Zustaende genau zwei ist (d.h. mit einem
Zustand genau ein Bit codiert wird) ist die Baudrate gleich der Bitrate.&lt;/dd&gt;
&lt;dt&gt;Bimodem:&lt;/dt&gt;
&lt;dd&gt;bidirektionales Übertragungsprotokoll. Arbeitet im Gegensatz zu
den üblichen Protokollen wie Kermit, Xmodem, Zmodem in beide
Richtungen gleichzeitig.
Nur auf IBM-Kompatiblen verfuegbar. Maximale Blockgroesse 4KB. Sehr
hoher Datendurchsatz (fast 100%).&lt;/dd&gt;
&lt;dt&gt;Bitrate:&lt;/dt&gt;
&lt;dd&gt;Anzahl der uebertragenen Bits pro Sekunde (Übertragungsgeschwindigkeit).
Gemessen wird in bit/s oder bps. Die Bitrate ist nur in
Sonderfaellen mit der Baudrate identisch!&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;c&#34;&gt;
    &lt;a href=&#34;#c&#34;&gt;
	C
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;CCITT:&lt;/dt&gt;
&lt;dd&gt;Comite Consultatif International Telephonique et Telegraphique, ein
Internationales Gremium für Normen zu Telefon und Telegraphie, an dem
Vertreter von Post, Industrie und Wissenschaft aus 159 Ländern
teilnehmen. Das CCITT ist ein Organ der International Telecommunications
Union (ITU) der Vereinten Nationen.
Normen zur Datenübertragung sind beispielsweise die über
Telefon (V-Normen), ueber Datennetze (X-Normen) und über ISDN
(I-Normen).&lt;/dd&gt;
&lt;dt&gt;CRC:&lt;/dt&gt;
&lt;dd&gt;Cyclic Redundancy Check, Prüfsumme, in Übertragungsprotokollen
verwendet. Üblich sind 16 oder 32 Bit lange Varianten, kurz: CRC-16
und CRC-32. Eine CRC stellt den Rest aus einer Polynomdivision dar.
Implementationen sind allgemein als Quelltext erhältlich.&lt;/dd&gt;
&lt;dt&gt;CTS:&lt;/dt&gt;
&lt;dd&gt;Clear To Send, Sendebereitschaft, Signal der V.24-Schnittstelle.
Auch RTR, Ready To Receive genannt.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;d&#34;&gt;
    &lt;a href=&#34;#d&#34;&gt;
	D
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;DCD:&lt;/dt&gt;
&lt;dd&gt;Data Carrier Detect, Trägersignalerkennung, Signal der
V.24-Schnittstelle.&lt;/dd&gt;
&lt;dt&gt;DCE:&lt;/dt&gt;
&lt;dd&gt;Data Communications Equipment, eine von zwei moeglichen
Konfigurationen einer V.24-Schnittstelle. Eine DCE kann immer nur
direkt mit einer DTE verbunden werden. Für eine Vermindung DCE-DCE
oder DTE-DTE muss ein Kabeladapter oder Spezialkabel (Nullmodem)
verwendet werden.&lt;/dd&gt;
&lt;dt&gt;DEE:&lt;/dt&gt;
&lt;dd&gt;Datenendeinrichtung, Deutsch fuer DTE.&lt;/dd&gt;
&lt;dt&gt;DFÜ:&lt;/dt&gt;
&lt;dd&gt;Datenfernübertragung.&lt;/dd&gt;
&lt;dt&gt;DIN:&lt;/dt&gt;
&lt;dd&gt;Deutsches Institut fuer Normung e.V. seit 1975, davor Deutsche
Industrie-Norm.
Der Verein ist aus dem 1917 gegruendeten &amp;ldquo;Normalienausschuss für den
allg. Maschinenbau&amp;rdquo; hervorgegangen und hat den Sitz in Berlin.&lt;/dd&gt;
&lt;dt&gt;Download:&lt;/dt&gt;
&lt;dd&gt;Das &amp;ldquo;Herunterladen&amp;rdquo; einer Datei vom fernen Rechner auf den
eigenen mit Hilfe eines Übertragungsprotokolles.&lt;/dd&gt;
&lt;dt&gt;DSR:&lt;/dt&gt;
&lt;dd&gt;Data Set Ready, Betriebsbereitschaft, Signal der V.24-Schnittstelle.&lt;/dd&gt;
&lt;dt&gt;DTE:&lt;/dt&gt;
&lt;dd&gt;Data Terminal Equipment, eine von zwei Konfigurationen einer V.24-
Schnittstelle. Das Gegenstück zur DCE.&lt;/dd&gt;
&lt;dt&gt;DTR:&lt;/dt&gt;
&lt;dd&gt;Data Terminal Ready, Endgerät betriebsbereit, Signal der
V.24-Schnittstelle.&lt;/dd&gt;
&lt;dt&gt;DÜE:&lt;/dt&gt;
&lt;dd&gt;Datenübertragungseinrichtung, Deutsch fuer DCE.&lt;/dd&gt;
&lt;dt&gt;Echo-Cancelling:&lt;/dt&gt;
&lt;dd&gt;beide Modems senden gleichzeitig auf derselben Frequenz.
Da aber jedes Modem weiss, was es gerade gesendet hat, kann es aus
dem Frequenzgemisch seine Signale unterdrücken und so die Daten der
Gegenstelle herausfiltern. Wird z.B. bei V.32 verwendet.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;e&#34;&gt;
    &lt;a href=&#34;#e&#34;&gt;
	E
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;EIA:&lt;/dt&gt;
&lt;dd&gt;Electronic Industries Association. Amerikanische Vereinigung der
Elektronikindustrie, die u.A. auch Standards fuer Datenkommunikation
herausgibt (z.B. RS-232-C).&lt;/dd&gt;
&lt;dt&gt;Escapen:&lt;/dt&gt;
&lt;dd&gt;Codieren von unerlaubten Zeichen mittels eines reservierten
Steuerzeichens (Escape-Zeichen). Solche Verfahren werden z.B. von
Übertragunsprotokollen zur Übertragung von Zeichen verwendet,
die in der darunterliegenden Übertragungsebene nicht zulässig sind.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;f&#34;&gt;
    &lt;a href=&#34;#f&#34;&gt;
	F
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;Fallback:&lt;/dt&gt;
&lt;dd&gt;Zurückschalten auf langsamere Geschwindigkeit bei schlechter
Leitungsqualität.&lt;/dd&gt;
&lt;dt&gt;FSK:&lt;/dt&gt;
&lt;dd&gt;Frequency Shift Keying = Frequenzumtastung (Frequenzmodulation).&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;h&#34;&gt;
    &lt;a href=&#34;#h&#34;&gt;
	H
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;halbduplex:&lt;/dt&gt;
&lt;dd&gt;Datenübertragung in nur eine Richtung mit Umschaltung der
Übertragungsrichtung.&lt;/dd&gt;
&lt;dt&gt;Handshake:&lt;/dt&gt;
&lt;dd&gt;Synchronisationsverfahren bei der Datenübertragung. Der
Sender signalisiert, wenn er neue Daten senden möchte oder kann und der
Empfänger, wenn er neue verarbeiten kann bzw. möchte. Erst wenn beide
sich auf eine Übertragung geeinigt haben, kann diese beginnen.&lt;/dd&gt;
&lt;dt&gt;Hardware-Handshake:&lt;/dt&gt;
&lt;dd&gt;Handshake ueber Signalleitungen. Üblicherweise
wird bei V.24 mit CTS/RTS signalisiert.&lt;/dd&gt;
&lt;dt&gt;Hayes-Befehlssatz:&lt;/dt&gt;
&lt;dd&gt;Kommandosprache zur Modemansteuerung. Ursprünglich
Entwicklung der Firma Hayes. Inzwischen der De-Facto-Standard, von dem
aber nahezu jeder Modemhersteller mehr oder weniger abweicht.
Alle Befehle beginnen mit AT, daher heisst er auch AT-Befehlssatz.
Ist so weit verbreitet, dass sich der genormte V.25-Standard kaum
durchsetzt.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;i&#34;&gt;
    &lt;a href=&#34;#i&#34;&gt;
	I
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;ISDN:&lt;/dt&gt;
&lt;dd&gt;Integrated Services Digital Network, &amp;ldquo;Dienstintegrierendes
Digitales Netz&amp;rdquo;, ein öffentliches Digitalnetz sowohl zur Daten- als
auch zur Sprach- und Bildübertragung.&lt;/dd&gt;
&lt;dt&gt;ISO:&lt;/dt&gt;
&lt;dd&gt;International Standardisation Organisation, Internationale
Normungsorganisation. Internationales Gegenstueck zur staatlichen
Normungsinstituten wie ANSI oder DIN.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;k&#34;&gt;
    &lt;a href=&#34;#k&#34;&gt;
	K
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;Kermit:&lt;/dt&gt;
&lt;dd&gt;eines der ältesten Üebertragungsprotokolle. Tatsächlich nach
Kermit dem Frosch benannt. Da die Blockgrösse in der ursprünglichen
Form maximal 94 Bytes beträgt, ist die Geschwindigkeit relativ gering
(hoher Aufwand fuer das Protokoll).&lt;/dd&gt;
&lt;dt&gt;Kompression:&lt;/dt&gt;
&lt;dd&gt;verringert das Datenvolumen bei gleichem Informationsgehalt,
indem Redundanzen eliminiert werden.
Bei den meisten Verfahren (z.B. V.42bis, MNP 5) werden die
häufigsten Zeichen und Zeichenfolgen mit kurzen Bitfolgen codiert,
während die selteneren länger codiert werden.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;l&#34;&gt;
    &lt;a href=&#34;#l&#34;&gt;
	L
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;Leitungsvermittlung:&lt;/dt&gt;
&lt;dd&gt;Eine Leitung wird zwischen den beiden
Kommunikationspartnern für die Dauer der Verbindung fest geschaltet.
Das Gegenstück zu Paketvermittlung.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;m&#34;&gt;
    &lt;a href=&#34;#m&#34;&gt;
	M
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;MNP:&lt;/dt&gt;
&lt;dd&gt;Microcom Networking Protocol, Übertragungsverfahren der Firma
Microcom.  Es gibt zehn Klassen, die zum Teil aufwärtskompatibel
sind. Die Klassen 1-4 sind reine Datenübertragungsprotokolle. Diese
wurden in die V.42-Norm aufgenommen. Ab MNP Klasse 5 kommt dann
Kompression ins Spiel.&lt;/dd&gt;
&lt;dt&gt;Modem:&lt;/dt&gt;
&lt;dd&gt;Abkürzung fuer &amp;ldquo;MOdulator und DEModulator&amp;rdquo;, d.h. ein Gerät, das
den Bitstrom des Computers in analoge Signale umwandelt, die dann
auch über das Telefonnetz übertragen werden koennen (Modulation).
Das Partner-Modem macht die Umwandlung dann wieder rückgaengig
(Demodulation).
Deshalb ist auch der Akustikkoppler ein Modem, auch wenn er i.d.R.
nicht so genannt wird.&lt;/dd&gt;
&lt;dt&gt;Modulation:&lt;/dt&gt;
&lt;dd&gt;Verfahren, um einer Trägerfrequenz ein Nutzsignal
&amp;ldquo;aufzubürden&amp;rdquo;, so dass das Nutzsignal gut übertragen werden kann.
Üblich sind z.B.
&lt;p&gt;Amplitudenmodulation (AM):&lt;/p&gt;
  &lt;DD&gt;das Nutzsignal wird in die Amplitude (=Lautstärke) 
      codiert (z.B. laut=1, leise=0).
  Frequenzmodulation (FM, FSK):
  &lt;DD&gt;die Abweichung von der Trägerfrequenz ergibt das Nutzsignal. 
      Da bei der Datenübertragung das Nutzsignal nur
    	    zwei Zustände hat, ergeben sich zwei Frequenzen, die symmetrisch
      oberhalb und unterhalb der Trägerfrequenz liegen. Letztere heißt
      dann auch Mittenfrequenz.
  Phasenmodulation (PM, PSK):
  &lt;DD&gt;das (diskrete) Nutzsignal wird durch einen Sprung in der Phase 
      des (im Gegensatz zur FSK festen) Trägers codiert, d.h. der 
      normalerweise sinusförmige Signalverlauf wird
          unterbrochen und ein Stück weiter fortgesetzt. Oft werden mehrere
          Bits gleichzeitig in einen Zustand codiert.
  	Quadratur-Amplitudenmodulation (QAM):
  &lt;DD&gt;eine Kombination aus AM und PM,
    	    wobei ein Teil der Zustände in AM und der Rest in PM codiert 
      werden.
&lt;/dd&gt;
&lt;dt&gt;Multiplexer:&lt;/dt&gt;
&lt;dd&gt;Einrichtung, die einen schnelleren Datenkanal in mehrere
langsamere Kanäle aufteilt.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;o&#34;&gt;
    &lt;a href=&#34;#o&#34;&gt;
	O
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;Originate-Modus:&lt;/dt&gt;
&lt;dd&gt;eine von zwei Betriebsarten bei manchen Vollduplex-Modems.&lt;/dd&gt;
&lt;dt&gt;OSI:&lt;/dt&gt;
&lt;dd&gt;Open Systems Interconnection, Sammlung von Standards der ISO zur
Kommunikation zwischen Computersystemen.&lt;/dd&gt;
&lt;dt&gt;OSI-ISO-Modell:&lt;/dt&gt;
&lt;dd&gt;Modell zur Datenübertragung zwischen Computersystemen.
Es beschreibt sieben aufeinander aufbauende Schichten mit definierten
Aufgaben und Schnittstellen.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;p&#34;&gt;
    &lt;a href=&#34;#p&#34;&gt;
	P
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;Paketvermittlung:&lt;/dt&gt;
&lt;dd&gt;Eine Technik zum Weiterleiten von Daten in einem Netz.
Hierbei werden die Daten in Blöcken (&amp;ldquo;Paketen&amp;rdquo;) einer bestimmten Länge
übertragen. Spezielle Steuerpakete dienen dem Aufbau der Verbindung.
Im Gegensatz zur Leitungsvermittlung wird zwischen den Partnern keine
feste Leitung geschaltet, vielmehr werden die Daten je nach Auslastung
des Netzes ueber verschiedene Wege übertragen. Dabei können durchaus
Pakete des gleichen Datenstromes verschiedene Wege nehmen.&lt;/dd&gt;
&lt;dt&gt;Parität:&lt;/dt&gt;
&lt;dd&gt;Bit bei asynchroner Datenübertragung, das der Fehlererkennung
dient. Bestandteil des Übertragungsformats.&lt;/dd&gt;
&lt;dt&gt;Protokoll:&lt;/dt&gt;
&lt;dd&gt;Ein Satz von Regeln und Vereinbarungen, der den
Informationsfluss in einem Kommunikationssystem steuert. Kann sich
sowohl auf Hardware, wie auf Software beziehen. Wird in der
Datenübertragung haeufig als Kurzform fuer Übertragungsprotokoll
verwendet.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;q&#34;&gt;
    &lt;a href=&#34;#q&#34;&gt;
	Q
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;QAM:&lt;/dt&gt;
&lt;dd&gt;Quadrature Amplitude Modulation.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;r&#34;&gt;
    &lt;a href=&#34;#r&#34;&gt;
	R
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;RD:&lt;/dt&gt;
&lt;dd&gt;Receive Data, Empfangsdaten, Signal der V.24-Schnittstelle.&lt;/dd&gt;
&lt;dt&gt;RI:&lt;/dt&gt;
&lt;dd&gt;Ring Indicator, ankommender Ruf, Signal der V.24-Schnittstelle.&lt;/dd&gt;
&lt;dt&gt;Routing:&lt;/dt&gt;
&lt;dd&gt;Transportieren von Daten innerhalb eines Netzes anhand eines
Pfades, der im Header der Daten enthalten ist (passives Routing)
oder durch Bestimmen des kürzesten, schnellsten, billigsten oder
nächstbesten Routweges (aktives Routing) aus einer Karte des Netzes.&lt;/dd&gt;
&lt;dt&gt;RS-232-C:&lt;/dt&gt;
&lt;dd&gt;amerikanische EIA-Norm für serielle Schnittstellen. Die
internationale Norm V.24 legt die entsprechenden funktionalen
Eigenschaften und V.28 die entsprechenden elektrischen Eigenschaften
fest.&lt;/dd&gt;
&lt;dt&gt;RTS:&lt;/dt&gt;
&lt;dd&gt;Request To Send, Sendeteil Einschalten, Signal der
V.24-Schnittstelle.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;s&#34;&gt;
    &lt;a href=&#34;#s&#34;&gt;
	S
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;Sliding-Window-Protocol:&lt;/dt&gt;
&lt;dd&gt;Jedes Übertragungsprotokoll, bei dem weitere
Datenblöcke schon übertragen werden können, während für den
aktuellen Datenblock das ACK noch aussteht. Wesentlich schneller, als
wenn das Protokoll jedesmal das Senden unterbricht, um auf die
Bestätigung des Blockes zu warten. Die Anzahl der ACKs, die noch
ausstehen duerfen, bezeichnen die Window-Size des Protokolls.&lt;/dd&gt;
&lt;dt&gt;Software-Handshake:&lt;/dt&gt;
&lt;dd&gt;Handshake durch festgelegte Steuerzeichen. Fuer
Binaeruebertragungen ohne Übertragungsprotokoll nicht geeignet, da
die Daten auch die reservierten Handshake-Zeichen enthalten koennen.
Die ueblichsten Zeichen sind XON/XOFF, manchmal wird aber auch
ETX/ACK benutzt.&lt;/dd&gt;
&lt;dt&gt;Split-Speed:&lt;/dt&gt;
&lt;dd&gt;asymmetrische vollduplex-Datenübertragung mit zwei
verschiedenen Geschwindigkeiten (z.B. V.23).&lt;/dd&gt;
&lt;dt&gt;Startbit:&lt;/dt&gt;
&lt;dd&gt;Bit bei asynchroner Uebertragung, das den Anfang eines Datenworts
anzeigt. Immer Null. s. Übertragungsformat.&lt;/dd&gt;
&lt;dt&gt;Stopbit:&lt;/dt&gt;
&lt;dd&gt;ein oder zwei Bits bei asynchroner Übertragung,
die das Ende eines Datenworts anzeigen.
Immer Eins. siehe Übertragungsformat.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;t&#34;&gt;
    &lt;a href=&#34;#t&#34;&gt;
	T
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;TAE:&lt;/dt&gt;
&lt;dd&gt;TelefonAnschlussEinheit. Steckersystem der Deutschen Telekom. In
Deutschland wird nur die sechspolige Version TAE-6 und in
ISDN-Anlagen die achtpolige TAE-8 verwendet.&lt;/dd&gt;
&lt;dt&gt;TD:&lt;/dt&gt;
&lt;dd&gt;Transmit Data, Sendedaten, Signal der V.24-Schnittstelle.&lt;/dd&gt;
&lt;dt&gt;Trellis-Modulation:&lt;/dt&gt;
&lt;dd&gt;spezielles Modulationsverfahren mit eingebauter
Fehlerkorrektur, wird z.B. bei V.32 verwendet. Im Gegensatz zur
Quadratur-Amplitudenmodulation mit ihren Quadbits werden Quintbits
uebertragen. Das zusätzliche Bit dient der Fehlerkontrolle und teilweise
auch deren Beseitigung.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;u&#34;&gt;
    &lt;a href=&#34;#u&#34;&gt;
	U
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;Übertragungsformate:&lt;/dt&gt;
&lt;dd&gt;Bitkombination bei asynchroner Datenübertragung.
Durch zusaetzliche Bits wird Anfang (Startbit) und Ende (Stopbit)
eines Datenworts markiert. Weitere Bits (Paritätsbits) können der
Fehlererkennung dienen.
Die ueblichsten Formate sind &amp;ldquo;8n1&amp;rdquo; ( 8 Datenbits, no=keine Parität,
1 Stopbit) und &amp;ldquo;7e1&amp;rdquo; ( 7 Datenbits, even=gerade Parität, 1 Stopbit).&lt;/dd&gt;
&lt;dt&gt;Übertragungsprotokoll:&lt;/dt&gt;
&lt;dd&gt;Verfahren zur Übermittlung von Daten; diese
werden meist in Blöcke zerlegt und um Prüfsummen (CRC o.ä.)
ergänzt. Fehlerhafte Blöcke werden automatisch neu übertragen, ohne
daß der Benutzer (oberhalb der Protokollebene) etwas davon merkt. Bei
hoher Fehlerhäufigkeit wird meistens die Blockgrösse verkleinert.&lt;/dd&gt;
&lt;dt&gt;Upload:&lt;/dt&gt;
&lt;dd&gt;Das &amp;ldquo;Hinaufladen&amp;rdquo; einer Datei vom eigenen Rechner auf den fernen
Rechner mit einem Übertragungsprotokoll. Die Umkehrung dieses
Vorganges heisst Download.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;v&#34;&gt;
    &lt;a href=&#34;#v&#34;&gt;
	V
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;vollduplex:&lt;/dt&gt;
&lt;dd&gt;Datenübertragung in beide Richtungen gleichzeitig.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;w&#34;&gt;
    &lt;a href=&#34;#w&#34;&gt;
	W
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;Ward-Christiansen-Protokoll:&lt;/dt&gt;
&lt;dd&gt;s. Xmodem.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;x&#34;&gt;
    &lt;a href=&#34;#x&#34;&gt;
	X
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;X.25:&lt;/dt&gt;
&lt;dd&gt;Schnittstellennorm des CCITT zur paketorientierten Datenübermittlung.
Das öffentliche deutsche X.25-Netz ist Datex-P.&lt;/dd&gt;
&lt;dt&gt;Xmodem:&lt;/dt&gt;
&lt;dd&gt;Übertragungsprotokoll. Nach seinem Erfinder auch Ward-
Christensen-Protokoll genannt. Neben Kermit eines der ältesten
Datenübertragungsprotokolle.&lt;/dd&gt;
&lt;dt&gt;XON:&lt;/dt&gt;
&lt;dd&gt;Steuerzeichen (Ctrl-Q) zum Signalisieren der Empfangsbereitschaft
(Softwarehandshake), wird von XOFF aufgehoben.&lt;/dd&gt;
&lt;dt&gt;XOFF:&lt;/dt&gt;
&lt;dd&gt;Steuerzeichen (Ctrl-S) zum Aufheben der Empfangsbereitschaft,
Gegenstück zu XON.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;y&#34;&gt;
    &lt;a href=&#34;#y&#34;&gt;
	Y
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;Ymodem:&lt;/dt&gt;
&lt;dd&gt;Übertragungsprotokoll, faßt die diversen Xmodem-Erweiterungen
zusammen und ergänzt sie um eine Übertragung von Dateinamen und
Dateigröße und um Batch-Übertragungen.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h1 id=&#34;z&#34;&gt;
    &lt;a href=&#34;#z&#34;&gt;
	Z
    &lt;/a&gt;
&lt;/h1&gt;
&lt;dl&gt;
&lt;dt&gt;Zmodem:&lt;/dt&gt;
&lt;dd&gt;Übertragungsprotokoll, völlig neues Protokoll, versteht sich
aber als Nachfolger von Ymodem. Auf positive Rückmeldungen wird
verzichtet, sofern die Leitungsqualität das zuläßt. Die Blockgröße
wird während der Übertragung der Leitungsgüte angepaßt. Die maximale
Blockgröße ist auf 1K (einige Versionen: 8 KB) erhöht.&lt;/dd&gt;
&lt;/dl&gt;
&lt;br&gt;
</description>
    </item>
    
    <item>
      <title>Grundlagen der Datenübertragung</title>
      <link>https://blog.koehntopp.info/1995/02/01/datenuebertragung.html</link>
      <pubDate>Wed, 01 Feb 1995 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/1995/02/01/datenuebertragung.html</guid>
      <description>&lt;p&gt;&lt;strong&gt;von: Kristian Köhntopp, aus: DOS Sonderheft DFÜ, DMV Verlag&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;grundlagen-der-datenübertragung&#34;&gt;
    &lt;a href=&#34;#grundlagen-der-daten%c3%bcbertragung&#34;&gt;
	Grundlagen der Datenübertragung
    &lt;/a&gt;
&lt;/h1&gt;
&lt;h4 id=&#34;der-einsteiger-in-das-gebiet-der-datennah--und-fernübertragung-wird-zunächst-einmal-mit-einer-verwirrenden-vielfalt-neuer-konzepte-und-begriffe-konfrontiert-wir-wollen-hier-versuchen-einen-allgemeinen-überblick-über-das-gebiet-der-datenübertragung-zu-geben-und-die-wichtigsten-ideen-und-ausdrücke-darzustellen&#34;&gt;
    &lt;a href=&#34;#der-einsteiger-in-das-gebiet-der-datennah--und-fern%c3%bcbertragung-wird-zun%c3%a4chst-einmal-mit-einer-verwirrenden-vielfalt-neuer-konzepte-und-begriffe-konfrontiert-wir-wollen-hier-versuchen-einen-allgemeinen-%c3%bcberblick-%c3%bcber-das-gebiet-der-daten%c3%bcbertragung-zu-geben-und-die-wichtigsten-ideen-und-ausdr%c3%bccke-darzustellen&#34;&gt;
	Der Einsteiger in das Gebiet der Datennah- und fernübertragung wird zunächst einmal mit einer verwirrenden Vielfalt neuer Konzepte und Begriffe konfrontiert. Wir wollen hier versuchen, einen allgemeinen Überblick über das Gebiet der Datenübertragung zu geben und die wichtigsten Ideen und Ausdrücke darzustellen.
    &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;Die Grundaufgabe bei der Datenübertragung ist es, eine Menge an
Informationen von einem Gerät zu einem anderen zu übertragen. Diese
Formulierung ist mit Absicht genauso allgemein gewählt, wie sich das
Problem in der Wirklichkeit darstellen kann. Bei dem zu lösenden
Problem kann es sich um die einfache Übermittlung einer Grafikdateien
vom Rechner zum Drucker handeln, aber genausogut kann es sein, daß die
kompletten Konstruktionspläne eines Containerfrachters vom
koreanischen Konstruktionsbüro an eine Werft in Bremen oder Kiel
übermittelt werden müssen. Entsprechend vielfältig sind die Lösungen,
die für das jeweilige Problem gefunden werden und entsprechend
unterschiedlich ist nicht nur die verwendete Hard- und Software,
sondern auch die Begriffswelt, die die entsprechenden Personen
verwenden.&lt;/p&gt;
&lt;h2 id=&#34;das-osi-modell&#34;&gt;
    &lt;a href=&#34;#das-osi-modell&#34;&gt;
	Das OSI-Modell
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Um dieses Problem in den Griff zu bekommen, hat sich die
Normungskommision ISO zusammengesetzt und ein sogenanntes
&lt;em&gt;Referenzmodell&lt;/em&gt; für die Datenübertragung ausgearbeitet. Dieses
Referenzmodell wird allgemein als
&lt;em&gt;Open Systems Interconnect (OSI) Modell&lt;/em&gt; bezeichnet. Das Modell
gibt keine konkrete Lösung zur
Datenübertragungsproblemen an, sondern versucht das komplizierte
Problem Datenübertragung in kleine, leichter zu lösende Teilprobleme
zu unterteilen, die aufeinander aufbauen. Hat man ein Teilproblem im
Griff, kann man sich dem nächstkomplizierten Problem zuwenden. Das
OSI-Modell besteht insgesamt aus sieben Schichten, mit denen man
versucht, die Aufgabe zu strukturieren.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1995/02/bild1.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 1: Das OSI 7-Schichtenmodell&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Weil jede Schicht auf den darunter liegenden Schichten aufbaut, redet
man auch gelegentlich von einem Stapel oder &lt;em&gt;protocol stack&lt;/em&gt;. Man
kann nicht immer ein Protokoll oder eine Funktion in der realen Welt
genau auf eine Schicht im OSI-Referenzmodell abbilden. Das ist auch nicht
notwendig, denn das Modell stellt nur eine Strukturierungshilfe dar und
repräsentiert keine Gesetzmäßigkeit, nach der ein Protokoll zwangsläufig aufgebaut sein muß.&lt;/p&gt;
&lt;h2 id=&#34;von-punkt-zu-punkt&#34;&gt;
    &lt;a href=&#34;#von-punkt-zu-punkt&#34;&gt;
	Von Punkt zu Punkt
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Um Daten übertragen zu können, muß zunächst
einmal eine Verbindung zwischen den beteiligten Geräten
hergestellt werden. Genau damit beschäftigt sich die
unterste Schicht des OSI-Protokollturmes, die
&lt;em&gt;physical layer&lt;/em&gt;.  Damit eine Verbindung konstruiert werden kann,
ist es notwendig, die verwendeten Kabel und Stecker zu
normieren.  Außerdem müssen die elektrischen
Parameter der Übertragung festgelegt werden und eine
entsprechende Hardware vorhanden sein. Natürlich braucht
man heute für Standardfälle keine solchen
Vereinbarungen mehr zu treffen. Stattdessen existiert eine
reichhaltige Palette von Normen für die unterschiedlichsten
Anwendungsfälle. So legt die CCITT-Norm &lt;em&gt;V.24&lt;/em&gt; z.B. die
elektrischen Parameter einer seriellen Schnittstelle eines PC
fest, während die parallele Schnittstelle durch eine
Herstellernorm des Druckerherstellers *&lt;em&gt;Centronics&lt;/em&gt;
beschrieben wird.  Andere Normen beschreiben die Hardware zum
Anschluß an ein Ethernet, ein Token-Ring Netzwerk oder an
einen FDDI-Glasfaserring.&lt;/p&gt;
&lt;p&gt;Danach kann man sich Gedanken über ein &lt;em&gt;Übertragungsprotokoll&lt;/em&gt;
machen. Das Protokoll legt eine Verfahrensvorschrift fest, nach der
sich alle an der Übertragung beteiligten Geräte Zeichen auf dem
Übertragungsmedium signalisieren dürfen. Dabei muß nicht nur das wie
der Zeichenübertragung geregelt werden, sondern auch das wann. Das
bedeutet: Man muß nicht nur festlegen, wie und mit welcher
Geschwindigkeit die einzelnen Bits eines Datenbytes codiert werden,
sondern man muß auch festlegen, wie ein Gerät seine Übertragung
anmelden muß. Einerseits verhindert man damit, daß mehrere Sender
gleichzeitig versuchen, einem Empfänger eine Nachricht zu senden und
sich gegenseitig blockieren.
Diesen Teil eines Protokolles nennt man &lt;em&gt;media access layer&lt;/em&gt;, weil er den Zugriff auf das Datenübertragungsmedium - sprich: das Kabel - regelt.
Andererseits muß der Empfänger die Möglichkeit haben, eine Datenübertragung abzulehnen, weil er z.B. intern noch mit der Verarbeitung einer vorhergehenden Nachricht beschäftigt ist oder weil seine Puffer voll sind und die Daten deswegen nicht entgegen nehmen kann.
Diesen Teil eines Protokolles nennt man &lt;em&gt;flow control&lt;/em&gt; (Datenflußkontrolle).&lt;/p&gt;
&lt;h2 id=&#34;bitte-nicht-stören&#34;&gt;
    &lt;a href=&#34;#bitte-nicht-st%c3%b6ren&#34;&gt;
	Bitte nicht stören
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Jede Datenübertragung in der wirklichen Welt hat mit dem Problem
mehr oder minder starker Störungen zu kämpfen. Nachdem man das Problem
der Datenübertragung erst einmal grundsätzlich gelöst hat, kann man
sich daran machen, das Übertragungsprotokoll so zu verbessern, daß
solche Übertragungsfehler erkannt und korrigiert werden können.
Derartige Spezifikationen werden im OSI-Modell in die zweite Schicht,
die &lt;em&gt;data link layer&lt;/em&gt;, eingeordnet. Die Korrektur von
Übertragungsfehlern kann auf zwei Arten geschehen: Einmal könnte man
sich für die Übertragung einen speziellen Code definieren, der es
nicht nur möglich macht, Übertragungsfehler zu erkennen, sondern sogar
das ursprüngliche Zeichen zurückzuberechnen. Zum anderen könnte man
sich darauf beschränken, Fehler nur zu erkennen und dem Sender zu
signalisieren, die beschädigten Daten ein weiteres Mal zu übertragen.&lt;/p&gt;
&lt;p&gt;Dies ist das gebräuchlichere Verfahren, aber es setzt voraus, daß es
Rückkanal existiert, über den der Empfänger den Sender darüber
informieren kann, ob und wie gut die Übertragung funktioniert hat.
Wenn man sowieso schon dabei ist, mit verschiedenen Codierungen zu
hantieren, fügt man an dieser Stelle oft noch eine Kompression der
Daten für die Dauer der Übertragung mit ein. Dies ist letztendlich
auch nur ein weiteres Umkodieren von Zeichen, wenn auch mit dem Ziel,
eine möglichst kurze und nicht eine möglichst sichere oder leicht zu
verarbeitende Darstellung zu finden. Auf diese Weise kann man die
Übertragungsleistung einer Datenleitung noch beträchlich erhöhen. Je
nach Art der Daten und des verwendeten Kompressionsprogrammes ist eine
Steigerung um 200 % bis 500 % möglich.&lt;/p&gt;
&lt;h2 id=&#34;aus-vielen-verbindungen-wird-ein-netz-geknüpft&#34;&gt;
    &lt;a href=&#34;#aus-vielen-verbindungen-wird-ein-netz-gekn%c3%bcpft&#34;&gt;
	Aus vielen Verbindungen wird ein Netz geknüpft
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Auf diese Weise kann man sich eine schnelle und fehlerfreie
Verbindung zwischen zwei Endpunkten konstruieren. Fügt man noch eine
weitere Idee hinzu, gelangt man von Punkt-zu-Punkt Verbindungen zu
echten Rechnernetzen: In einem solchen Rechnernetz sind auch indirekte
Verbindungen möglich. Es besteht also die Möglichkeit, eine Nachricht
oder ein Datenpaket über einen oder mehrere andere Rechner an einen
Zielrechner zu senden. Der erste Rechner auf dem Weg nimmt das Paket
entgegen und stellt fest, über welche seiner Punkt-zu-Punkt
Verbindungen er es zum eigentlichen Zielrechner senden kann. Die
folgenden Rechner leiten das Paket ebenfalls weiter, solange bis es
den Zielrechner endlich erreicht.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1995/02/bild2.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 2: Ein Router nimmt ein Paket und leitet es an einen näher am Ziel gelegenen Rechner weiter. Auf diese Weise entstehen indirekte Verbindungen.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Um aus einem Netz von Punkt-zu-Punkt Verbindungen also ein echtes Rechnernetz zu machen, muß
man eine Route oder einen Pfad festlegen können, auf dem Informationen
übermittelt werden sollen. Dementsprechend muß man seinen Rechnern
&lt;em&gt;routing&lt;/em&gt; beibringen. In einem gut ausgebauten Rechnernetz kann es
mehr als eine Route geben, auf der man von einem Rechner zu einem
anderen gelangt. Dementsprechend wird ein guter Router nicht einfach
irgendeine Route auswählen, sondern versuchen, eine möglichst schnelle
oder möglichst billige Route zum Ziel zu finden. Routingprotokolle
werden im OSI-Modell in die dritte Schicht eingeordnet, die
dementsprechend &lt;em&gt;network layer&lt;/em&gt; heißt.&lt;/p&gt;
&lt;p&gt;Wenn man routet, kann es nicht nur vorkommen, daß eine Nachricht
über mehr als eine Leitung übertragen werden muß, bis sie am Ziel ist,
sondern es müssen auch Nachrichten von verschiedenen Systemen über
eine Leitung übertragen werden. Die Leitung muß also zwischen
verschiedenen Benutzern aufgeteilt werden. Dies erreicht man durch
&lt;em&gt;Multiplexen&lt;/em&gt; der Verbindung. Dabei werden die verschiedenen
Datenpakete unterschiedlicher Benutzer entweder nacheinander
übertragen (serielles Multiplexen) oder gleichzeitig, aber in
verschiedenen Frequenzbereichen, übermittelt (paralleles Multiplexen).
Außerdem kann es vorkommen, daß Routen zusammenbrechen, weil ein
Rechner auf dem Weg ausgefallen ist oder ein Kabel beschädigt worden
ist. Dadurch werden Routen ungültig und es kommt zu
Übertragungsfehlern, die korrigiert werden müssen. Dies ist die
Aufgabe der vierten OSI-Schicht, der &lt;em&gt;transport layer&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Nach der vierten Ebene des OSI-Protokollturmes hat man ein
Verfahren definiert, daß es zwei beliebigen Programmen über ein
Rechnernetz hinweg erlaubt, einen beliebigen Bytestrom auszutauschen.
Dieser Datenstrom hat noch keine Struktur, so wie eine Datei aus der
Sicht des Betriebssystems zunächst auch nur eine strukturlose
Ansammlung von Bytes ist. In den &lt;em&gt;weiteren Schichten des OSI-Modells&lt;/em&gt;
macht man sich jetzt daran, Protokolle zu definieren, um diesen
Bytestrom zu strukturieren, gemeinsame Repräsentationen von Daten
festzulegen und ähnliche Verfeinerungen zu definieren. Diese
Protokolle sind aber, genau wie Dateiformate für Dateien, abhängig von
der jeweiligen Anwendung.&lt;/p&gt;
&lt;h2 id=&#34;seriell-oder-parallel&#34;&gt;
    &lt;a href=&#34;#seriell-oder-parallel&#34;&gt;
	Seriell oder Parallel?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Wir wollen uns deswegen noch einmal den unteren Schichten des
OSI-Modells zuwenden. Bei der &amp;ldquo;selbstgemachten&amp;rdquo; Datenübertragung,
etwa über ein Modem oder ein Laplink-Kabel, hat man es meistens mit
den OSI-Schichten 1 und 2 zu tun. Wir wollen uns diejenigen Verfahren,
die in einem PC-Haushalt am gebräuchlichsten sind, einmal genauer
ansehen.&lt;/p&gt;
&lt;p&gt;Für kurze Strecken von einigen Metern wird man wegen der größeren
möglichen Geschwindigkeiten meistens eine parallele Datenübertragung
wählen. Bei dieser Form der Übertragung hat man ganzes Bündel von
Datenleitungen, etwa 8 Datenleitungen zur parallelen Übertragung eines
Bytes bei der Centronics-Schnittstelle. Auf je einer Leitung wird
dabei eines der 8 Bits eines Bytes signalisiert. Leider sind
elektronische Bauteile nicht immer gleich schnell, sodaß es sein kann,
daß Bit 3 einer Leitung einen winzigen Bruchteil einer Sekunde eher
verfügbar ist, als etwa Bit 6. Deswegen sieht man noch eine neunte
Leitung vor, die als Steuerleitung (&lt;em&gt;Strobe&lt;/em&gt;, &amp;ldquo;Bitte sehr&amp;rdquo;)
fungiert und signalisiert, daß die Inhalte der acht Datenleitungen
gültig sind.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1995/02/bild3.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 3: Signal-Zeitdiagramm an einer Centronics Schnittstelle. Die Datenübertragung erfolgt asychron ohne ein Taktsignal. Die Geschwindigkeit der Übertragung regelt sich durch die Bestätigung eines jeden Zeichens selbst.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Der Empfänger der Daten - bei einer
Centronics-Schnittstelle meistens ein Drucker - liest nach dem Empfang
des Steuersignals die Datenleitungen ab und bestätigt dies mit einem
Impuls (&lt;em&gt;Acknowledge&lt;/em&gt;, &amp;ldquo;Danke schön&amp;rdquo;) an den Sender, sobald er
fertig ist.&lt;/p&gt;
&lt;p&gt;Auf diese Weise regelt sich nicht nur die
Übertragungsgeschwindigkeit zwischen den beiden Partnern ganz
automatisch, sondern man hat auch ohne Mehraufwand ein Verfahren zur
Flußkontrolle bekommen: Wenn der Drucker keine weiteren Daten annehmen
kann, weil sein Puffer voll ist oder er zur Bearbeitung eines Zeichens
längere Zeit benötigt (um etwa das Papier vorzuschieben), kann er das
Bestätigungssignal verzögern und so den Sender auf die von ihm
benötigte Geschwindigkeit herunterbremsen. Weil sich Sender und
Empfänger frei über die Übertragungsgeschwindigkeit einigen (jeder so
schnell er kann), kann man keine allgemeine
Datenübertragungsgeschwindigkeit für eine Centronics-Schnittstelle
angeben. Sie liegt jedoch je nach Drucker- und Rechnermodell in der
Größenordnung von 60 bis 150 KB pro Sekunde. Noch größere
Geschwindigkeiten erlauben die in der Regel recht trägen
Ausgangsbausteine eines PC nicht.&lt;/p&gt;
&lt;p&gt;Parallele Datenübertragung ist relativ aufwendig: Immerhin muß für
jedes Bit, das zu Übertragen ist, eine eigene Leitung verlegt werden.
Das ist bei größeren Entfernungen zu teuer, denn man muß nicht nur
viele Kabel verlegen, sondern diese auch gegeneinander abschirmen,
damit sie sich nicht beeinflussen. Deswegen wird parallele
Datenübertragung nur dort eingesetzt, wo kurze Strecken zu überbrücken
sind: Vom Rechner zum Drucker, von der Festplatte zum Controller, von
der CPU über den Bus zur Peripherie.&lt;/p&gt;
&lt;p&gt;Für längere Strecken verwendet man bitserielle Übertragung. Hier
wird jeweils ein Datenbyte in ein Schieberegister geladen und Bit für
Bit auf einer einzelnen Signalleitung übermittelt. Für eine minimale
Verkabelung braucht man bei einer seriellen Schnittstelle nur drei
Leitungen im Gegensatz zu mindestens elf bei einer parallelen
Schnittstelle: Eine Leitung für die Sendedaten, eine für die
Empfangedaten und eine gemeinsame Masseleitung, damit ein elektrischer
Bezugspegel existiert. Und dabei ist bei einer seriellen Schnittstelle
dann schon Kommunikation in beide Richtungen möglich, während eine
Centronics-Schnittstelle nur als Sender betrieben wird.  Doch dadurch,
daß die einzelnen Bits nacheinander über eine einzelne Leitung
übermittelt werden müssen, ist diese Art der Übertragung langsamer:
Ein PC erreicht eine Höchstgeschwindigkeit von 115200 Bit pro Sekunde,
das sind etwa 11.2 KB/Sekunde.&lt;/p&gt;
&lt;h2 id=&#34;v24&#34;&gt;
    &lt;a href=&#34;#v24&#34;&gt;
	V.24
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1995/02/bild4.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 4: Belegung und Bedeutung der Anschlüsse an einer V.24 Schnittstelle.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Die Leitungen an einer V.24 Schnittstelle, die die eigentliche
Übertragungsarbeit leisten, sind die Pins 2 (Transmit Data,
Sendedaten) und 3 (Receive Data, Empfangsdaten). Dort wird
mit den Pegeln +12V eine logische Null und -12V eine logische 1
signalisiert. Um Zeichen zu übertragen, müssen sich Sender und
Empfänger darüber einig sein, aus wievielen Bits ein Zeichen besteht,
wie schnell die einzelnen Bits signalisiert werden und an welchem Ende
eines Bytes angefangen wird, zu übertragen. Einige dieser Parameter
sind festgelegt, andere sind in gewissen Grenzen variabel. Wenn Sender
und Empfänger nicht auf genau die gleichen Übertragungsparameter
eingestellt sind, wird die Übertragung nicht gelingen.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1995/02/bild5.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 5: Bitfolge auf einem V.24 Kabel zur Übertragung eines 7 Bit Zeichens mit gerader Parität: Nach dem Startbit folgenden die 7 Datenbits, das niederwertigste Bit zuerst. Das Paritätsbit sorgt dafür, daß die Anzahl der Einsbits im Datenwort gerade ist. Mit dem Stopbit wird das Ende des Datenwortes signalisiert.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Das Verfahren zur Übermittlung von Zeichen ist genau wie die
Steckerbelegung und die verwendeten Spannungen in der V.24-Norm
festgelegt. Wenn kein Zeichen zur Übertragung anliegt, soll die
Schnittstelle auf 1-Pegel liegen. Sobald dann ein Zeichen zu
übertragen ist, wird zunächst durch Übermittlung eines 0-Bits
signalisiert, daß jetzt ein Zeichen zu übertragen ist. Dieses 0-Bit
wird als Startbit bezeichnet. Danach werden die einzelnen Bits eines
Bytes übermittelt, und zwar mit dem niederwertigsten Bit zuerst. Nach
dem Byte wird eventuell noch ein Paritätsbit zur Fehlererkennung
mitgesendet und danach wird die Leitung für eine gewisse Mindestdauer
auf den Ruhepegel logisch 1 gelegt. Diese Pause stellt sicher, daß ein
nachfolgendes Startbit sicher erkannt werden kann und wird als Stopbit
bezeichnet.&lt;/p&gt;
&lt;p&gt;Zur Übermittlung eines einzelnen Bytes sind 8 Datenbits plus ein
Startbit plus ein Stopbit zu übertragen. Bei einer Datenrate von 9600
Bit pro Sekunde werden pro Sekunde also genau 960 Byte transportiert.
Der Benutzer einer seriellen Schnittstelle kann einige Parameter der
Übertragung frei festlegen.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1995/02/bild6.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 6: Nicht alle Parameter einer seriellen Schnittstelle sind konfigurierbar. Einstellbar sind neben der Geschwindigkeit der Übertragung auch die Anzahl der Datenbits pro Datenwort, die Parität und die Anzahl der Stopbits. Übliche Parameterwerte sind 8-N-1 oder 7-E-1.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Als wichtigster Parameter ist
dort die Übertragungsgeschwindigkeit in Bit pro Sekunde zu nennen. Die
Basis bildet eine Datenrate von 300 Bit pro Sekunde. Die anderen
möglichen Übertragungsgeschwindigkeiten ergeben sich dann durch
Verdoppelung: 300, 600, 1200, 2400, 4800, 9600, 19200 und 38400 Bit
pro Sekunde. Noch höhere Datenraten sind in der V.24 Norm zwar nicht
definiert, aber die meisten Programme können außerdem noch mit 57600
und 115200 Bit pro Sekunde senden.&lt;/p&gt;
&lt;p&gt;Ein einzelnes Zeichen besteht heute normalerweise aus 8 Datenbits.
In den Anfangstagen der Datenverarbeitung kam man noch ohne Umlaute
und Sonderzeichen zurecht und nutzte damit nur einen über 7 Bit
definierten ASCII-Zeichensatz aus. Das achte Bit wurde dann nicht zur
Codierung von Daten genutzt, sondern in Form eines Paritätsbits für
eine einfache Fehlerkontrolle verwendet. Die Parität eines Zeichens
berechnet man, indem man die 1-wertigen Bits in der Binärdarstellung
seines Zeichencodes zählt. Ist die Anzahl ungerade, hat das Zeichen
ungerade Parität, ist sie gerade, hat es eine gerade Parität. Bei der
Datenübertragung kann man gerade oder ungerade Parität wählen: Stellt
man gerade Parität ein, wird bei Zeichen mit ungerader Parität das
achte Bit gesetzt, um die Anzahl der 1-Bits im Zeichen wieder auf eine
gerade Anzahl zu bringen.&lt;/p&gt;
&lt;p&gt;Auf diese Weise kann man Übertragungsfehler leicht erkennen: Da
nur Zeichen mit gerader Parität übermittelt werden, muß ein Zeichen
mit ungerader Parität einer Störung zum Opfer gefallen sein. Leider
besteht ohne ein Protokoll zur Fehlerkorrektur keine Möglichkeit,
dieses Zeichen erneut übertragen zu lassen, sodaß man zwar die
Information hat, daß ein Fehler aufgetreten ist, aber keine Chance
hat, diesen zu korrigieren. Da Parität als Fehlerkorrektur also nur
von begrenztem Nutzen ist, verwendet man sie heute normalerweise nicht
mehr, sondern nutzt das achte Bit als normales Datenbit mit. Während
man früher als gelegentlich 7 Datenbits, gerade Parität und ein
Stopbit als Schnittstellenparameter gewählt hat, verwenden heute fast
alle Systeme 8 Datenbits, keine Parität und ein Stopbit.&lt;/p&gt;
&lt;p&gt;Im Gegensatz zum Protokoll einer Centronics-Schnittstelle bekommt
man bei der V.24 Schnittstelle die Datenflußkontrolle nicht als
Abfallprodukt des Übertragungsprotokolls. Stattdessen müssen
ausdrückliche Vereinbarungen zwischen dem Sender und dem Empfänger
getroffen werden. Für die bereits erwähnte Dreidrahtleitung verwendet
man dazu zwei besondere ASCII-Zeichen, die Zeichen Control-S (XOFF,
ASCII 13h) und Control-Q (ASCII 11h, XON). Wenn der Empfänger keine
weiteren Daten mehr aufnehmen kann, sendet er das Zeichen XOFF an den
Sender. Der Sender muß daraufhin die Übertragung einstellen. Sobald
der Empfänger wieder bereit ist, Daten entgegenzunehmen, signalisiert
er dies dem Sender mit dem Zeichen XON.&lt;/p&gt;
&lt;p&gt;Dieses Verfahren ist praktisch, weil es keine weiteren
Steuerleitungen notwendig macht, hat aber den Nachteil, zwei Zeichen
aus dem Zeichensatz zu &amp;ldquo;verbrauchen&amp;rdquo;. Diese Zeichen werden für
Steuerfunktionen verwendet und können nicht mehr direkt übermittelt
werden. Stattdessen müssen sie durch bestimmte Zeichenfolgen anderer
Zeichen &amp;ldquo;umschrieben&amp;rdquo; werden. Eine Leitung, die nicht für alle
ASCII-Zeichen durchlässig ist, nennt man &lt;I&gt;nicht transparent&lt;/I&gt;. Auf
einer nicht transparenten Leitung müssen die Zeichen, die nicht direkt
übermittelt werden können mit Hilfe eines &lt;I&gt;Escape-Mechanismus&lt;/I&gt;
umschrieben werden.&lt;/p&gt;
&lt;p&gt;Eine andere Methode der Flußkontrolle verwendet statt zweier
Zeichen zwei zusätzliche Steuerleitungen an der V.24 Schnittstelle.
Die Leitungen an den Pins 4 (Request to Send, RTS) und 5 (Clear to
Send, CTS) signalisieren für jeweils eine Übertragungsrichtung, ob
gesendet werden darf oder nicht. Solange die zu der jeweiligen
Datenleitung gehörige Steuerleitung 1-Pegel führt, darf gesendet
werden. Sobald der Pegel auf 0 wechselt, muß der Sender seine Arbeit
so lange einstellen, bis der Pegel wieder auf 1 wechselt.
Datenflußkontrolle mit RTS und CTS ist nicht nur transparent, sondern
auch schneller und sicherer als XON/XOFF-Steuerung. Gerade bei höheren
Datenraten sollte man daher dieses Verfahren vorziehen.&lt;/p&gt;
&lt;h2 id=&#34;übertragungsstreß&#34;&gt;
    &lt;a href=&#34;#%c3%bcbertragungsstre%c3%9f&#34;&gt;
	Übertragungsstreß
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Hohe Datenraten sind auch aus einem anderen Grund ein Problem:
Normalerweise wird die serielle Schnittstelle in einem PC von einem
Baustein vom Typ 16450 oder einem seiner Verwandten betreut. Diese
Bausteine lösen für jedes empfangene oder gesendete Zeichen eine
Unterbrechung aus. Wird die Schnittstelle also mit 38400 Bit pro
Sekunde unter Vollast betrieben, erzeugt sie um die 8000
Unterbrechungen pro Sekunde. Das bedeutet: 8000 mal pro Sekunde wird
das gerade laufende Programm unterbrochen, um ein Zeichen für den
Schnittstellenbaustein zu lesen oder ihm das nächste Zeichen zum
Senden zu nennen. Gerade bei Betriebssystemen, die den Prozessor im
erweiterten 386-Modus betreiben, können diese Unterbrechungen sehr
aufwendige Umschaltungen in der Betriebsart des Prozessors notwendig
machen. Das kostet wertvolle Rechenzeit und der Rechner wird unnötig
langsam oder verliert bei der Übertragung sogar einzelne Zeichen.
Schnittstellenbausteine vom Nachfolgetyp 16550AF haben deswegen eine
Warteschlange, die mehrere übertragene Zeichen speichern kann. Solche
Bausteine müssen im Durchschnitt nur noch alle 4 Zeichen vom Prozessor
betreut werden und sind gerade unter
Multitasking-Betriebssystemen für einen sicheren Betrieb der seriellen
Schnittstelle bei hohen Geschwindigkeiten unerlässlich. Der 16550AF ist
pinkompatibel zu seinem Vorgänger 16450 und kann, wenn dieser
gesockelt ist, auch leicht ausgetauscht werden.&lt;/p&gt;
&lt;h2 id=&#34;fehlerkorrektur&#34;&gt;
    &lt;a href=&#34;#fehlerkorrektur&#34;&gt;
	Fehlerkorrektur
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Bei der Übertragung von Dateien und Programmen ist es sehr
wichtig, daß auch bei schlechten Verbindungen alle Daten unverfälscht
und fehlerfrei übermittelt werden. Schon ein einziges falsch gesetztes
Bit in einer Programmdatei kann fatale Folgen haben. Deswegen schützt
man eine Datenübertragung in der Regel mit einem
Übertragungsprotokoll. Es gibt viele dieser Protokolle, von
unterschiedlicher Datensicherheit und Effizienz, aber das Grundprinzip
ist bei allen gleich: Immer wird ein Block von Daten (z.B. 128 oder
1024 Byte am Stück) gefolgt von einer durch den Sender errechneten
Prüfsumme übermittelt. Der Empfänger liest den Datenblock und
errechnet die Prüfsumme nach demselbem Verfahren selbst. Stimmt die
errechnete Prüfsumme mit der empfangenen Prüfsumme überein, ist der
Datenblock korrekt angekommen und wird bestätigt. Andernfalls wird
eine Fehlermeldung an den Sender zurückgegeben, der daraufhin den
Datenblock noch einmal überträgt.&lt;/p&gt;
&lt;p&gt;Das primitivste dieser Protokolle, das im PC-Bereich Anwendung
findet, ist das X-MODEM Protokoll. Es sendet relativ kleine Blöcke von
128 Zeichen und eine einfache Summe der übertragenen Bytes. Summen
sind aber relativ schlechte Indikatoren für Verfälschungen: Sie
registrieren nicht die Einfügung von Nullbytes, sind unempfindlich
gegenüber Vertauschungen von Bytes und können bestimmte Doppelfehler
(eine Erhöhung um Eins an einer Stelle und eine Verminderung um Eins
an anderer Stelle) nicht erkennen. CRC-Prüfziffern (&lt;em&gt;cyclic
redundancy check&lt;/em&gt;) erkennen alle diese und viele andere
Veränderungen an Daten und werden deswegen in der Computertechnik
immer dann eingesetzt, wenn die Integrität eines Datenblockes
gesichert werden muß.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;XMODEM&lt;/em&gt; ist auch aus anderen Gründen ein relativ schlechtes
Protokoll: Es überträgt keine Informationen über die Datei. Weder der
Dateiname noch die Länge, das Datum oder eventuell vorhandene
Dateieigentümer oder Zugriffsrechte werden übermittelt. Außerdem
wartet XMODEM nach jedem gesendeten Block erst auf die Bestätigung der
Gegenseite, bevor der nächste Datenblock verschickt wird. Ein
Datenpaket muß gewissermaßen erst seine Rundreise auf einer Leitung
beendet haben, bevor das nächste Datenpaket verschickt werden kann.
Man kann sich eine Datenleitung vorstellen, wie einen Gartenschlauch:
Nachdem man das Ventil aufgedreht hat, muß der Schlauch erst
vollaufen, bevor am Ende des Schlauches Wasser austritt. XMODEM
versendet die Daten jetzt nicht als Strom, sondern schickt sie
gewissermaßen schluckweise durch die Leitung. Auf diese Weise wird
möglicherweise ein Großteil der Übertragungskapazität der Leitung
verschenkt.&lt;/p&gt;
&lt;p&gt;ZMODEM hat diese Probleme nicht: Nicht nur, daß es Dateinamen,
Länge und andere Informationen mit überträgt. Es ist auch in der Lage,
weitere Datenblöcke zu versenden, bevor die Bestätigungen für
vorhergehende Pakete eingegangen sind.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1995/02/bild7.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 7: Der Sender kann dem Empfänger vorauseilen. Er sendet Daten,
deren Empfang der Empfänger noch nicht bestätigt hat. Das bedeutet, für
solche unbestätigten Daten muß der Sender damit rechnen, daß sie nicht
ordnungsgemäß beim Empfänger angekommen sind und noch einmal gesendet werden
müssen. Daten, die bereits als fehlerfrei bestätigt sind, kann der Sender
als erledigt betrachten.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Die Frage ist: Wie groß darf soll der Sender das Transferfenster werden
lassen? Läßt er es zu klein, kann es sein, daß er auf die Bestätigungen des
Empfängers warten muß, bevor er weiter senden darf. Läßt der Sender das
Transferfenster zu groß werden, muß er sehr viel Speicher für Puffer
bereitstellen.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In diesem Fall
entsteht ein Bereich von Datenpaketen, die der Sender zwar schon
abgeschickt hat, für die er aber noch keine positiven
Empfangsbestätigungen gesehen hat. Diese Lücke nennt man das
&lt;em&gt;Transferfenster&lt;/em&gt; eines Übertragungsprotokolls. Ein gutes
Übertragungsprotokoll wird das Transferfenster gerade so groß halten,
wie die Kapazität der Leitung es erfordert. Bei einem Wasserschlauch
würde man die Kapazität in Litern als Querschnitt mal Länge berechnen.
Bei einer Datenleitung entspricht der Querschnitt der Datenrate in Bit
pro Sekunde und die Länge der Umlaufzeit der Datenpakete in Sekunden.
Das Resultat gibt die Anzahl der Bits an, die auf der Leitung
unterwegs sind und stellt eine minimale Größe für das Transferfenster
dar, wenn der Sender nicht auf den Empfänger warten soll.&lt;/p&gt;
&lt;h2 id=&#34;modulation&#34;&gt;
    &lt;a href=&#34;#modulation&#34;&gt;
	Modulation
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Während bei der Datenübertragung über ein einfaches Kabel keine
besondere Codierung der Daten notwendig war, ist dies bei der
Datenfernübertragung nicht mehr möglich. Eine Telefonleitung ist kein
durchgehendes Kabel, sondern vielfach durch Filter, Verstärker und
andere elektrische Dinge unterbrochen. Sie ist für Gleichspannungen
nicht durchlässig, sondern kann nur Wechselspannungen, elektrisch
codierte Töne nämlich, übertragen. Bevor man Daten also über eine
Telefonleitung übertragen kann, muß man sie in hörbare Töne umwandeln.
Diese Umwandlung wird von einem &lt;em&gt;Modem&lt;/em&gt; vorgenommen. Der Name ist
ein Kunstwort aus den Begriffen Modulator und Demodulator und
beschreibt in etwa die Funktionsweise des Gerätes: Ein gleichmäßiger
Ton, der Datenträgerton, wird abhängig von den zu übertragenden Daten
verändert.&lt;/p&gt;
&lt;p&gt;Im einfachsten Fall ordnet man dabei einem Eins-Bit einen Ton und
einem Null-Bit einen anderen Ton zu. Auf diese Weise beeinflußt man
jedoch nur einen einzigen Parameter einer Schwingung, nämlich die
Tonhöhe, die Frequenz.  Außerdem überträgt man so nur ein Bit zur
Zeit.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1995/02/bild8.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 8: Das Diagramm zeigt Phasenwinkel und Amplitudenwerte eines
Signals. Der Sender steuert zur Signalisierung eines von 16 Zuständen Phase
und Amplitude seines Signals so, daß er einen der markierten Punkte trifft.
Auf diese Weise können in einem Zustand 4 Bit signalisiert werden.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Durch Störungen der Übertragung kommt beim Empfänger nicht genau das Signal
an, das der Sender auf das Kabel schickt. Stattdessen wird der angesteuerte
Punkt nur in der Nähe der markierten Punkte liegen und zwar um so weiter
von den Punkten entfernt, je stärker das Signal gestört wird. Auf schlechten
Leitungen verschwimmen die Punkte also stärker als auf guten Leitungen. Wenn
die Störungen so groß werden, daß die Punkte ineinander verschwimmen, ist
die Leitungsqualität so schlecht, daß keine Datenübertragung mehr möglich
ist.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Wenn man gleichzeitig mehrere Parameter einer Schwingung
verändert, kann hat man mehr als zwei verschiedene Zustände und kann
so mehrere Bits zur Zeit übertragen. Das Bild zeigt ein Verfahren, bei
dem Phase und Amplitude eines Signales jeweils einen von vier
Zuständen annehmen können. Auf diese Weise ist es möglich, sechzehn
verschiedene Zustände zu codieren und vier Bit parallel zu
übermitteln. Die Geschwindigkeit, mit der ein Modem von einem
Signalzustand zum nächsten wechselt, nennt man die Baudrate. Eine
Geschwindigkeit von einem Baud entspricht einem Zustandswechsel pro
Sekunde. Die Bitrate eines Modems ist gewöhnlich ein Vielfaches seiner
Baudrate.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Bezeichnung Geschwindigkeit
            in Bit/s  in Baud	Modulation  duplex  Verwendung
V.17	    14400	2400	TCM	    halb	FAX
	    12000
            9600
            7200	2400 	TCM	    halb	FAX
	    4800	2400	QAM	    halb	FAX
V.21	    300		300	FSK	    voll
V.22	    1200	600	DPSK	    voll
V.22bis	    2400	600	QAM	    voll
V.23	    1200/75	1200/75	FSK	    asymm.	BTX
V.27ter	    4800	1600	DPSK	    halb	FAX
	    2400	1200	DPSK	    halb	FAX
V.29	    9600	2400	QAM	    halb	FAX
	    7200	2400	QAM	    halb	FAX
V.32	    9600	2400	TCM/QAM	    voll
	    4800	2400	QAM	    voll
V.32bis	    14400 	2400	TCM	    voll
	    12000
	    9600
	    7200	2400	TCM	    voll
	    4800	2400	QAM	    voll

Abkürzungen:
FSK	Frequency Shift Keying
DPSK	Differential Phase Shift Keying
QAM	Quadrature Amplitude Modulation
TCM	Trellis Coded Modulation
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;Bild 9: CCITT-Normen, Datenraten, Baudraten und Modulationsverfahren von Modems im Überblick.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Es gibt verschiedene CCITT-Normen, die unterschiedlich schneller
Übertragungsverfahren für Modems normen. Während die
meisten Modem-Normen gleichzeitiges Senden und Empfangen von Daten
vorsehen, sehen die CCITT-Normen für FAX-Geräte keine Datenübertragung
im zwei Richtungen vor. Grundsätzlich unterscheidet man drei Fälle:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ist die Übertragung &lt;em&gt;simplex&lt;/em&gt;, wird die Datenrichtung der Übertragung niemals umgeschaltet:
Der Sender hat nur einen Modulator, der Empfänger nur einen Demodulator.&lt;/li&gt;
&lt;li&gt;Bei einer Übertragung in &lt;em&gt;halbduplex&lt;/em&gt; sendet immer nur einer der beteiligten Partner.
Wenn er &amp;ldquo;ausgeredet&amp;rdquo; hat, wechselt die Übertragungsrichtung und der jeweils andere Partner kommt an die Reihe.
FAX-Geräte übertragen ihre Informationen auf diese Weise.&lt;/li&gt;
&lt;li&gt;Die meisten Modemnormen sehen eine &lt;em&gt;vollduplex&lt;/em&gt;-Übertragung vor.
Hier können beide Partner gleichzeitig senden und empfangen.
Damit sich die Signale der beiden Modems leicht getrennt werden, sendet der angerufene Partner bei den Normen V.21, V.22 und V.23 auf einer anderen Frequenz als der Anrufer (&lt;em&gt;answer mode/originate  mode&lt;/em&gt;).
Die unterschiedlichen Signale der beiden Modems lassen sich mit einem einfachen Filter voneinander trennen.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Die Normen V.32 und höher sehen vor, daß Anrufer und Angerufener
beide auf denselben Frequenzen senden, sich also quasi &amp;ldquo;anschreien&amp;rdquo;.
Auf der Leitung vermischen sich beide Signale zu einem nicht
entzifferbaren Datensignal. Da jedoch jedes der beiden Modems weiß,
welche Töne es gesendet hat, kann es diese Daten von den empfangenen
Signalen abziehen und erhält als Differenzsignal die Informationen der
Gegenseite. Dieses als &lt;em&gt;echo cancellation&lt;/em&gt;  bezeichnete Verfahren
setzt jedoch einen aufwendigen Signalprozessor voraus, der die
entsprechenden Berechnungen auf dem Eingangssignal vornimmt. Da die
entsprechenden Prozessoren lange Zeit sehr teuer waren, waren die
entsprechenden Modems gut doppelt so teuer wie ihre kleineren Brüder
ohne Signalprozessor. Heute existieren für V.32 und V.32bis fertige
Chipsätze mit integrierten Faxoptionen, die in großen Stückzahlen
produziert werden. Entsprechend gibt es Modems für diese
Übertragungsnormen zu relativ günstigen Preisen, obwohl das
Modulationsverfahren sehr aufwendig und rechenintensiv ist.&lt;/p&gt;
&lt;p&gt;Für das neue V.34-Verfahren sind solche Chipsätze noch nicht
verfügbar, sodaß diese Modems zur Zeit noch unverhältnismäßig teuer
sind.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Norm	Zweck
V.24	Bedeutung der Signale an einer seriellen 
	Schnittstelle.
V.28	Elektrische Pegel an einer solchen Schnittstelle.
	(V.24, V.28 und ISO 2110 sind zusammen äquivlaent 
	zu EIA RS232.)
V.42	Verfahren zur Sicherung der übertragenen Daten. Im 
	wesentlichen nicht von dem unterliegenden 
	Modulationsverfahren abhängig. Verwendet ein eigenes 
	Protokoll namens LAPM, zwecks Kompatibilität ist ein
	Rückfall auf MNP 2-4 möglich.
V.42bis	Verfahren zur transparenten Kompression von Daten
	während der Übertragung, manchmal auch BTLZ genannt.
	Effizienter als, aber inkompatibel zu MNP5.
	Alle existierenden V.42bis-Modems beherrschen MNP5
	zusätzlich.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;Bild 10: Weitere häufig verwendete CCITT-Normen im Zusammenhang mit Modems.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>UNIX Dateisysteme</title>
      <link>https://blog.koehntopp.info/1994/02/01/dateisysteme.html</link>
      <pubDate>Tue, 01 Feb 1994 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/1994/02/01/dateisysteme.html</guid>
      <description>&lt;h1 id=&#34;unix-dateisysteme&#34;&gt;
    &lt;a href=&#34;#unix-dateisysteme&#34;&gt;
	UNIX Dateisysteme
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;aus »c&amp;rsquo;t - Magazin für Computertechnik«, Ausgabe 2/94&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;die-aufgaben-eines-betriebssystems-bestehen-in-der-fairen-zuteilung-der-systemressourcen-an-alle-bewerber-und-in-der-abstraktion-unterschiedlichster-hardware-zu-einer-virtuellen-maschine-für-den-bereich-der-plattenplatzverwaltung-hat-diese-aufgabe-das-dateisystem-unix-dateisysteme-haben-eine-mehr-als-zwanzigjähirge-entwicklung-hinter-sich-und-dienten-als-vorbild-für-die-dateisysteme-vieler-anderer-betriebssysteme-1-trotz-vieler-mängel-der-ursprünglichen-implementation-haben-sich-die-dahinter-stehenden-ideen-in-den-letzten-zwanzig-jahren-nicht-wesentlich-verändert&#34;&gt;
    &lt;a href=&#34;#die-aufgaben-eines-betriebssystems-bestehen-in-der-fairen-zuteilung-der-systemressourcen-an-alle-bewerber-und-in-der-abstraktion-unterschiedlichster-hardware-zu-einer-virtuellen-maschine-f%c3%bcr-den-bereich-der-plattenplatzverwaltung-hat-diese-aufgabe-das-dateisystem-unix-dateisysteme-haben-eine-mehr-als-zwanzigj%c3%a4hirge-entwicklung-hinter-sich-und-dienten-als-vorbild-f%c3%bcr-die-dateisysteme-vieler-anderer-betriebssysteme-1-trotz-vieler-m%c3%a4ngel-der-urspr%c3%bcnglichen-implementation-haben-sich-die-dahinter-stehenden-ideen-in-den-letzten-zwanzig-jahren-nicht-wesentlich-ver%c3%a4ndert&#34;&gt;
	Die Aufgaben eines Betriebssystems bestehen in der fairen Zuteilung der Systemressourcen an alle Bewerber und in der Abstraktion unterschiedlichster Hardware zu einer virtuellen Maschine. Für den Bereich der Plattenplatzverwaltung hat diese Aufgabe das Dateisystem. UNIX Dateisysteme haben eine mehr als zwanzigjähirge Entwicklung hinter sich und dienten als Vorbild für die Dateisysteme vieler anderer Betriebssysteme [1]. Trotz vieler Mängel der ursprünglichen Implementation haben sich die dahinter stehenden Ideen in den letzten zwanzig Jahren nicht wesentlich verändert.
    &lt;/a&gt;
&lt;/h4&gt;
&lt;h2 id=&#34;daten-wiederfinden&#34;&gt;
    &lt;a href=&#34;#daten-wiederfinden&#34;&gt;
	Daten wiederfinden
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;UNIX schlägt sich auf den höheren Ebenen des Betriebssystems nicht  mit Angaben zur Plattengeometrie herum.
Es betrachtet eine Festplatte als ein langes Band von Plattenblöcken, die linear durchnummeriert sind.
Die Umrechnung von linearen Blockadressen in Angaben von Zylinder, Kopf und Sektor ist entweder Aufgabe eines Festplattengerätetreibers oder - im Fall von SCSI - der Festplatte selbst.
Die ersten paar Datenblöcke einer Festplatte sind reserviert für den Bootloader und ähnliche Dinge, die vor dem Betriebssystem geladen werden und deshalb außerhalb seiner Reichweite gelagert werden.
Der Rest der Platte  wird in Form eines Dateisystems verwaltet.
UNIX operiert bei Dateisystemen mit der Blockgröße des Mediums.
Anders als bei DOS werden die Verwaltungseinheiten auf einer Platte also nicht größer, wenn man sehr große Partitionen anlegt.&lt;/p&gt;
&lt;p&gt;Den Anfang eines Dateisystems bildet der sogenannte Superblock, der das Dateisystem selbst beschreibt.
Er enthält Geometriedaten der Platte, gibt an, wie viele Blöcke das Dateisystem enthält und welche davon Verwaltungsinformationen und welche Daten enthalten.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/disklayout.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 1: Am Anfang des Dateisystems steht der Superblock. Er enthält alle Metainformationen, die das Dateisystem beschreiben. Der &amp;ldquo;vordere&amp;rdquo; Teil des Dateisystems enthält I-Nodes, Dateiköpfe, die alle Metainformationenen über eine Datei speichern. In den Datenblöcken sind dann die eigentlichen Nutzdaten untergebracht. Das Bild zeigt eine I-Node mit ihren Verweisen auf die Datenblöcke der Datei.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Die Basis der Dateiverwaltung bildet in UNIX eine Datenstruktur, die sogenannte &lt;em&gt;index node&lt;/em&gt; oder I-Node (Bild 2).&lt;/p&gt;
&lt;p&gt;In ihr sind - mit einer Ausnahme, dem Dateinamen - alle wesentlichen Informationen über eine Datei gesammelt.
Für jede Datei, jedes Verzeichnis und jedes Gerät legt UNIX eine I-Node an, in der es alles vermerkt, was es über dieses Datenobjekt weiß.
Dazu gehören zum einen Informationen über Zugriffsrechte, Dateieigentümer und Zeitmarken, zum anderen Verweise auf die Datenblöcke, die die Daten der Datei enthalten.
Ursprünglich hat UNIX die I-Nodes eines Dateisystems in Form einer Tabelle zusammengefasst und am Anfang des Dateisystems untergebracht.&lt;/p&gt;
&lt;p&gt;Die Größe dieser Tabelle muss schon beim Anlegen des Dateisystems festgelegt werden, d.h. ein Systemverwalter auf einem UNIX-Rechner muss beim Formatieren einer Platte festlegen, wie viele Dateien später einmal maximal auf dieser Platte angelegt werden können.
Üblicherweise berechnet man mindestens eine I-Node für jeweils 4 KB zur Verfügung stehenden Plattenplatz, sodass auf einer 200 MB Festplatte in etwa 50 000 I-Nodes angelegt werden.
Zum Glück sind I-Nodes relativ kleine Datenstrukturen von nur 128 Bytes.
Im Schnitt verschwinden also auf diese Weise 3 % des gesamten Plattenplatzes in Verwaltungsinformationen.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct  dinode
{
/*	Typ     Feldname          Byte-Offset: Beschreibung */
	u_short ino_mode;        /*  0: Dateityp und Zugriffsrechte */
	short   ino_nlink;       /*  2: Anzahl der Namen der Datei  */
        uid_t   ino_uid;         /*  4: Benutzernummer Dateieigentümer */
	gid_t   ino_gid;         /*  6: Gruppennummer Dateieigentümer */
	off_t   ino_size;        /*  8: Größe in Bytes */
	time_t  ino_atime;       /* 16: Zeit des letzten Lesezugriffs */
	long    ino_atspare;     /*     in Sekunden seit 1.1.1970, 0 Uhr */
	time_t  ino_mtime;       /* 24: Zeit des letzten Schreibzugriffs */
	long    ino_mtspare;
	time_t  ino_ctime;       /* 32: Zeit der letzten Statusänderung */
	long    ino_ctspare;
        daddr_t ino_db[NDADDR];  /* 40: Blocknummern der ersten 12 Datenblöcke */
        daddr_t ino_ib[NIADDR];  /* 88: Blocknummern der 3 indirekten Datenblöcke */
        long    ino_blocks;      /* 100: Größe der Datei in Blöcken */
        long    ino_gen;         /* 104: Generationsnummer (NFS) */
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;Bild 2: Aufbau einer I-Node eines modernen UNIX-Dateisystems. Die Datenstruktur paßt in ein Feld von 128 Bytes, sodas ein Hardware-Plattenblock 8 I-Nodes halten kann. Sie enthält alle Metainformationen über eine Datei mit Ausnahme der Namen der Datei.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Untersucht man die durchschnittliche Länge von Dateien in einem Dateisystem, dann stellt man fest, das kurze Dateien relativ häufig auftreten.
Daher versucht UNIX, die Blocknummern der ersten paar Plattenblöcke einer Datei direkt in der I-Node zu speichern.
In der I-Node aus Bild 2 werden die ersten 12 Datenblöcke einer Datei im Feld &lt;code&gt;ino_db[]&lt;/code&gt; abgelegt.
Wenn über ihre I-Nodenummer auf diese Datei zugegriffen wird, stehen die 12 direkten Datenblöcke der Datei also ohne weitere Leseoperation zur Verfügung.&lt;/p&gt;
&lt;p&gt;Für große Dateien ist dieses Verfahren natürlich nicht praktikabel, denn die I-Node würde dann sehr groß werden.
Wächst eine Datei über die Größe von 12 Datenblöcken hinaus, besorgt UNIX einen freien Datenblock und trägt diesen als ersten indirekten Datenblock einer Datei ein.
In diesem indirekten Datenblock werden jetzt die Blocknummern der weiteren Datenblöcke einer Datei abgelegt.
Bei einer angenommenen Blockgröße von einem Kilobyte können in einem indirekten Block 256 Blocknummern gespeichert werden, von denen jede einen Datenblock von einem Kilobyte adressiert.
Zusammen mit den direkten Datenblöcken können also Dateien bis zu einer Größe von 266 KB angelegt werden, ohne daß mehr als eine Ebene der Indirektion durchlaufen werden muss.
Modernere Dateisysteme, die mit einer Blockgröße von 8 Kilobyte arbeiten, bringen 2048 Blocknummern in einem Block unter und können so bis zu 16 Megabyte große Dateien mit einem einzigen indirekten Block verwalten.&lt;/p&gt;
&lt;p&gt;Für noch größere Dateien sieht UNIX doppelt indirekte Blöcke vor, die die Blocknummern von einfach indirekten Blöcken enthalten.
Diese wiederum zeigen dann endlich auf die Daten.
Bei einer Blockgröße von 8 KB kann man mit diesem Schema schon mehr als die vier Gigabyte verwalten, die sich im Größenfeld &lt;code&gt;ino_size&lt;/code&gt; einer I-Node verwalten lassen.
Bei Dateisystemen mit einer Blockgröße von einem Kilobyte muss dagegen ab einer Dateigröße von 64 MB von einem dreifach indirekten Block Gebrauch gemacht werden (Bild 3).
Zum Glück sind zum Laden eines solchen Datenblockes aber keine vier Plattenzugriffe notwendig, denn alle UNIX-Versionen haben einen Plattencache, der häufig benötigte Daten im RAM präsent hält.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/filestructure.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 3: Von der I-Node zu den Datenblöcken einer Datei&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Bei der Belegung von Plattenblöcken für eine Datei ist UNIX sehr effizient.
Nur diejenigen Blöcke einer Datei, die schon einmal beschrieben wurden, belegen auch wirklich Platz auf der Platte.
Wird beispielsweise begonnen, einen doppelt indirekten Block zu verwenden, so wird für diesen zunächst der erste einfach indirekte Block beschafft und belegt.
Die Blocknummern der anderen indirekten Blöcke werden dagegen einfach auf Null gesetzt.&lt;/p&gt;
&lt;p&gt;Das führt zu interessanten Effekten bei Dateien, die nicht durchgehend beschrieben werden:
Legt man unter UNIX eine neue Datei an und bewegt dann den Dateizeiger irgendwo in die oberen Megabytes, um dort ein einziges Byte zu beschreiben, dann wird nur der eine Datenblock belegt, der notwendig ist, um dieses Byte zu speichern (plus der möglicherweise notwendigen indirekten Blöcke, die notwendig sind, um den Block zu erreichen).
Die Blocknummer aller anderen nicht verwendeten Blöcke bleiben auf Null stehen und es werden auch keine Datenblöcke zwischen dem gespeicherten Byte und dem Dateianfang angefordert.
Es entsteht eine Datei, die in der Verzeichnisausgabe viele Megabytes groß erscheint, in Wirklichkeit aber nur wenige Kilobytes belegt.
Eine solche Datei nennt man in UNIX eine dünn besetzte Datei (sparse file).
Beim Lesen einer solchen Datei werden für die nicht vorhandenen Blöcke entsprechend viele Nullbytes zurückgemeldet.&lt;/p&gt;
&lt;p&gt;Das kann beim Kopieren oder Sichern solcher Dateien natürlich zu seltsamen Effekten führen, wenn man nicht aufpasst:
Beim naiven Kopieren wird eine Datei von vorne nach hinten durchgelesen und die gelesenen Daten werden in die Zieldatei geschrieben.
Während eine dünn besetzte Quelldatei also möglicherweise nur wenige Blöcke wirklich belegt, wird die Zieldatei von vorne nach hinten beschrieben und belegt dann wirklich so viel Platz, wie im Verzeichnis angegeben.
Dateien, die ein Abbild eines häufig ebenfalls dünn besetzten Prozessadressraumes darstellen, sind oft sparse files:
Die shared libraries in einem Linux-System oder Speicherabzüge von gecrashten Programmen unter SunOS sollten tunlichst nicht naiv kopiert werden.&lt;/p&gt;
&lt;h2 id=&#34;dateinamen&#34;&gt;
    &lt;a href=&#34;#dateinamen&#34;&gt;
	Dateinamen
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Die I-Node enthält gesammelt alle Informationen, die UNIX über eine  Datei hat, mit einer Ausnahme: dem Dateinamen.
Dateinamen speichert UNIX in besonderen Dateien, den Verzeichnissen.
Ein Verzeichnis ist n jeder Hinsicht eine normale Datei mit einer I-Node, Datenblöcken und so weiter.
Verzeichnisdateien werden jedoch nicht von Benutzerprogrammen, sondern ausschließlich vom Betriebssystem verwaltet.
Es unterhält in einem Verzeichnis eine feste Satzstruktur.&lt;/p&gt;
&lt;p&gt;Beim älteren UNIX-Dateisystem ist diese sehr einfach aufgebaut:
Ein Verzeichnis besteht aus Datensätzen zu 16 Byte Länge.
Die ersten 2 Byte enthalten die I-Nodenummer einer Datei, die folgenden 14 Byte nehmen einen Dateinamen auf.
Falls ein Dateiname kürzer als 14 Zeichen ist, wird er einfach mit Nullbytes aufgefüllt.
Bei moderneren UNIX-Systemen ist die Verzeichnisstruktur etwas komplizierter, um 4 Byte lange I-Nodenummern und bis zu 255 Byte lange Dateinamen ohne große Platzverschwendung verwalten zu können, aber im Prinzip handelt es sich immer noch um eine einfache Zuordnung von Name zu I-Nodenummer.&lt;/p&gt;
&lt;p&gt;Es ist in UNIX ohne weiteres möglich, mehr als einen Dateinamen für eine Datei zu vergeben.
Dazu wird einfach mit der Systemfunktion link() in einem weiteren Verzeichnis ein Namenseintrag gemacht, der dieselbe I-Nodenummer hat wie der erste Name der Datei.
Im Feld &lt;code&gt;ino_nlink&lt;/code&gt; einer I-Node wird die Anzahl der Namen einer Datei gezählt.
Beide Namen einer Datei sind gleichberechtigt und nicht voneinander zu unterscheiden:
Man kann nicht sagen, welcher von zwei Namen einer Datei der erste und welcher der zweite Name der Datei war.
Anstatt eine Datei zu löschen, kann man in UNIX nur die Anzahl ihrer Namen um Eins vermindern.
Sobald die Anzahl der Namen einer Datei Null wird, gibt das Betriebssystem dem Plattenplatz frei, der zu einer Datei gehört.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/verzeichnis.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;


&lt;em&gt;Bild 4: Das alte System V UNIX Dateisystem behandelt Verzeichnisse als gewöhnliche Dateien mit einer festen Satzstruktur von 16 Byte. Die ersten beiden Byte enthalten die I-Node Nummer einer Datei, die folgenden 14 Bytes stellen den Namen der Datei (mit Nullbytes aufgefüllt) dar.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Im BSD Dateisystem sind längere Dateinamen erlaubt. Um die Platzverschwendung zu minimieren, ist die Struktur eines Verzeichnisses etwas komplizierter, aber das Prinzip der Zuordnung eines Namens zu einer
I-Nodenummer wird nicht verletzt.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Um eine Datei zu öffnen, muß ihr Name in eine I-Nodenummer übersetzt werden.
Nach dem Öffnen der Datei arbeitet das Betriebssystem dann intern ausschließlich mit der I-Nodenummer weiter.
Die Übersetzung von Namen in Nodenummern wird in UNIX an einer zentralen Stelle im Betriebssystemkern abgehandelt, in der Kern-internen Funktion &lt;code&gt;namei()&lt;/code&gt;.
Für jeden Prozess verwaltet UNIX in der Prozessstruktur zwei Einträge, in denen die I-Nodenummer des Hauptverzeichnisses und des aktuellen Verzeichnisses dieses Prozesses hinterlegt sind.
Wenn dem Betriebssystem in einem Systemaufruf ein Pfadname übermittelt wird, wird zunächst geprüft, ob es sich um einen absoluten oder relativen Pfadnamen handelt.
Je nachdem, ob der Pfadname mit einem führenden &amp;ldquo;&lt;code&gt;/&lt;/code&gt;&amp;rdquo; beginnt, wird entweder im Hauptverzeichnis oder im aktuellen Verzeichnis des Prozesses begonnen, den Pfadnamen aufzulösen.
&lt;code&gt;namei()&lt;/code&gt; isoliert dazu die erste Komponente des Pfadnamens und sucht diese im Startverzeichnis der Suche.
Sobald der gesuchte Namenseintrag dort gefunden ist, kann die zugehörige I-Nodenummer abgelesen werden und das nächste Stück des Pfadnamens aufgelöst werden.&lt;/p&gt;
&lt;p&gt;In Bild 5 ist zu sehen, was bei der Auflösung eines Pfadnamens wie &amp;ldquo;&lt;code&gt;/bin/ls&lt;/code&gt;&amp;rdquo; passiert:
Weil der Pfadname mit einem &amp;ldquo;&lt;code&gt;/&lt;/code&gt;&amp;rdquo; beginnt, durchsucht &lt;code&gt;namei()&lt;/code&gt; das Hauptverzeichnis des Prozesses, der den Systemaufruf getätigt hat, nach einem Eintrag für &amp;ldquo;&lt;code&gt;bin&lt;/code&gt;&amp;rdquo;.
Sobald die I-Nodenummer für das &amp;ldquo;&lt;code&gt;bin&lt;/code&gt;&amp;quot;-Verzeichnis gefunden ist, kann es nach einem Eintrag für &amp;ldquo;&lt;code&gt;ls&lt;/code&gt;&amp;rdquo; durchsucht werden.
Erst wenn die I-Nodenummer von &amp;ldquo;&lt;code&gt;ls&lt;/code&gt;&amp;rdquo; bekannt ist, kann die Datei geöffnet oder geladen werden.
Bei der Auflösung von Pfadnamen ergibt sich also eine wechselseitige Verkettung von Datenblöcken und I-Nodes: I-Nodes enthalten Zeiger auf Datenblöcke und die Datenblöcke eines Verzeichnisses enthalten Zeiger auf I-Nodes.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/nameiresolver.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 5: Zugriffe beim Auflösen eines Pfadnamens&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;zugriffsrechte&#34;&gt;
    &lt;a href=&#34;#zugriffsrechte&#34;&gt;
	Zugriffsrechte
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In der I-Node existiert ein Feld &lt;code&gt;ino_mode&lt;/code&gt;.
Es enthält neben anderen Informationen 9 Bits, die die Zugriffsrechte auf die Datei festlegen.
UNIX unterscheidet an jedem Objekt im Dateisystem 3 Rechte: r-Recht bestimmt, ob eine Datei zu Lesen geöffnet werden darf, w-Recht bestimmt, ob eine Datei beschrieben werden darf und x-Recht bestimmt, ob eine Datei ausgeführt werden kann.
Diese Rechte rwx sind jeweils einmal für den Eigentümer der Datei, für Angehörige seiner Benutzergruppe und für den Rest der Welt vorhanden, sodass sich insgesamt 9 Rechte-Bits ergeben.&lt;/p&gt;
&lt;p&gt;Da Verzeichnisse auch Dateien sind, haben auch sie diese Zugriffsrechte.
In Zusammenhang mit Verzeichnissen werden sie jedoch etwas anders interpretiert: r-Recht an einem Verzeichnis erlaubt einem Benutzer, die Namensliste eines Verzeichnisses zu lesen.
w-Recht an einem Verzeichnis gestattet es ihm, Dateien anzulegen oder zu löschen.
x-Recht schließlich ist notwendig, um auf die Dateien in einem Verzeichnis zuzugreifen. In Bild 5 ist zu sehen, an welchen Stellen welche Zugriffsrechte geprüft werden, wenn die Datei &amp;ldquo;&lt;code&gt;/bin/ls&lt;/code&gt;&amp;rdquo; zum Lesen geöffnet werden soll:
Zunächst einmal muss am Hauptverzeichnis x-Recht vorhanden sein, damit auf die Datei &amp;ldquo;&lt;code&gt;bin&lt;/code&gt;&amp;rdquo; zugegriffen werden kann, die im Hauptverzeichnis enthalten ist.
Danach wird auf ein x-Recht am &amp;ldquo;&lt;code&gt;bin&lt;/code&gt;&amp;quot;-Verzeichnis geprüft, um auf die Datei &amp;ldquo;&lt;code&gt;ls&lt;/code&gt;&amp;rdquo; zugreifen zu können.
Und schließlich muss an der Datei &amp;ldquo;&lt;code&gt;ls&lt;/code&gt;&amp;rdquo; selbst noch r-Recht vorhanden sein, damit auf die Datenblöcke der Datei lesen zugegriffen werden darf.&lt;/p&gt;
&lt;p&gt;x-Recht an einem Verzeichnis ist also immer dann erforderlich, wenn &lt;code&gt;namei()&lt;/code&gt; einem Zeiger aus diesem Verzeichnis in die I-Nodetabelle folgen muss.
In Bild 5 sind diese aufwärts führenden Pfeile etwas  dicker hervorgehoben.&lt;/p&gt;
&lt;h2 id=&#34;fragmente&#34;&gt;
    &lt;a href=&#34;#fragmente&#34;&gt;
	Fragmente
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Dateisysteme verwalten den Plattenplatz in Form von Blöcken fester Größe.
Deswegen ist am Ende der meisten Dateien ein Block vorhanden, der nicht ganz ausgenutzt werden kann, denn bei den meisten Dateien ist die Dateilänge nicht genau ein Vielfaches der Blockgröße des Dateisystems.
So geht, abhängig von der mittleren Dateigröße und der Blockgröße des Dateisystems ein mehr oder weniger großer Anteil des Plattenplatzes verloren.
Je kleiner die Verwaltungseinheiten des Dateisystems sind, umso effektiver kann es seinen Platz verwalten.
Andererseits ist der Datendurchsatz eines Dateisystems um so größer, je größer die Blöcke sind, die es verwaltet.
Und schließlich kann man bei der Verwendung von großen Datenblöcken oft mehrfach indirekte Blöcke einsparen und macht das Dateisystem auf diese Weise schneller und reduziert den Verwaltungsaufwand.
In modernen UNIX-Dateisystem löst man dieses Dilemma, indem man ein Dateisystem mit einer relativ großen Blockgröße (meistens 8 Kilobyte) anlegt, Dateienden aber in speziellen Blöcken, den Fragmenten, speichert.
Fragmente werden erzeugt, in dem man einen normalen Plattenblock in mehrere gleichgrosse Teilblöcke unterteilt, die jeweils das Dateiende einer anderen Datei aufnehmen können.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/bsdfragment.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 6: Zwei Dateienden in einem fragmentierten Block&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Auf diese Weise werden die Dateienden verschiedener Dateien praktisch in einem Block zusammen komprimiert und der Verlust an Plattenplatz durch nicht ausgenutzte Blöcke wird reduziert.
Trotzdem kann das Dateisystem die meiste Zeit mit vollständigen, großen Blöcken arbeiten und so hohe Geschwindigkeiten erreichen.
Der Nachteil dieses Systems ist, daß ein Dateiende unter Umständen mehrfach umkopiert werden muss, wenn eine Datei wächst:
Zunächst passt das Dateiende noch in sein Fragment hinein, wenn es wächst, muss jedoch ein größeres Fragment gesucht werden, das jedoch durch weitere Schreiboperationen sofort wieder überläuft, bis die Datei endlich den nächsten vollständigen Block füllt.
Solche Kopieroperationen lassen sich vermeiden, wenn Anwendungsprogramme ihre Schreiboperationen der Blockgröße des Dateisystems anpassen.
Da so etwas sehr unbequem ist, wenn man es selber programmieren muss, nimmt die C-Standardbibliothek in einem UNIX-System einem diese Arbeit ab:
Sie fragt die Blockgröße des unterliegenden Dateisystems ab und stimmt ihre Schreibzugriffe so ab, daß mit maximaler Geschwindigkeit geschrieben werden kann.&lt;/p&gt;
&lt;p&gt;Weitere Geschwindigkeitsvorteile lassen sich erzielen, wenn man dafür sorgen kann, daß Dateien möglichst hintereinanderliegende Blöcke auf einer Platte belegen.
Die Platte kann in diesem Fall ihren internen Cache füllen und die Daten schneller abliefern.
Außerdem entfallen Bewegungen des Schreib-/Lesekopfes der Platte.
Wie man am Beispiel von DOS sehen kann, ist es leider ist es nicht damit getan, die Blöcke einer Datei hintereinander anzuordnen.
Man muss außerdem auch Platz lassen, damit Dateien wachsen können.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/fragmentierung.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 7: Durch unkluge Anordnung von Daten zerstückelt MS-DOS Dateien in kleine, nicht zusammenhängende Fragmente.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Moderne UNIX-Dateisysteme unterteilen eine Festplatte deswegen in Streifen von einigen Megabyte Größe, sogenannte cylinder groups.
Jeder dieser Streifen enthält eine eigene kleine I-Nodetabelle und seinen Anteil an Datenblöcken.
Neue Dateien werden in derjenigen Zylindergruppe angelegt, die im Verhältnis am meisten freie Datenblöcke aufzuweisen hat.
Dadurch wird sichergestellt, daß solche Dateien gerade nicht direkt hintereinanderliegen, sondern genügend freien Platz haben, um zu wachsen.
Bei sehr langen Dateien wird außerdem nach dem Schreiben von jeweils einem Megabyte an Daten ein Wechsel der Zylindergruppe erzwungen:
Man geht davon aus, daß man sehr lange Dateien sowieso nicht in einem Stück zusammenhängend lagern kann.
Stattdessen versucht man, die einzelnen Stücke möglichst groß zu machen.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/bsdlayout.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 8: Das BSD Fast Filing System unterteilt die Platte in Streifen von einigen MB Größe. Das Betriebssystem versucht durch verschiedene Verfahren,
das Verhältnis von belegten Datenblöcken zu belegten I-Nodes in allen cylinder groups einer Platte in etwa ausgewogen zu halten. Dadurch ist das Dateisystem effektiv selbstdefragmentierend.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Außerdem würde eine sehr lange Datei alle Datenblöcke, aber nur eine einzige I-Node in einer Zylindergruppe belegen.
Die Daten zu den I-Nodes aller weiteren Dateien in derselben Zylindergruppe müssten dann auf andere Zylindergruppen verlagert werden, was dort wiederum das ausgewogene Verhältnis zwischen freien I-Nodes und freien Datenblöcken stören würde.
Dadurch, daß man  jeweils ein Megabyte einer sehr großen Datei auf eine andere Zylindergruppe verlagert, wird der Platz auf der Platte gleichmäßig verbraucht.
Man verhindert, daß andere Dateien dann nicht mehr günstig auf der Platte angeordnet werden können.&lt;/p&gt;
&lt;h2 id=&#34;abgeleitete-dateisysteme&#34;&gt;
    &lt;a href=&#34;#abgeleitete-dateisysteme&#34;&gt;
	Abgeleitete Dateisysteme
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Die grundlegenden Strukturen des UNIX-Dateisystems wurden von Ritchie und Thompson vor 20 Jahren in den Laboratorien von AT&amp;amp;T entwickelt und haben sich grundsätzlich bewährt.
Selbst das Entwicklerteam von BSD UNIX, das das Dateisystem vor 10 Jahren einer gründlichen Überarbeitung unterzogen hat, hat die zugrundeliegenden Ideen nicht verändert, sondern UNIX lediglich beigebracht, auf die Geometrie der Platte Rücksicht zu nehmen, um weitere Geschwindigkeitsgewinne zu erzielen.&lt;/p&gt;
&lt;p&gt;Das UNIX-Dateisystem ist dem nur halb so alten, aber wesentlich weniger effektiv organisierten MS-DOS Dateisystem in Sachen Geschwindigkeit, Zugriffsschutz und Benutzerfreundlichkeit weit überlegen.
Die Ideen der UNIX-Entwickler waren letztlich so überzeugend, daß sie sich letztendlich im OS/2 HPFS und schließlich auch im Dateisystem von Windows NT wiederfinden.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/mount.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 9: 26 Laufwerksbuchstaben wären für eine gut ausgelastete Workstation viel zu wenig. UNIX kennt deswegen nur einen einzigen Dateibaum. Beim Anmelden (mounten) eines Dateisystems wird eine Platte an einer
bestimmten Stelle in den Verzeichnisbaum eingehängt. Beim Wechsel des Verzeichnisses wechselt man so auch gleich die Platte oder bei Netzwerkplatten sogar den Rechner, auf dem man aktiv ist.&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&#34;literatur&#34;&gt;
    &lt;a href=&#34;#literatur&#34;&gt;
	Literatur
    &lt;/a&gt;
&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;The UNIX Time Sharing System&amp;rdquo;, Ritchie, Thompson, Communications of the ACM 7/74, p.365&lt;/li&gt;
&lt;li&gt;&amp;ldquo;A Fast File System for UNIX&amp;rdquo;, McKusick et. al, ACM Trans. on Computer Systems, August 84, p.181&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Operating Systems&amp;rdquo;, A. Tanenbaum, Prentice-Hall&lt;/li&gt;
&lt;li&gt;&amp;ldquo;The Design of the UNIX Operating System&amp;rdquo;, M.Bach, Prentice-Hall&lt;/li&gt;
&lt;li&gt;&amp;ldquo;The Design of the 4.3 BSD UNIX Operating System&amp;rdquo;, McKusick, Addison-Wesley&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Advanced Programming in the UNIX Environment&amp;rdquo;, W.R.Stevens, Addison-Wesley&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TCP/IP Technik</title>
      <link>https://blog.koehntopp.info/1993/04/01/tcpip-technik.html</link>
      <pubDate>Thu, 01 Apr 1993 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/1993/04/01/tcpip-technik.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#tcpip-technik&#34;&gt;TCP/IP Technik&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#smtp&#34;&gt;Ein SMTP Dialog&lt;/a&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;aus »c&amp;rsquo;t - Magazin für Computertechnik«, Ausgabe 4/93&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;tcpip-technik&#34;&gt;
    &lt;a href=&#34;#tcpip-technik&#34;&gt;
	TCP/IP Technik
    &lt;/a&gt;
&lt;/h1&gt;
&lt;h4 id=&#34;rechner-miteinander-zu-vernetzen-ist-heutzutage-kein-problem-mehr-so-scheint-es-um-die-rechner-im-büro-zu-verbinden-nimmt-man-ethernet-arcnet-oder-token-ring-für-die-anbindung-von-außenstellen-stehen-modems-datx-p-und-neuerdings-auch-isdn-zur-verfügung-und-um-mal-eben-einige-daten-von-seinem-mac-auf-den-atari-zu-überspielen-legt-man-ein-nullmodemkabel-alle-diese-netze-haben-ihre-stärken-und-schwächen-und-dementsprechend-ihre-einsatzgebiete&#34;&gt;
    &lt;a href=&#34;#rechner-miteinander-zu-vernetzen-ist-heutzutage-kein-problem-mehr-so-scheint-es-um-die-rechner-im-b%c3%bcro-zu-verbinden-nimmt-man-ethernet-arcnet-oder-token-ring-f%c3%bcr-die-anbindung-von-au%c3%9fenstellen-stehen-modems-datx-p-und-neuerdings-auch-isdn-zur-verf%c3%bcgung-und-um-mal-eben-einige-daten-von-seinem-mac-auf-den-atari-zu-%c3%bcberspielen-legt-man-ein-nullmodemkabel-alle-diese-netze-haben-ihre-st%c3%a4rken-und-schw%c3%a4chen-und-dementsprechend-ihre-einsatzgebiete&#34;&gt;
	Rechner miteinander zu vernetzen ist heutzutage kein Problem mehr, so scheint es. Um die Rechner im Büro zu verbinden, nimmt man Ethernet, ARCNET oder Token-Ring; für die Anbindung von Außenstellen stehen Modems, Datx-P und neuerdings auch ISDN zur Verfügung und um mal eben einige Daten von seinem Mac auf den Atari zu überspielen, legt man ein Nullmodemkabel. Alle diese Netze haben ihre Stärken und Schwächen und dementsprechend ihre Einsatzgebiete.
    &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;Leider haben diese Netze aber auch alle eine unterschiedliche Schnittstelle der Anwendung gegenüber.
Das fängt schon bei den Adressen an (Datex-P Adressen sehen anders aus als Adressen in einem Ethernet) und hört erst wieder bei den grundlegenden Konzepten des jeweiligen Netzwerks auf.
Wie schön wäre es, würden alle diese Netzwerke zusammenarbeiten können, sodaß man Daten auf dieselbe Art und Weise vom Wohnzimmer in den Hobbykeller wie von einem Ende der Welt zum anderen verschicken könnte, wenn man die verschiedenen Netzwerke miteinander vernetzen könnte.&lt;/p&gt;
&lt;p&gt;Genau diese Anforderung erfüllen die TCP/IP-Protokolle, die im Internet verwendet werden.&lt;/p&gt;
&lt;p&gt;Was kann TCP/IP?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gibt einem Unabhängigkeit von Hardware des unterliegenden Trägernetzes.&lt;/li&gt;
&lt;li&gt;gibt einem netzwerkweit einheitliche Adressen.&lt;/li&gt;
&lt;li&gt;präsentiert dem Programmierer eine einheitliche, geschlossene API.&lt;/li&gt;
&lt;li&gt;bietet einen Baukasten von standardisierten High-Level-Protokollen für die verschiedensten Netzwerkdienste.&lt;/li&gt;
&lt;li&gt;ist eine offene Protokollfamilie, die unabhängig von Herstellern entwickelt wurde.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Um die Entwicklung und das Verständnis von Rechnernetzen zu erleichtern, hat die International Standards Organisation (ISO) ein Architekturmodell für Rechnernetze entwickelt, das OSI
Referenzmodell.
Dieses Modell teilt den Prozeß des Verschickens von Daten über ein Rechnernetz in 7 übereinanderliegende Schichten ein, die einander zuarbeiten und jede für sich eine bestimmte Abstraktionsebene kennzeichnen.
Weil diese Schichten in der Abbildung einen übereinander liegen, redet man oft auch von einem
Protokollstapel.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/osimodell.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 1: OSI Referenzmodell&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Wenn Daten zwischen zwei Rechnern übertragen werden, erscheint es im Programmiermodell so, als würden zwei gleiche Schichten auf verschiedenen Rechnern miteinander kommunizieren.
Die Details der darunterliegenden Abstraktionsebenen werden vor den darüberliegenden Schichten verborgen.
Beispielsweise ist es die Aufgabe der Schicht 2, eine fehlerfreie Verbindung zwischen zwei benachbarten Netzknoten zur Verfügung zu stellen.
Das bedeutet, dass die Schicht 3 sich mit den Details der Datenübertragung zwischen zwei Maschinen nicht mehr zu befassen hat.
Sie kann mit der Schicht 3 der Gegenstelle kommunizieren, ohne sich um Einzelheiten der Datenübertragung und möglicherweise auftretende Fehler kümmern zu müssen.&lt;/p&gt;
&lt;p&gt;In Wirklichkeit besteht jedoch die einzige Verbindung zwischen zwei Rechnern auf der Ebene 1, der physikalischen Schicht.
Wenn Daten zu senden sind, werden sie von einer Schicht zur jeweils darunterliegenden Schicht weitergereicht.
Damit die einzelnen Schichten voneinander unabhängig sind müssen die Schnittstellen zwischen den Schichten natürlich bekannt und definiert sein.
Diese Art von Modulbildung erleichtert die Wartung und Entwicklung von neuen Netzwerkprotokollen und die Fehlersuche.&lt;/p&gt;
&lt;h2 id=&#34;internetworking-protocol-ip&#34;&gt;
    &lt;a href=&#34;#internetworking-protocol-ip&#34;&gt;
	Internetworking Protocol (IP)
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Auch TCP/IP hat einen ähnlichen, schichtweisen Aufbau, wenn es auch nicht so vielfach unterteilt ist wie das OSI-Modell;
üblicherweise unterscheidet man vier Schichten.
Die Grundlage des TCP/IP-Protokollturms bildet die Netzwerkschicht, deren Aufgabe der eigentliche Datentransport ist.&lt;/p&gt;
&lt;p&gt;TCP/IP ist kein Netzwerkprotokoll, das von der Hardware direkt verstanden wird.
Normalerweise werden TCP/IP-Daten immer über ein vorhandenes Trägernetz, etwa Ethernet oder X.25, übertragen, denn die Aufgabe von TCP/IP ist es ja gerade, solche vorhandenen Netzwerke zu vereinheitlichen.
Im OSI-Modell deckt die Netzwerkschicht also die Hardwareschichten 1 und 2 sowie in einigen Fällen auch noch Teile der Schicht 3 ab.
Auf der Netzwerkschicht aufbauend liegt die Internet-Schicht, die die erste Abstraktionsschicht von einem konkreten Netzwerk darstellt.
Damit ist das Internet-Protokoll, kurz IP, der Kern von TCP/IP, denn es stellt den grundlegenden Dienst des Netzes zur Verfügung:
den Versand von Datenpaketen, sogenannten Datagrammen, über verschiedene Netze hinweg.
Die Netzwerkschicht hat keine Information darüber, von welcher Art die Daten sind, die sie befördert:
Für eine Ethernetkarte sind die ankommenden Daten eben einfach nur Daten, die vom Netz kommen.
Der Kartentreiber interpretiert einen Teil dieser Daten als IP-Header und den Rest als Datenteil eines IP-Paketes.
Auf diese Weise ist der IP-Header innerhalb eines Ethernet-Paketes gewissermaßen eingekapselt.
Aber auch das IP-Paket selbst enthält selbst wieder ein Datenpaket für eine höhere Protokollebene, dessen Header auf der IP-Ebene als Bestandteil der Daten erscheint.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/datenkapselung.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 2: Kapselung von Daten in ein Protokollpaket der nächstniederen Schicht.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;IP ist ein verbindungsloses Protokoll, das bedeutet, IP kennt keinen Verbindungszustand.
Es ist also nicht notwendig, eine IP-Verbindung zu einem Rechner zu &amp;ldquo;öffnen&amp;rdquo;, bevor man Daten zu diesem Rechner senden kann, sondern es genügt, das IP-Paket einfach abzusenden.
Bei einem verbindungsorientierten Protokoll wird beim Öffnen einer Verbindung getestet, ob der Zielrechner überhaupt erreichbar ist.
Ein verbindungsloses Protokoll macht das nicht und kann demnach auch nicht garantieren, daß ein Datenpaket überhaupt beim Empfänger ankommt.
IP garantiert auch nicht, daß ein von einem einmal abgeschickten Datenpaket nur eine Kopie beim Empfänger ankommt oder daß in einer Reihenfolge abgeschickte Datenpakete auch wieder in dieser Reihenfolge empfangen werden.
Dadurch ist es möglich, daß längere Transfers von einem Rechner zum anderen, die über mehrere Zwischenrechner laufen, beim Ausfall eines dieser Rechner dynamisch neu konfiguriert werden.
Irgendwann während der Übertragung bricht ein Übertragungsweg zusammen und es wird ein neuer Weg zum Ziel gesucht und benutzt.
Da der neue Weg zeitlich länger oder kürzer sein kann als der alte, kann man keine allgemein gültigen Aussagen darüber machen, in welcher Reihenfolge IP-Pakete beim Empfänger eintreffen.
Es kann auch sein, daß bei dieser Umschalterei IP-Pakete verloren gehen oder verdoppelt werden.
Alle diese Unebenheiten auszubügeln überläßt IP anderen, höherliegenden Schichten im Protokollturm.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/ippaket.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 3: Aufbau eines Internet Protocol (IP) Headers. Eine Zeile stellt ein Langwort (4 Byte) dar. Das höchstwertigste Byte eines Langwortes wird als erstes übertragen (Network Byte Order).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Die Hauptaufgabe von IP ist es also, die Unterschiede zwischen den verschiedenen, unterliegenden Netzwerkschichten zu verbergen und eine einheitliche Sicht auf die verschiedensten Netzwerktechnologien zu präsentieren.
Dazu gehören die Einführung eines einheitlichen Adressierungsschemas und eines Fragmentierungsmechanismus, der es ermöglicht, große Datenpakete durch Netze mit kleiner maximaler Paketgröße zu senden.&lt;/p&gt;
&lt;p&gt;Jedes IP-Paket enthält zwei Adressen in Form von 32 Bit Worten:
Die Absender- und die Empfängeradresse.
Eine Internet-Adresse wird meist in Form von vier, durch Punkte getrennten Bytes notiert, man spricht in diesem Fall von der &amp;ldquo;dotted quad&amp;rdquo;-Schreibweise.
Um die Zustellung von IP-Paketen zu vereinfachen, unterteilt man die Adresse in zwei Teile:
Den Netzwerkteil und den Rechnerteil.
Ein Router muß, um ein Datenpaket zustellen zu können, nur den Netzwerkteil einer Adresse erkennen.
Erst im Zielnetzwerk wird der Rechnerteil einer Adresse ausgewertet.
Um den verschiedenen Anforderungen gerecht zu werden, was die Größe von Netzwerken angeht, unterscheidet man verschiedene Aufteilungen der 32 Adreßbits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bei Netzwerken der Klasse A ist das erste Bit der IP-Adresse 0.
Die folgenden 7 Bit bilden den Netzwerkteil der Adresse und die restlichen 24 Bits bilden den Rechnerteil.
Es kann also weniger als 128 verschiedene Klasse A Netzwerke geben, aber jedes dieser Netze aus Millionen von Rechnern bestehen.
Ein typischer Verteter ist zum Beispiel das amerikanische MILNET, das sich über das ganze Land
erstreckt.&lt;/li&gt;
&lt;li&gt;bei Netzwerken der Klasse B fängt die Adresse mit der Bitfolge &amp;ldquo;10&amp;rdquo; an.
Die folgenden 14 Bit stellen den Netzwerkteil der Adresse dar, die restlichen 16 Bit den Rechnerteil.
Es kann also Tausende von Klasse B Netzen mit jeweils tausenden von Rechnern geben.
Ein typischer Vertreter ist das Campusnetzwerk einer großen Universität.&lt;/li&gt;
&lt;li&gt;bei Netzwerken der Klasse C fängt die Adresse mit der Bitfolge &amp;ldquo;110&amp;rdquo; an.
Die folgenden 21 Bit stellen den Netzwerkteil der Adresse dar, die restlichen 8 Bit den Rechnerteil.
Es kann also Millionen von Netzwerken der Klasse C geben, von denen jedes weniger als 256 Rechner beherbergt. Standardmäßigt bekommt man ein Klasse C Netz, wenn man ein Netzwerk beim NIC anmeldet.&lt;/li&gt;
&lt;li&gt;fängt eine Adresse mit den Bits &amp;ldquo;111&amp;rdquo; an, so hat sie eine Spezialbedeutung.
Manchmal werden solche Adressen als Klasse D Adressen bezeichnet.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Höherliegende Protokolle und Dienste bieten dem IP-Benutzer Mechanismen, die Namen Internet-Adressen zuordnen und umgekehrt.&lt;/p&gt;
&lt;p&gt;Weil das Internet-Protokoll wie bereits erwähnt normalerweise immer auf einem Trägernetzwerk aufsetzt, muß es noch eine andere Eigenschaft der unterliegenden Netzwerkschicht verbergen:
Normalerweise existiert bei allen Netzwerken eine maximale Größe, die ein Datenpaket haben kann.
Im IP-Jargon nennt man diese Grenze die &amp;ldquo;maximum transmisson unit&amp;rdquo;, MTU.
Natürlich ist diese Obergrenze je nach verwendeter Trägertechnik unterschiedlich.
Die Internet-Schicht teilt IP-Pakete, die größer als die MTU des verwendeten Netzwerks in kleinere Stücke, sogenannte Fragmente auf.
Auf dem Zielrechner werden diese Fragmente dann wieder zu vollständigen IP-Paketen zusammengesetzt, bevor sie an die darüberliegenden Protokolle weiter gegeben werden.&lt;/p&gt;
&lt;p&gt;Welches darüberliegende Protokoll der Transportschicht das Datenpaket bekommt, steht im &amp;ldquo;Protokoll&amp;rdquo;-Feld eines jeden IP-Paketes.
Jedes Protokoll der Transportschicht bekommt eine eindeutige Identifikationsnummer zugewiesen, anhand derer der IP-Treiber entscheiden kann, wie weiter mit dem Paket zu verfahren ist.
Eines der wichtigsten Protokolle der Transportschicht ist TCP.&lt;/p&gt;
&lt;h2 id=&#34;was-leistet-tcp&#34;&gt;
    &lt;a href=&#34;#was-leistet-tcp&#34;&gt;
	Was leistet TCP?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Die Aufgabe von TCP ist es, die oben geschilderten Defizite von IP zu verbergen.
Für den TCP-Benutzer soll es nicht mehr sichtbar sein, daß die darunterliegenden Protokollschichten Datenpakete versenden, sondern stattdessen soll der Benutzer mit einem Bytestrom wie bei einer normalen Datei arbeiten können.
TCP garantiert das Ankommen, die Einmaligkeit und die Reihenfolge der Daten.
Zusätzlich multiplext TCP die Verbindung zwischen zwei Rechnern:
Während auf der Internet-Schicht nur eine Verbindung zur Zeit zwischen zwei Rechnern bestehen kann, teilt TCP diese Verbindung in viele virtuelle Kanäle auf.&lt;/p&gt;
&lt;p&gt;Im Gegensatz zu IP ist TCP verbindungsorientiert.
Das muß so sein, denn TCP-Verbindungen sollen ja für den Benutzer wie Dateien zu handhaben sein.
Das bedeutet, eine TCP-Verbindung wird wie eine Datei geöffnet und geschlossen und man kann seine Position innerhalb des Datenstromes bestimmen, genau wie man bei einer Datei die Position des Dateizeigers angeben kann.&lt;/p&gt;
&lt;p&gt;Auch TCP sendet die Daten in größeren Einheiten, um den Verwaltungsaufwand durch Header und Kontrollinformation klein zu halten.
Im Gegensatz zu den IP-&amp;ldquo;Paketen&amp;rdquo; bezeichnet man in die Einheiten der Transportschicht als &amp;ldquo;Segmente&amp;rdquo;.
Jedes gesendete TCP-Segment hat eine eindeutige Folgenummer, die die Position seines ersten Bytes im Bytestrom der Verbindung angibt.
Anhand dieser Nummer kann die Reihenfolge der Segmente korrigiert werden und doppelt angekommene  Segmente können aussortiert werden.
Da die Länge des Segmentes aus dem IP-Header bekannt ist, können auch Lücken im Datenstrom entdeckt werden und der Empfänger kann verlorengegangene Segmente neu anfordern.&lt;/p&gt;
&lt;p&gt;Beim Öffnen einer TCP-Verbindung werden zwischen beiden Kommunikationspartnern Kontrollinformationen ausgetauscht, die sicherstellen, daß der Endpunkt der Verbindung existiert
und Daten annehmen kann.
Dazu schickt der Sender ein Segment mit der Aufforderung, die Folgenummern zu synchronisieren.
Der Empfänger weiß jetzt, daß der Sender eine Verbindung öffnen möchte und an welcher Position im Datenstrom der Sender anfangen wird zu zählen.
Der Empfänger bestätigt den Empfang der Nachricht und legt seinerseits eine Folgenummer für Übertragungen in Gegenrichtung fest.
Der Sender bestätigt nun seinerseits den Empfang der Folgenummer von B und beginnt dann mit der Übertragung von Daten.
Diese Art des Austausches von Kontrollinformation, bei der jede Seite die Aktionen der Gegenseite bestätigen muß, ehe sie wirksam werden können, heisst &amp;ldquo;Dreiweg-Handshake&amp;rdquo;.
Auch beim Abbau einer Verbindung wird auf diese Weise sichergestellt, daß beide Seiten alle Daten korrekt und vollständig empfangen haben.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/tcppaket.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;Bild 4: Aufbau eines Transmission Control Protocol (TCP) Headers.*&lt;/p&gt;
&lt;p&gt;Während der Übertragung kann der Empfänger dem Sender im Feld &amp;ldquo;Fenstergröße&amp;rdquo; signalisieren, für wieviele Bytes er noch Pufferkapazität frei hat.
Der Sender darf nicht mehr Daten senden, als der Empfänger auf diese Weise freigegeben hat, bis er eine weitere Empfangsbestätigung mit einer neu festgelegten Fenstergröße vom Sender erhält.
Auf diese Weise kann der Empfänger den Datenfluß vom Sender nach Wunsch dosieren.
Wenn der Empfänger dem Sender eine Fenstergröße von Null Byte signalisiert, muß der Sender den Transfer unterbrechen, bis er eine zweite Bestätigung mit einer Fenstergröße ungleich Null bekommt.&lt;/p&gt;
&lt;p&gt;Auf einem Rechner können mehrere Prozesse zu einem Zeitpunkt TCP-Verbindungen geöffnet haben.
Die Portnummer in jedem TCP-Segment gibt an, welche virtuelle Verbindung zu welchem Prozeß gehört.
So ist es möglich, Leitungen für eine Vielzahl von Prozessen zu multiplexen.
Vom Standpunkt eines Modembenutzers aus kann man TCP/IP also in gewisser Weise als eine Art glorifiziertes ZMODEM- oder BIMODEM-Protokoll betrachten:
Es ist nicht nur eine Übertragung von Daten in beide Richtungen gleichzeitig möglich, sondern es können pro Richtung noch mehrere Verbindungen zugleich unterhalten werden.&lt;/p&gt;
&lt;p&gt;Damit die verschiedenen Schichten des Protokollturms miteinander Daten austauschen können, müssen jeweils zwei aneinanderstoßende Schichten sich jeweils über ein gemeinsames Interface einig sein.
Normalerweise sind diese Interfaces nicht interessant, weil sie für den Anwender unsichtbar sind.
Das Interface der Internet-Schicht ist zum Beispiel nur für denjenigen interessant, der TCP oder ein vergleichbares Protokoll selbst implementieren möchte.
Das Interface zwischen der Transportschicht und der Anwendungsschicht ist jedoch von besonderem Interesse, denn es stellt das Interface dar, mit dem ein Programmierer umgehen muß, der eine Anwendung schreiben möchte, die von den Möglichkeiten von TCP/IP Gebrauch macht.&lt;/p&gt;
&lt;p&gt;Leider gibt es zwei verschiedene, inkompatible APIs für TCP/IP.
Die ältere der beiden ist als &amp;ldquo;Berkeley Sockets&amp;rdquo; bekannt geworden und in BSD UNIX zusammen mit der ersten Version von TCP/IP implementiert worden.
Die andere API ist das &amp;ldquo;Transport Level Interface&amp;rdquo;, kurz TLI, von AT&amp;amp;T.
Es stellt den Versuch dar, eine generelle, TCP/IP unabhängige API für Netzwerkprogrammierung zu schaffen.
Die Namen und Parameter der TLI-Aufrufe orientieren sich dabei an der Begriffswelt der OSI.&lt;/p&gt;
&lt;p&gt;Die Grenze zwischen der Anwendungsschicht und der Transportschicht ist in den meisten Implementierungen zugleich die Grenze zwischen dem Betriebssystem und den Anwendungsprogrammen.
Im OSI-Modell ist diese Grenze in etwa die Grenze zwischen den Schichten 4 und 5.
Daher ordnet man IP meist ungefähr in die Ebene 3 und TCP ungefähr in Ebene 4 des OSI-Modells ein.
Da TCP/IP jedoch älter und einfacher als das OSI-Modell sind, kann diese Einordnung nicht genau passen.&lt;/p&gt;
&lt;h2 id=&#34;typische-tcpip-dienste&#34;&gt;
    &lt;a href=&#34;#typische-tcpip-dienste&#34;&gt;
	Typische TCP/IP Dienste
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Auf TCP/IP setzen viele verschiedene Dienste auf, von denen die meisten ein eigenes, anwendungsspezifisches Protokoll zwischen ihrem Server und den verschiedenen Client-Programmen verwenden.
Der UNIX-Tradition folgend kommunizieren viele dieser Anwendungen zwar in einem formalisierten Format miteinander, aber dieses Format ist meist so gehalten, daß es noch von einem Menschen ohne besondere Debugging-Werkzeug gelesen und erzeugt werden kann.&lt;/p&gt;
&lt;p&gt;Eines dieser Protokolle ist zum Beispiel das &amp;ldquo;simple mail transport protocol&amp;rdquo;, SMTP.
Es dient der synchronen Auslieferung von Electronic Mail im Internet und wird von einer ganzen Palette von Mailtransportprogrammen direkt verstanden.
Ist eine Mail zu versenden, so baut der sendende Mailer eine TCP/IP-Verbindung direkt zum Zielrechner auf.
Der physikalische Weg zu diesem Rechner muß nicht direkt vorhanden sein, aber das braucht den Absender nicht zu kümmern.
Die Internet-Schicht des Netzes wird einen Weg zum Zielrechner konstruieren, wenn es einen gibt.
Für den Mailer sieht es so aus, als hätte er eine direkte, virtuelle Verbindung zum Zielrechner.
Kommt eine Verbindung zustande, so meldet sich auf dem Zielrechner ein Hintergrundprozeß, der auf eingehende Nachrichten wartet.
Zwischen den beiden Mailern läuft dann ein SMTP-Dialog ab.
Da der Dialog aber in reinem ASCII und sogar relativ lesbar ist, kann man ihn bei Kenntnis des SMTP-Protokolls auch als Mensch simulieren.
Im Kasten &lt;a href=&#34;#smtp&#34;&gt;SMTP&lt;/a&gt;

 ist so eine Simulation eines SMTP-Dialoges zu sehen.&lt;/p&gt;
&lt;p&gt;So wie SMTP der Zustellung persönlicher Nachrichten an einzelne Personen dient, ermöglicht das NNTP-Protokoll die Verbreitung öffentlicher Nachrichten, der USENET News, im Internet.
Das FTP-Protokoll dient zur Übertragung von Dateien durch das Netz, das TELNET- und das rlogin-Protokoll ermöglichen es, Sessions auf entfernten Rechnern zu fahren und wieder andere Protokolle ermöglichen die Einrichtung von Namensverzeichnissen oder die Fernabfrage der eigenen Mail.&lt;/p&gt;
&lt;p&gt;TCP/IP ist durch das schichtweise Design ein modularer Protokollstandard.
Die einzelnen Komponenten sind in den sogenannten &amp;ldquo;Requests for Comments&amp;rdquo; (RFCs) genormt und  offengelegt.
Am Zustandekommen einer einzelnen SMTP-Verbindung über TCP über IP über Ethernet-Verbindung sind dann auch eine ganze Reihe dieser Normen beteiligt.
Das Format der übertragenen Nachricht ist in RFC 822, &amp;ldquo;Standard for the format of ARPA Internet text messages&amp;rdquo; festgelegt.
Die Nachrichten werden nach dem in RFC 821 definierten SMTP-Verfahren übertragen.
SMTP bedient sich wiederum des in RFC 793 spezifizierten TCP, das auf dem in RFC 791 und RFC  792 definierten Internet Protocol aufsetzt.
Wie Internet-Pakete auf einem Ethernet als Träger verschickt werden, ist wiederum in RFC 894 festgelegt, während RFC 826 die Zuordnung von Ethernet-Adressen zu IP-Adressen regelt.&lt;/p&gt;
&lt;p&gt;Die Universalität von TCP/IP verbirgt die Eigenheiten der unterliegenden Trägernetze vollständig.
Für einen TCP/IP-Benutzer, ja sogar für den Programmierer ist es egal, auf welche Weise der Zielrechner erreicht wird, er hat eine einheitliche Sicht auf ein riesiges, weltweites, aus
tausenden von Teilnetzen zusammengesetztes Netzwerk.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&#34;smtp&#34;&gt;
    &lt;a href=&#34;#smtp&#34;&gt;
	SMTP
    &lt;/a&gt;
&lt;/h1&gt;
&lt;h4 id=&#34;smtp-dialog-zwischen-tpkitoppointde-und-blacktoppointde&#34;&gt;
    &lt;a href=&#34;#smtp-dialog-zwischen-tpkitoppointde-und-blacktoppointde&#34;&gt;
	SMTP Dialog zwischen tpki.toppoint.de und black.toppoint.de
    &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;Von tpki.toppoint.de gesendete Zeichen sind fett gesetzt.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
220-black.toppoint.de Smail3.1.26.7 #3 ready at Wed, 9 Dec 92 00:08 
MET
220 call +49 431 676689 for operator.
&lt;b&gt;helo tpki.toppoint.de&lt;/b&gt;
250 black.toppoint.de Hello tpki.toppoint.de
&lt;b&gt;mail from: kris@tpki.toppoint.de&lt;/b&gt;
250 &amp;lt;kris@tpki.toppoint.de&gt; ... Sender Okay
&lt;b&gt;rcpt to: kris@black.toppoint.de&lt;/b&gt;
250 &amp;lt;kris@black.toppoint.de&gt; ... Recipient Okay
&lt;b&gt;data&lt;/b&gt;
354 Enter mail, end with &#34;.&#34; on a line by itself
&lt;b&gt;.&lt;/b&gt;
250 Mail accepted
&lt;b&gt;quit&lt;/b&gt;
221 black.toppoint.de closing connection
&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>TCP/IP Dienste</title>
      <link>https://blog.koehntopp.info/1993/03/01/tcpip-dienste.html</link>
      <pubDate>Mon, 01 Mar 1993 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/1993/03/01/tcpip-dienste.html</guid>
      <description>&lt;p&gt;&lt;strong&gt;für c&amp;rsquo;t - Magazin für Computertechnik, Ausgabe 3/93&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;tcpip-dienste&#34;&gt;
    &lt;a href=&#34;#tcpip-dienste&#34;&gt;
	TCP/IP Dienste
    &lt;/a&gt;
&lt;/h1&gt;
&lt;h4 id=&#34;das-größte-problem-bei-einem-artikel-über-das-internet-ist-es-zu-definieren-was-das-internet-überhaupt-ist-eigentlich-existiert-so-etwas-wie-das-internet-nämlich-überhaupt-nicht-das-ändert-natürlich-nichts-an-der-tatsache-daß-millionen-menschen-es-jeden-tag-benutzen-wie-erklärt-sich-ein-solcher-widerspruch&#34;&gt;
    &lt;a href=&#34;#das-gr%c3%b6%c3%9fte-problem-bei-einem-artikel-%c3%bcber-das-internet-ist-es-zu-definieren-was-das-internet-%c3%bcberhaupt-ist-eigentlich-existiert-so-etwas-wie-das-internet-n%c3%a4mlich-%c3%bcberhaupt-nicht-das-%c3%a4ndert-nat%c3%bcrlich-nichts-an-der-tatsache-da%c3%9f-millionen-menschen-es-jeden-tag-benutzen-wie-erkl%c3%a4rt-sich-ein-solcher-widerspruch&#34;&gt;
	Das größte Problem bei einem Artikel über das Internet ist es, zu definieren, was das Internet überhaupt ist. Eigentlich existiert so etwas wie &amp;ldquo;das Internet&amp;rdquo; nämlich überhaupt nicht. Das ändert natürlich nichts an der Tatsache, daß Millionen Menschen es jeden Tag benutzen. Wie erklärt sich ein solcher Widerspruch?
    &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;Am Besten, man beginnt am Anfang:
Ende der Siebziger Jahre hatte das amerikanische Verteidigungsminsterium Bedarf an einer Technologie, die unterschiedlichsten Computersysteme an verschiedenen Orten miteinander zu vernetzen.
Um die Möglichkeiten einer solchen Vernetzung auszuloten und die dazu notwendigen Technologien zu entwickeln und zu erproben, wurde im Jahre 1969 im Rahmen eines Forschungsprojektes ein experimentelles Computernetz ins Leben gerufen.
Schon bald zeigte sich, daß nicht nur das Verteidigungsminsterium einen Bedarf an derartiger Technik hatte.
Das ARPANET war viel erfolgreicher als ursprünglich geplant:
Nach kurzer Zeit schon begannen viele Organisationen das Netz nicht nur für experimentelle Zwecke zu nutzen, sondern verwendeten es auch für ihre tägliche Arbeit.
Auch Institutionen und Firmen, die nicht direkt an der Entwicklung von Netzwerktechnologien beteiligt waren, sondern diese einfach nur benutzen wollten, zeigten Interesse an der Vernetzung.
Daher zog man 1975 die Konsequenz und änderte den Status von ARPANET in den eines Produktionsnetzwerks, das von der Defense Communications Agency (heute die Defense Information Systems Agency) verwaltet wurde.&lt;/p&gt;
&lt;p&gt;Doch die Entwicklung des Netzes blieb damit nicht stehen.
Die heute verwendeten &lt;a href=&#34;#rfc&#34;&gt;Netzwerkprotokolle&lt;/a&gt;

, TCP und IP, stammen im Prinzip aus den frühen achtziger Jahren.
Weil das ARPANET immer stärker wuchs und zum Teil nicht zu experimenteller Arbeit, sondern immer mehr auch zu Produktionszwecken genutzt wurde, teile man es in einen Forschungsteil (ARPANET) und das MILNET auf.
Zugleich stellte man das Protokoll zwischen den zentralen Netzwerkknoten auf TCP/IP um.
Um den Umstieg zu erleichtern und auch Universitäten für die verwendete Technik zu interessieren, wurde eine frei verfügbare Implementation von TCP/IP für BSD UNIX in Auftrag gegeben und damit der Grundstein zu dem gelegt, was heute als &amp;ldquo;open systems&amp;rdquo; in aller Munde ist.
Die Rechnung ging auf: Schon mitte der achtziger Jahre begann die National Science Foundation in den Vereinigten Staaten mit dem Aufbau des NSFNET, einem Netz mit Verbindung zum ARPANET, aber auch zu regionalen Netzwerken auf gleicher Technologiebasis.&lt;/p&gt;
&lt;p&gt;Heute bezeichnet man mit dem Namen &amp;ldquo;internetwork&amp;rdquo; Netzwerk aus Teilnetzwerken der verschiedensten Technologien, die durch das darüberliegende TCP/IP zusammengebunden werden.
Die weltweite Verbindung von TCP/IP-Netzwerken, die aus dem ARPANET entstanden ist, trägt jedoch den Namen &amp;ldquo;das Internet&amp;rdquo; (mit betontem &amp;ldquo;das&amp;rdquo; und großem &amp;ldquo;I&amp;rdquo;).
Alle wichtigen staatlichen und wirtschaftlichen Institutionen in den USA sind mittlerweile auf die eine oder andere Weise mit dem Internet verbunden.
Auch in Deutschland findet, wenn auch mit mehreren Jahren Verzögerung, eine ähnliche Entwicklung statt.
So etwas wie eine einheitliche Verwaltung gibt es jedoch nicht.
Das Internet Activities Board definiert das Internet selbst dann in einem seiner Informationenpapiere auch als einen &amp;ldquo;lockeren, internationalen Zusammenschluß miteinander verbundener Netzwerke, das direkten Kontakt von Rechner zu Rechner durch freiwilliges befolgen offener Protokollstandards und -prozeduren ermöglicht.&amp;rdquo;
Diese Definition ist in der Tat schwammig genug, um einem Gebilde wie dem Internet gerecht zu werden.&lt;/p&gt;
&lt;p&gt;Ein anderer Pluspunkt von TCP/IP ist eher für den Programmierer interessant:
Die totale Unabhängigkeit der Applikation von der darunterliegenden Netzwerkebene.
Ein Programm, das in einer Internet-Umgebung läuft, muß sich nicht darum kümmern, wie es seine Datenpakete aus dem lokalen Ethernet über das Datex-P-Gateway nach Übersee und dort in das lokale Token-Ring-Netzwerk schicken muss.
Das Internet-Protokoll kümmert sich darum, die Details der verschiedenen unterliegenden Netzwerke und Transportmechanismen zu verbergen.
Es kümmert sich auch darum, die schnellste oder am wenigsten ausgelastete Route durch das Netz zu suchen.&lt;/p&gt;
&lt;p&gt;Diese Transparenz wird vom Protokoll auch an die darüberliegenden Anwendungen und letztendlich an den Benutzer weitergegeben.
Für einen Benutzer einer Anwendung im Internet ist es vom Aufwand her kein Unterschied, ob er seine Daten von einer lokalen Platte, aus dem inhouse-Netzwerk, von einem Server irgendwo in Deutschland oder gar in Taiwan oder den USA bekommt.
Allein an der Übertragungsgeschwindigkeit könnte man einen Unterschied  feststellen.
Leider birgt diese Transparenz gelegentlich Probleme in sich:
Für den Benutzer ist es gleich schwierig, einen Dienst über Transatlantik-Leitungen zu benutzen wie einen Dienst im lokalen Ethernet.
Es könnte sogar sein, daß sich ein guter Teil der Netzwerk-Benutzer gar nicht darum kümmert, woher genau die Daten jetzt kommen und wieviel Technik dafür in Bewegung gesetzt werden muß.
In Folge kommt es zu den Stoßzeiten auf überregionalen Leitungen mehr oder weniger stark zu Kapazitätsproblemen.&lt;/p&gt;
&lt;h2 id=&#34;reichhaltiges-angebot&#34;&gt;
    &lt;a href=&#34;#reichhaltiges-angebot&#34;&gt;
	Reichhaltiges Angebot
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Das Internet stellt seinen Benutzern auf der Basis von TCP/IP als Transportprotokoll eine Vielzahl von Dienstleistungen zur Verfügung.
Diese Dienste sind normalerweise auf der Basis eines weiteren Protokolles realisiert, das wiederum auf TCP/IP aufsetzt
(vgl. &lt;a href=&#34;https://blog.koehntopp.info/1993/04/01/tcpip-technik.html&#34;&gt;Internet Technik Artikel&lt;/a&gt;

).&lt;/p&gt;
&lt;p&gt;Der erste Dienst, den man als Benutzer im Internet kennenlernt, ist wahrscheinlich electronic mail.
Mail erlaubt es, Textnachrichten und neuerdings auch multimediale Dokumente an andere Benutzer im Netz zu verschicken.
Die Zustellung der Mail erfolgt, in dem der eigene Rechner nach dem Abschicken der Mail eine Verbindung zum Zielrechner aufbaut und die Mail dort online und direkt einliefert.
Bei einer schnellen Netzverbindung ist die Mail praktisch Sekunden nach dem Drücken der Returntaste beim Empfänger.&lt;/p&gt;
&lt;p&gt;Viele bekannte Firmen sind im Netz durch Mitarbeiter oder sogar mit einer Supportadresse vertreten.
Darunter sind so illustre Namen wie Motorola, Intel, AT&amp;amp;T, Microsoft, Borland, Seagate, Prime, NeXT, SUN, DEC, IBM, HP, Commodore, Atari und viele andere mehr, darunter auch zahllose kleinere Firmen.
Auch sind fast alle Universitäten in den meisten Ländern direkt zu erreichen.
Wer Freunde oder Bekannte hat, die als Austauschstudent an einer ausländischen Universität sind, der wird electronic mail als schnelles und billiges Briefmedium schätzen lernen.
Für den Studenten taugt Mail auch, um sich mit den Autoren von Seminarpapieren kurzzuschließen und zusätzliches Material für den Vortrag zu bekommen oder um Fragen zu stellen.&lt;/p&gt;
&lt;p&gt;Wer die Mailgrößen und die Zustellgeschwindigkeiten von Mailboxnetzen gewohnt ist, wird im Internet allerdings umdenken müssen.
Internet ist in der Lage, in kurzer Zeit große Datenmengen zu bewegen und dementsprechend wird dieser Dienst auch genutzt.
Es kann einem leicht passieren, daß man auf eine Anfrage, ob diese oder jene Datei vorhanden sei, kein &amp;ldquo;Ja&amp;rdquo;, sondern kurzerhand die Quelle zugestellt bekommt.&lt;/p&gt;
&lt;p&gt;Mit Mail ist es möglich, private Nachrichten an Personen zu verschicken.
Auf dem Internet gibt es einen anderen Dienst, News, der es erlaubt öffentliche Nachrichten an Sachgruppen, sogenannte Newsgroups, zu adressieren.
Eine Newsgroup ist gewissermaßen ein öffentliches Diskussionsforum, das einem bestimmten Thema gewidmet ist.
Insgesamt gibt es weit über 2500 verschiedene Newsgroups mit einem Themenspektrum, das von Computerthemen über Wissenschaft, Hobby, politischer Diskussion bis hin zu bloßem Jux reicht.
Typische Laufzeiten von Nachrichten in einer Newsgroup liegen dabei in der Gegend von 6-10 Stunden.
In dieser Zeit ist der eigene Text einmal rund um die Erde verteilt worden und viele tausend Mal kopiert worden.&lt;/p&gt;
&lt;p&gt;Mit einer Nachricht in einer Newsgroup erreicht man schnell ein großes Publikum.
Selbst bei exotischen Problemen oder Fragestellungen ist es wahrscheinlich, innerhalb eines Tages Personen zu finden, die ein ähnliches Problem auch schon einmal gehabt haben und einem möglicherweise weiter helfen können.
Gerade für jemanden, der sich mit Softwareentwicklung befaßt, sind die News eine wichtige Quelle für Informationen, praktische Erfahrungsberichte und Support, die beim Hersteller oft nur schwer zu bekommen sind.&lt;/p&gt;
&lt;p&gt;Viele nützliche PD-Programme konnten nur deswegen entstehen, weil Programmierer in den entferntesten Gegenden der Erde per News und Mail Quellen und Fehlerreports austauschen können und so trotz der großen Entfernungen eng zusammenarbeiten können.
Die public domain UNIX-Versionen Linux und 386BSD sind nach Megbytes gemessen die größten Produkte einer solchen Zusammenarbeit, aber auch viele andere Werkzeuge für den täglichen Einsatz sind auf diese Weise entstanden.
Allen voran stehen die Programme, die man zur effizienten Nutzung von News und Mail benötigt:
Programmpakete zum Lesen, Schreiben, Verschicken und Archivieren von News und Mail.&lt;/p&gt;
&lt;p&gt;Die neuesten Versionen dieser Programmpakete finden sich in Archiven, die per anonymous FTP zugänglich sind.
FTP steht für &amp;ldquo;File Transfer Protocol&amp;rdquo; und ist zugleich der Name eines Übertragungsprotokolls als auch der Name der Anwendung, die dieses Protokoll benutzt, um per Internet Dateien zu übertragen.
Viele Institutionen, die einen schnellen Internet-Anschluß haben und ein wenig Plattenplatz erübrigen können, richten Bereiche ein, in denen man auch ohne Paßwort per FTP Programme ablegen oder abholen kann.
Teilweise sind diese Rechner so konfiguriert, daß sie ihre Datenbestände untereinander automatisch abgleichen, ihre Platten also gegenseitig spiegeln.
Auf diese Weise erübrigt sich für den Benutzer das Horten von Quelltexten auf der eigenen Platte:
Wenn man ein Programmpaket benötigt, um es zu installieren oder mit den Quellen zu arbeiten, wird man sowieso nicht das private Archiv mit der veralteten Version aufsuchen, sondern sich per FTP eine aktuelle Version desselben Paketes holen.&lt;/p&gt;
&lt;p&gt;Das Hauptproblem dabei ist es lediglich, einen Server zu lokalisieren, der die gewünschten Daten auch anbietet.
Dafür gibt es im Netz öffentlich zugängliche Datenbanken, die einen Index über dreistellige Gigabytemengen auf Software enthalten, die Archies.
Ein Archie ist eine Datenbank, die typischerweise im Tages- oder Wochenrhytmus die kompletten Inhaltsverzeichnisse einiger hundert FTP-Server abfragt und zu einem Gesamtindex verarbeitet.
Man kann den Archie nach Namen oder Beschreibungen von Programmpaketen suchen lassen und erhält eine Liste aller Quellen für das gesuchte Programmpaket, die dem Archie bekannt sind.
Dazu kann man sich direkt auf dem Archie einloggen und einer simplen Abfragesprache bedienen.
Richtig bequem wird so eine Abfrage aber erst mit einem Abfrageprogramm wie xarchie (für XWindows), das man mit der Maus bedienen kann.
Die Beschaffung eines bestimmten Programmpaketes beschränkt sich dann auf die Eingabe des Paketnamens und das Anklicken der Knöpfe &amp;ldquo;Query&amp;rdquo; und (nach Auswahl des gewünschten Servers) &amp;ldquo;FTP&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Es gibt im Internet noch weitere frei zugängliche Datenbanken.
Da es jedoch keine zentrale Administration des Netzwerks gibt, ist es hier etwas schwierig einen Überblick zu bekommen.
Es ist zum Beispiel bekannt, daß sehr viele Bibliotheken in den USA einen Zugang ins Internet haben und ihre Kataloge als Datenbank öffentlich zugänglich machen.
Aber auch andere Institutionen bieten Datenbanken zur freien Abfrage an.
Man erreicht diese Datenbanken per TELNET, einem TCP/IP-Dienst, der es einem erlaubt, sich auf einem entfernten Rechner einzuloggen.
Per FTP sind Texte erhältlich, die den Versuch einer Katalogisierung solcher Dienste darstellen und die Netzadressen, Logins und Passwörter enthalten, die man benötigt, um arbeiten zu können.
Der nächste logische Schritt sind Datenbankabfrageprogramme, die eine Anfrage nehmen und sie allen Datenbanken stellen, die ihnen bekannt sind.
Solche Dienste sind WAIS (Wide Area information Service) und gopher.&lt;/p&gt;
&lt;h2 id=&#34;wie-man-sich-anschließt&#34;&gt;
    &lt;a href=&#34;#wie-man-sich-anschlie%c3%9ft&#34;&gt;
	Wie man sich anschließt
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Man kann auf zwei Wegen an einen Internet-Zugang kommen.
Die eine Methode ist es, sich einen Systembetreiber zu suchen, dessen Rechner am Internet angeschlossen ist und der einem die Benutzung seines Rechners erlaubt.
Man kann sich dann auf diesem Rechner einloggen und die Internet-Dienste dieses Rechner online nutzen.
Die andere Methode wäre, auf dem eigenen Rechner zu arbeiten und nur die eigenen IP-Pakete an einen Internet-Rechner weiter zu routen, etwa über ein Modem und SL/IP (Serial Line Internet Protocol).
Die meisten Internet-Anbieter lassen einem die Auswahl zwischen beiden Methoden des Anschlusses.&lt;/p&gt;
&lt;p&gt;Ein Anschluß ans Internet ist derzeit jedoch eine teure Sache, falls man nicht gerade Student an einer Universität mit freiem Zugang zum Internet ist.
Wer immer Internet anbietet, der muß eine Standleitung oder etwas mit ähnlicher Charateristik unterhalten.
Dabei kann es sich um eine Datex-P, ISDN- oder Modemstrecke handeln.
Der Betreiber dieser Strecke wird natürlich versuchen, seine Kosten auf die Nutzer umzulegen.
Im Endeffekt liegen die Kosten für vernünftig nutzbaren Internet-Anschluß derzeit bei etwa 50 DM/Monat mit starken geographischen Abweichungen.&lt;/p&gt;
&lt;p&gt;In Deutschland gibt es drei verschiedene Anbieter, die Internet-Dienste verkaufen können.
Diese sogenannten Provider sind jedoch nur für kommerzielle Kunden und Institutionen interessant.
Es handelt sich um EuNet Germany GmbH in Dortmund, XLINK in Karlsruhe und den DFN Verein.
Für Privatpersonen ist eher der Individual Network e.V. (&amp;ldquo;das IN&amp;rdquo;) interessant.
Dieser Verein hat bei zweien dieser drei Anbieter das Recht gekauft, deren Internet-Leitungen zu benutzen und dieses Recht an seine Mitglieder weiterzugeben.
Auf diese Weise kann das IN seinen Mitgliedern einen günstigen Zugang ins Internet verschaffen, wenn diese die dazu notwendig Infrastruktur vor Ort organisieren können.&lt;/p&gt;
&lt;p&gt;Wenn man sich in der Nähe eines solchen Zugangspunktes wohnt, also etwa in Kiel, Hamburg, Berlin, Oldenburg, im Ruhrgebiet, in Frankfurt oder
in München, dann genügt es, sich an den entsprechenden Anbieter zu wenden (siehe Kasten&amp;quot;Adressen&amp;quot;).
Ansonsten wird man sich überlegen müssen, ob man einen Anschlußpunkt in der Nähe finden kann oder wie man die Entfernung zum nächsten Anschlußpunkt überbrücken kann.&lt;/p&gt;
&lt;h2 id=&#34;informationsquellen&#34;&gt;
    &lt;a href=&#34;#informationsquellen&#34;&gt;
	Informationsquellen
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Um Neueinsteigern ins Internet bei der Orientierung zu helfen und einen Überblick über die verfügbaren Informationen und Dienste zu geben, hat man eine Reihe von RFCs mit Einsteierinformationen zusammengestellt.
Diese RFCs sind in einer gesonderten Reihe als &amp;ldquo;For your information&amp;rdquo; oder kurz FYI-Texte zusammengefaßt worden.
Von besonderem Interesse sind FYI 4, der sich mit häufig gestellten Fragen von Internet-Neulingen beschäftigt, FYI 8, der sich mit der Sicherheit einer Internet-Installation befaßt und FYI 10, der einen Überblick über im Internet verfügbare Dienste gibt.&lt;/p&gt;
&lt;h2 id=&#34;literatur&#34;&gt;
    &lt;a href=&#34;#literatur&#34;&gt;
	Literatur
    &lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Internetworking with TCP/IP; Principles, Protocols, and Architecture&amp;rdquo;,  by Douglas Comer, Prentice Hall, ISBN 0-13-470154-2.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;The Matrix; Computer Networks and Conferencing Systems Worldwide&amp;rdquo;, by John S. Quarterman, Digital Press, ISBN 0-13-565607-9.&lt;/LI&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;!%@:: A Directory of Electronic Mail Addressing and Networks&amp;rdquo;, by Donnalyn Frey and Rick Adams, O&amp;rsquo;Reilly &amp;amp; Associates, Inc., ISBN 0-937175-39-0.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;The User&amp;rsquo;s Directory of Computer Networks&amp;rdquo;,  Edited by Tracy L. LaQuey, Digital Press, ISBN 0-13-950262-9.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Where to Start - A Bibliography of General Internetworking Information&amp;rdquo;, by Bowers, K., T. LaQuey, J. Reynolds, K. Roubicek, M. Stahl, and A. Yuan, RFC 1175, FYI 3, CNRI, U Texas, ISI, BBN, SRI, Mitre, August 1990.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;The Hitchhikers Guide to the Internet&amp;rdquo;, by Krol, E., RFC 1118, University of Illinois Urbana, September 1989.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;IAB Official Protocol Standards&amp;rdquo;&lt;/I&gt;, (currently, RFC 1280).&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;rfc&#34;&gt;
    &lt;a href=&#34;#rfc&#34;&gt;
	RFC
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Ein &amp;ldquo;Request for Comments&amp;rdquo;, kurz RFC,  ist ein Papier, das sich in irgendeiner Form mit im Internet verwendeten Verfahren beschäftigt.
Es kann sich dabei um eine Anmerkung zu bestehenden Verfahren, einen Verbesserungsvorschlag oder den Vorschlag zu einem neuen Verfahren handeln.
Jeder, der am Internet interessiert ist, kann einen solchen RFC beim RFC Editor einreichen.
Derzeit ist der RFC Editor Jon Postel, der unter der Internet-Adresse &lt;a href=&#34;mailto:RFC-EDITOR@ISI.EDU&#34;&gt;RFC-EDITOR@ISI.EDU&lt;/a&gt;

 zu erreichen ist.
Wie eine Einsendung an den RFC-Editor auszusehen hat, um ihm die Arbeit zu vereinfachen ist auch in einem RFC (&lt;a href=&#34;http://src.doc.ic.ac.uk/public/rfc/rfc1111.txt.gz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 1111&lt;/a&gt;

 beschrieben.&lt;/p&gt;
&lt;p&gt;Ein solches Papier kann den Status &amp;ldquo;zur Information&amp;rdquo; erhalten, wenn es sich nur um eine Anmerkung handelt.
Enthält der RFC eine Spezifikation, die einmal ein Standard werden soll, so kann das Internet Activities Board (IAB) das Papier prüfen und zum &amp;ldquo;proposed standard&amp;rdquo; erklären.
So eine Spezifikation soll dann die Grundlage für zu entwickelnde Programmpakete sein, d.h. es braucht noch keine funktionierende Implementation des Standards zu geben.&lt;/p&gt;
&lt;p&gt;Sobald es Erfahrungen mit dem neuen Vorschlag gibt, frühestens aber nach einem halben Jahr, kann die Spezifikation zum &amp;ldquo;draft standard&amp;rdquo; werden.
Dazu muß es mindestens zwei Implementationen geben, die unabhängig voneinander aus der Spezifikation entwickelt worden sind und die trotzdem zusammenarbeiten können.
An einem &amp;ldquo;draft standard&amp;rdquo; wird nichts wesentliches mehr geändert; Modifikationen dienen nur noch der Ausbesserung von Fehlern und Ungenauigkeiten.&lt;/p&gt;
&lt;p&gt;Schließlich wird die Spezifikation nach angemessener Zeit zum &amp;ldquo;standard&amp;rdquo; befördert und ist damit ein fester Teil der Internet-Spezifikationen.
&lt;a href=&#34;http://src.doc.ic.ac.uk/public/rfc/rfc1280.txt.gz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC  1280&lt;/a&gt;

 gibt eine Übersicht über den Standardisierungsprozeß und nennt den Status der verschiedenen Dokumente.&lt;/p&gt;
&lt;p&gt;Nicht alle Standards im Internet müssen von allen Programmpaketen unterstützt werden.
Die RFCs unterscheiden zwischen Fähigkeiten, die alle beteiligten Programme unterstützen müssen (required), zwischen Optionen, die alle unterstützen sollten (recommended) und zusätzlichen Features, die wirklich optional sind (elective).&lt;/p&gt;
&lt;p&gt;Um in der Entwicklung der Standards im Internet auf dem Laufenden zu bleiben, kann man die neu erscheinenden RFCs abonnieren.
Dazu sendet man eine E-Mail an &lt;a href=&#34;mailto:RFC-REQUEST@NIC.DDN.MIL&#34;&gt;RFC-REQUEST@NIC.DDN.MIL&lt;/a&gt;

, die die eigene Netzadresse enthält.
Diese Adresse wird dann in einen Verteiler übernommen und fortan bekommt man alle neuen RFCs per E-Mail zugestellt.
Vorausgegangene RFCs sind in verschiedenen Archiven zu bekommen.
Eine Liste dieser Archive und eine Anleitung, wie man die betreffenden Dokumente bekommen kann, kann per FTP als isi.edu:/in-notes/rfc-retrieval.txt bezogen werden.
Alternativ kann man auch eine E-Mail an &lt;a href=&#34;mailto:rfc-info@isi.edu&#34;&gt;rfc-info@isi.edu&lt;/a&gt;

 senden, die als Nachrichtentext nur die eine Zeile &amp;ldquo;help: ways_to_get_rfcs&amp;rdquo; (ohne die Anführungszeichen) enthält.
Die RFCs bis Nummer 1357 sind außerdem auf der Desktop Library CD von Walnut Creek enthalten.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Betriebssysteme</title>
      <link>https://blog.koehntopp.info/1992/03/17/betriebssysteme.html</link>
      <pubDate>Tue, 17 Mar 1992 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/1992/03/17/betriebssysteme.html</guid>
      <description>&lt;p&gt;&lt;strong&gt;Abgeschickt an die c&amp;rsquo;t am 17. März 1992.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Aus technischen Gründen stehen die Abbildungen zu diesem Artikel nicht im Web zur Verfügung.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#betr%c3%bcbssysteme&#34;&gt;Text des Artikels&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#glossar&#34;&gt;Glossar&lt;/a&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;betrübssysteme&#34;&gt;
    &lt;a href=&#34;#betr%c3%bcbssysteme&#34;&gt;
	Betrübssysteme
    &lt;/a&gt;
&lt;/h1&gt;
&lt;h4 id=&#34;jeder-hat-eines-angeblich-kennt-sich-kaum-einer-wirklich-damit-aus-und-natürlich-ist-meines-besser-als-deines-die-rede-ist-von-betriebssystemen&#34;&gt;
    &lt;a href=&#34;#jeder-hat-eines-angeblich-kennt-sich-kaum-einer-wirklich-damit-aus-und-nat%c3%bcrlich-ist-meines-besser-als-deines-die-rede-ist-von-betriebssystemen&#34;&gt;
	Jeder hat eines, angeblich kennt sich kaum einer wirklich damit aus und natürlich ist meines besser als Deines. Die Rede ist von Betriebssystemen.
    &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;Das Betriebssystem ist das Grundprogramm eines Rechners.
Es wird beim Einschalten des Rechners gestartet und erst beim Abschalten wieder beendet.
Entsprechend seiner Funktion als Zwischenstück zwischen der realen Welt der konkreten Hardware und der abstrakten Welt der Algorithmen ist seine Aufgabe eine doppelte:
Für alle Benutzer eines Rechners teilt es die Rechenleistung, den Speicher und die Geräte der Maschine fair zwischen ihnen auf.
Es verhindert, so ist zumindest die Theorie, ungewollte Beeinflussung der verschiedenen Programme auf einem Rechner untereinander.
Für ein einzelnes Programm ist das Betriebssystem mehr wie eine große Befehlsbibliothek, die die doch recht sparsame Maschinensprache eines Rechners um so wirksame Funktionen wie &amp;ldquo;mehr Speicher zur Verfügung stellen&amp;rdquo;, &amp;ldquo;Satz aus einer Datei lesen&amp;rdquo; oder gar &amp;ldquo;diesen Bildschirmaufbau präsentieren und Ergebnis der Benutzeraktion hier abliefern&amp;rdquo; erweitert.&lt;/p&gt;
&lt;h2 id=&#34;mit-gespaltener-zunge&#34;&gt;
    &lt;a href=&#34;#mit-gespaltener-zunge&#34;&gt;
	Mit gespaltener Zunge
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Diese doppelte Aufgabenstruktur des Aufteilens und Multiplexens von knappen Betriebsmitteln auf der einen Seite und des Verbergens von lästigen Details aus der realen Welt vor den Anwendungen auf
der anderen Seite bestimmt die Struktur eines Betriebssystems.
Die Betriebsmittel, die ein Betriebssystem verwaltet, lassen sich grob in drei Gruppen unterteilen:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Zum ersten ist da - aus der Hardwaresicht - der Prozessor.
Er ist die einzig aktive Komponente des Systems und zudem in den meisten Fällen leider nur einmal vorhanden.
Aus der abstrakteren Sicht der Software erscheint er als Thread (&amp;ldquo;Kontrollfluß&amp;rdquo;) eines Programmes.
Ein gutes Betriebssystem wird die kostbare - weil seltene - Prozessorhardware multiplexen, um mehr als einen Kontrollfluß zur Zeit ablaufen zu lassen.&lt;/li&gt;
&lt;li&gt;Zum zweiten gibt es den Arbeitsspeicher.
Damit der Prozess ablaufen kann, müssen er selbst und seine Daten irgendwo gespeichert werden.
Realer Speicher in Form von RAM hat irgendwelche Adressen und ist nicht notwendigerweise mit den von der Anwendung benötigten Eigenschaften (&amp;ldquo;an einem Stück&amp;rdquo;, &amp;ldquo;an einer bestimmten Stelle&amp;rdquo;) vorhanden.&lt;br&gt;
Es ist Aufgabe des Betriebssystems, mit Unterstützung einer MMU diese Anforderungen zu erfüllen.
Andererseits muß aber verhindert werden, daß ein Prozess mehr als den ihm zugesicherten Speicher benutzt und dadurch eventuell andere Prozesse in ihrem Ablauf stört.
Das Betriebssystem muß die images (&amp;ldquo;Laufzeitbilder&amp;rdquo;) verschiedener Programme verwalten.&lt;/li&gt;
&lt;li&gt;Und zum dritten sind auch noch Ein/Ausgabegeräte verschiedenster Art zu verwalten.
Einige dieser Geräte, zum Beispiel Drucker oder Bandlaufwerke, sind nur von einem Prozess zur Zeit nutzbar.
In diesem Fall muß das Betriebssystem den Zugriff auf diese Geräte zuteilen - etwa über einen Druckerspooler oder durch Locks.
Andere Geräte, Festplatten beispielsweise, können aufgeteilt werden.
Hier muß das Betriebssystem einen entsprechenden Dienst zur Verfügung stellen - im Beispiel wäre dies ein Dateisystem.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ein Betriebssystem stellt dem Anwendungsprogramm, wie bereits festgestellt, verschiedene Dienste zur Verfügung.
Allerdings gibt es verschiedene Konzepte bei den Betriebssystem-Herstellern, wie diese Dienste in Anspruch zu nehmen sind.&lt;/p&gt;
&lt;h2 id=&#34;message-passing&#34;&gt;
    &lt;a href=&#34;#message-passing&#34;&gt;
	Message passing
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Ältere Betriebssysteme wie MS-DOS, aber auch UNIX und OS/2, stellen Dienste des Systems per Prozeduraufruf zur Verfügung.
Ob der Funktionsaufruf dabei durch einen Unterprogrammaufruf wie bei OS/2 oder durch einen Software-Interrupt wie bei MS-DOS und UNIX erfolgt, ist dabei zunächst nebensächlich.
Wesentlich ist, daß der Kontrollfluß des Prozesses auf das Betriebssystem über geht.
Diese Art des Dienstaufrufes hat aber einige Eigenschaften, die auf den ersten Blick als selbstverständlich, auf den zweiten Blick aber eher als unerwünscht gelten können:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ein solcher Unterprogrammaufruf ist immer synchron:
Das eigene Programm wartet solange, bis der Betriebssystemaufruf beendet ist.
Bei einigen Systemaufrufen, die mit Ein-/Ausgabefunktionen zu tun haben, könnte es aber vorteilhaft sein, daß das eigene Programm zwar den Wunsch nach bestimmten Daten absetzt, aber dann
erst einmal selbst weiterläuft und später nachsieht, ob die Daten denn jetzt zur Verfügung stehen.&lt;/li&gt;
&lt;li&gt;Durch einen Unterprogrammaufruf wird außerdem stillschweigend vorausgesetzt, daß das Betriebssystem den Dienst auf derselben CPU wie die Anwendung erbringt.
Eine Funktion &amp;ldquo;Fourieranalyse der Daten in diesem Puffer&amp;rdquo; unter Benutzung der wesentlich schnelleren Hardware eines Signalprozessors ist auf diese Weise nicht mit Unterstützung des Betriebssystems möglich - der Anwendungsprogrammierer muß das selbst hinbasteln.&lt;/li&gt;
&lt;li&gt;Wenn der Dienstaufruf dann auch noch durch einen gewöhnlichen Unterprogrammaufruf geschieht, ist es einer Anwendung möglich, außer den definierten Betriebssystemfunktionen auch noch andere, nicht dokumentierte Funktionen aufzurufen, in dem nicht zugelassene Sprungadressen
benutzt werden.
Es soll sogar Systeme geben, auf denen dies die gängige Praxis ist.
Der Systemsicherheit und der späteren Erweiterbarkeit ist eine so etwas natürlich nicht
dienlich.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Moderne Betriebssystemarchitekturen, allen voran Mach auf dem NeXT, aber auch Tanenbaums Amoeba oder Plan9 von AT&amp;amp;T, sind deswegen nach dem Client-Server Modell aufgebaut:
Die Dienste des Systems stehen dabei an Serverprozessen zur Verfügung.
Der Aufrufer sendet dem Server eine Nachricht (request-message), die von diesem ausgewertet wird.
Das Resultat wird dem Absender in einer Antwortnachricht (reply-message) zugestellt.&lt;/p&gt;
&lt;p&gt;Der Server ist dabei kein Teil des Betriebssystems selbst, sondern ein normaler Prozess, der möglicherweise einige zusätzliche Privilegien gegenüber gewöhnlichen Anwendungen hat.
Dazu gehört etwa die Zugriffsmöglichkeit auf einige Hardwareregister.
Das eigentliche Betriebssystem ist dann auf die allerwesentlichsten Funktionen reduziert:
Es verwaltet lediglich die Umschaltung zwischen den verschiedenen Prozessen, den lokalen Speicher des Systems und natürlich den Versand der Messages.
Alle anderen Dienste werden durch leicht austauschbare Serverprozesse realisiert.&lt;/p&gt;
&lt;p&gt;Dieses Modell des Dienstaufrufes hat nicht die Nachteile des Unterprogrammaufrufes:
Die Dienstleistungen des Systems können asynchron in Anspruch genommen werden, indem die Anwendung beispielsweise eine Nachricht mit einem Lesekommando an den Fileserver sendet, dann aber weiterarbeitet.
Später, wenn die Daten benötigt werden, sieht die Anwendung nach, ob die Antwort des Servers schon vorliegt.
Wenn ja, kann ohne Pause weitergearbeitet werden, ansonsten muß die Anwendung (wie beim Dienstaufruf durch Sprung in ein Unterprogramm auch) warten.&lt;/p&gt;
&lt;p&gt;Für die Anwendung ist es egal, ob der angeforderte Dienst lokal auf der eigenen CPU vorhanden ist oder ob ein Server über ein Netz auf einem anderen Rechner läuft.
Die Netzadresse mag sich ändern, aber der Aufrufmechanismus bleibt derselbe.
Unterschiedliche Datenformate, Maschinensprachen oder Aufrufkonventionen werden durch den Message-Mechanismus verborgen.&lt;/p&gt;
&lt;p&gt;Auch kann das Verhalten den Servers, der ja von seinem Client vollständig getrennt ist, genau durch seine Reaktion auf die verschiedenen Kommandonachrichten beschrieben werden.
Für den Client ist der Server auf jeden Fall eine Black Box.
Unsaubere Gemeinheiten wie das heimliche Auslesen von undokumentierten Variablen oder der Sprung in interne Funktionen, die eine Anwendung eigentlich nicht kennen geschweige denn aufrufen sollte, sind nicht mehr machbar, denn der Server läuft in einem vom Client vollständig getrennten Adreßraum oder sogar auf einer ganz anderen Maschine in einem Netz.&lt;/p&gt;
&lt;h2 id=&#34;rechenleistung-verteilen&#34;&gt;
    &lt;a href=&#34;#rechenleistung-verteilen&#34;&gt;
	Rechenleistung verteilen
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Wie oben erwähnt gibt es Systemzustände, in denen der Rechner ein Programm nicht fortsetzen kann, weil es auf irgendwelche Ereignisse (das Eintreffen von Daten von einem Gerät, das Erreichen einer bestimmten Zeit etc.) wartet.
Offenbar reicht ein einzelnes Programm nicht aus, einen Prozessor durchgehend zu beschäftigen.
Bei genauerer Untersuchung stellt sich sogar heraus, daß die meisten Programme mehr als 90 % ihrer realen Laufzeit in derartigen Wartezuständen zubringen.&lt;/p&gt;
&lt;p&gt;Aus dieser Beobachtung heraus ist das Konzept des Multitasking geboren worden.
In regelmäßigen Zeitabständen wird das laufende Programm unterbrochen, sein augenblicklicher Zustand wird eingefroren.
Der Scheduler des Betriebssystems wählt dann einen anderen Prozess aus, dessen Zustand aufgetaut wird und der dann für die Dauer der nächsten Zeitscheibe zum Ablauf kommt.
Ein Scheduler, der mit Zeitscheiben arbeitet, heißt &amp;ldquo;preemptive&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Viele Betriebssysteme, die nachträglich auf Multitasking nachgerüstet worden sind, haben keinen solchen Scheduler, sondern sind darauf angewiesen daß ein Task den Prozessor freiwillig hergibt.
Das kann ausdrücklich durch den Aufruf einer &lt;code&gt;schedule()&lt;/code&gt;-Funktion in regelmäßigen Abständen geschehen oder versteckt, indem man im Betriebssystem am Ende jeder Systemfunktion einen Aufruf des Schedulers vor dem Verlassen des Betriebssystems einsetzt.
Eine solche Form von Multitasking nennt man &amp;ldquo;kooperativ&amp;rdquo; oder &amp;ldquo;non-preemptive&amp;rdquo;.
Bei einem System mit kooperativem Multitasking kann die Umschaltung für den Benutzer aber leicht schwerfällig wirken, wenn rechenintensive Anwendungen laufen, die selten Systemaufrufe tätigen.&lt;/p&gt;
&lt;p&gt;Einer der schwersten Fehler, den ein Programmierer auf einem Rechner mit Multitasking-Betriebssystem machen kann, ist es, in einer aktiven Warteschleife auf das Eintreffen eines Ereignisses zu warten (&amp;ldquo;busy waiting&amp;rdquo;).
Die Effektivität von Multitasking beruht ja gerade darauf, daß Prozesse, die gerade keine echte Arbeit zu tun haben, stillgelegt werden und vom Betriebssystem erst dann wieder Rechenzeit zugeteilt bekommen, wenn sie etwas damit anfangen können.&lt;/p&gt;
&lt;p&gt;Deswegen ist es fast unmöglich, ein Betriebssystem wie beispielsweise MS-DOS nachträglich multitaskingfähig zu machen oder in einer Multitaskingumgebung (z.B. eine DOS-Box in UNIX oder OS/2) zu betreiben.
Nahezu jedes Programm, angefangen vom Kommandointerpreter der Shell, &amp;ldquo;verbrät&amp;rdquo; die ihm zugeteilte Rechenzeit vollständig in Zeicheneinleseroutinen und anderen engen Warteschleifen, anstatt diese anderen Programmen zur Verfügung zu stellen.
MS-DOS Prozesse sind gewissermaßen immer im Zustand &amp;ldquo;ready&amp;rdquo;.
Wenn man einem solchen System nachträglich eine Multitaskingerweiterung überstülpt, fehlt diesem System notgedrungen der Zustand &amp;ldquo;sleeping&amp;rdquo;, und jeder laufende Prozess erhält genau 1/ntel der Gesamtleistung der CPU - selbst dann, wenn er eigentlich gar nichts damit anfangen könnte.&lt;/p&gt;
&lt;p&gt;Nach welcher Strategie die &lt;code&gt;schedule()&lt;/code&gt;-Funktion letztendlich bestimmt, welcher Prozess aus der &amp;ldquo;ready&amp;rdquo;-Queue in den Zustand &amp;ldquo;running&amp;rdquo; gehen darf und damit auf die CPU gelangen kann, hängt stark von den gewünschten Eigenschaften des Systems ab.
Der einfachste Zuteilungsalgorithmus ist das &amp;ldquo;round-robin&amp;rdquo;-Verfahren.
Dabei wird die zur Verfügung stehende CPU-Zeit gleichmäßig zwischen allen Prozessen aufgeteilt, die sich darum bewerben.
Alle diese Prozesse kommen reihum auf die CPU - daher der Name.&lt;/p&gt;
&lt;p&gt;Oft wird dieses Verfahren noch so erweitert, daß man Prozesse unterschiedlicher Priorität unterscheidet.
Der Scheduler von AmigaOS, aber auch der von VAX/VMS, ist ein Round-Robin Scheduler mit Prioritäten.
Das bedeutet: Der Ringtausch der Prozesse auf der CPU funktioniert innerhalb der höchsten vorhandenen Prioritätsebene.
Erst wenn alle Prozesse einer höheren Prioritätsebene aus der Ready-Queue entfernt sind, etwa weil sie terminiert sind oder weil sie auf ein Ereignis warten und deswegen stillgelegt sind, kommen
Prozesse mit niederen Prioritäten auf die CPU.&lt;/p&gt;
&lt;p&gt;Andererseits kann ein CPU-intensiver Prozess mit einer hohen Priorität den Rest des Systems recht schwerfällig machen oder gar blockieren.
Gelegentlich (bei Echtzeitanwendungen zum Beispiel) ist dieser Effekt erwünscht:
Man geht davon aus, daß ein Prozess mit einer hohen Priorität die Rechenzeit, die er beansprucht, auch unbedingt und gerade zu diesem Zeitpunkt benötigt.
Im allgemeinen Fall allerdings möchte man eine Lösung haben, die auch dann noch eine gewisse
Fairness gewährleistet, wenn ein Programm böswillig Rechenzeit schluckt.
In UNIX zum Beispiel sind die Prioritäten von Prozessen nicht fest, sondern hängen davon ab, wie lange der Prozess schon in der Warteschlange steht und wie CPU-intensiv er ist.&lt;/p&gt;
&lt;p&gt;Prozesse, die frühzeitig die CPU verlassen (etwa weil sie viel I/O machen und deswegen häufig im Zustand &amp;ldquo;sleeping&amp;rdquo; sind) bekommen ihre Restzeit als Bonus für die nächste Zeitscheibe gutgeschrieben, der in die Berechnung der Priorität eingeht.
Dadurch bekommen solche Prozesse automatisch eine bessere Priorität als solche, die die Zeitscheiben immer voll ausnutzen.&lt;/p&gt;
&lt;p&gt;Prozesse, die lange in der Ready-Queue gestanden haben (weil sie eine schlechte Priorität haben), werden temporär aufgewertet, damit sie auch eine Chance haben, einmal zum Ablauf zu kommen (priority aging).&lt;/p&gt;
&lt;h2 id=&#34;synchronisation&#34;&gt;
    &lt;a href=&#34;#synchronisation&#34;&gt;
	Synchronisation
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Eines der zentralen Probleme in einem System, in dem mehr als ein Programm zur Zeit aktiv sein kann, ist die Synchronisation von Prozessen bzw. der gegenseitige Ausschluß von Prozessen, die auf einen gemeinsamen Datenbereich zugreifen.
Gemeinhin löst man in der Information ein solches Problem mit Semaphoren:
Man definiert sich ein Flag, das anzeigt, ob ein Datenbereich zur Zeit &amp;ldquo;frei&amp;rdquo; oder &amp;ldquo;in Bearbeitung&amp;rdquo; ist, und zwei Operationen zum Setzen bzw. Löschen dieses Flags.
Der Punkt ist, daß diese Operationen atomar sein müssen, das heißt, die Semaphor-Setzfunktion und die Löschfunktion dürfen auf keinen Fall unterbrochen werden.&lt;/p&gt;
&lt;p&gt;Auf Rechnern mit nur einem Prozessor läßt sich dieses Problem recht leicht dadurch lösen, daß man in diesen beiden Funktionen kurze Zeit sämtliche Unterbrechungen verbietet und die gewünschte Operation durchführt.
Auf Mehrprozessorsystemen nützt dies natürlich nichts mehr, denn während der eine Prozessor den Semaphor bearbeitet, kann ein anderes Programm auf einem anderen Prozessor dasselbe tun.
Hier ist das Betriebssystem auf die Unterstützung der Hardware angewiesen, die nicht unterbrechbare Semaphor-Operationen schon als Prozessorbefehl anbieten muß.
Prozessoren wie der 680x0 und der 80x86 haben solche Operationen bereits eingebaut:
Der TAS-Befehl des 680x0 führt zum Beispiel eine solche Semaphor-Operation in einem nicht unterbrechbaren Read-Modify-Write-Zyklus aus, und der 80x86 kennt das LOCK-Prefix für eine ganze Reihe von Befehlen, die dann ebenfalls nicht unterbrechbar werden.&lt;/p&gt;
&lt;h2 id=&#34;speicher-auf-kredit&#34;&gt;
    &lt;a href=&#34;#speicher-auf-kredit&#34;&gt;
	Speicher auf Kredit
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Eine andere nützliche Sache, die einen sicheren Multitasking-Betrieb unterstützt, ist in den neueren
Prozessoren der verschiedenen Hersteller ebenfalls gleich mit eingebaut:
Alle diese Geräte haben eine PMMU, das bedeutet, sie sind in der Lage, physikalisch vorhandenes RAM an jeder beliebigen Stelle des Adreßraumes der CPU einzublenden und die Speicherzugriffe eines jeden Programmes genau zu kontrollieren.&lt;/p&gt;
&lt;p&gt;Auf diese Weise läßt sich ein Prozess in seinem eigenen Speicher einzäunen.
Zwar erlaubt man ihm, auf den eigenen vom System angeforderten Speicher zuzugreifen, doch sobald versucht wird, auf andere, nicht erlaubte Speicherbereiche zuzugreifen, wird der Prozess unterbrochen und das Betriebssystem übernimmt die Kontrolle (&amp;ldquo;memory protection&amp;rdquo;, &amp;ldquo;Speicherschutz&amp;rdquo;).
Es kann den problematischen Prozess stillegen und ein Image seines Zustandes zur späteren Fehlersuche auf Platte ablegen.
Auf diese Weise verhindert man zwar nicht, daß ein fehlerhaftes Programm abstürzt, aber immerhin wird sichergestellt, daß keine anderen Programme in Mitleidenschaft gezogen werden.&lt;/p&gt;
&lt;p&gt;Die MMU-Hardware kann man auch dazu benutzen, dem Programm mehr RAM vorzuspiegeln, als tatsächlich in der verwendeten Maschine vorhanden ist (&amp;ldquo;virtual memory&amp;rdquo;).
Die meisten Programme brauchen nicht alle ihre Daten und ihren gesamten Code zur gleichen Zeit, sondern sind oft nur in einem kleinen, eng begrenzten Speicherbereich (dem &amp;ldquo;working set&amp;rdquo;) aktiv.
Je nach Benutzung des Programmes verschiebt sich dieser Bereich von Zeit zu Zeit, aber im Prinzip würde ein kleiner Speicherbereich ausreichen, um das ganze Programm ablaufen zu lassen.&lt;/p&gt;
&lt;p&gt;Betriebssysteme wie UNIX unterteilen deswegen den gesamten Speicher der Maschine in Seiten fester Größe - bei einer 80386 CPU zum Beispiel werden durch die Hardware Pages von 4 KB Größe vorgegeben.
Nicht alle Speicherseiten eines Prozesses sind gleichzeitig im RAM, sondern Teile davon befinden sich in der &amp;ldquo;paging area&amp;rdquo;, einem abgeteilten Bereich einer Festplatte.
Wenn ein Prozess versucht, eine Speicherseite anzusprechen, die gerade nicht präsent ist, generiert die MMU wieder eine Unterbrechung (&amp;ldquo;page fault&amp;rdquo;) und läßt das Betriebssystem zum Zuge kommen.
Dieses sucht jetzt eine andere Speicherseite, die möglichst lange nicht benutzt worden ist, speichert diese in der Paging Area zwischen, adressiert sie um und stellt sie dann dem unterbrochenen Prozess an der richtigen Adresse und mit dem richtigen Inhalt, der inzwischen von der Platte geladen wurde, zur Verfügung.
Dieser wird nach der kurzen Unterbrechung dann fortgesetzt.&lt;/p&gt;
&lt;p&gt;Wenn genug Speicher vorhanden ist, um die aktiven Teile der verschiedenen lauffähigen Prozesse gleichzeitig im Speicher zu halten, fallen die kurzen Unterbrechungen beim Paging nicht weiter  ins Gewicht.
Wenn der Rechner jedoch überlastet wird und für die Anzahl der gleichzeitig laufenden Prozesse zu wenig Speicher hat, fängt er an, auch Teile von Prozessen auf Platte auszulagern, die gleich wieder geladen werden müssen.
Die Rechenleistung der Maschine fällt plötzlich um einige Zehnerpotenzen, und die Antwortzeiten auf ein simples Return an der Console liegen auf einmal im Minutenbereich.
Man bezeichnet diesen Vorgang als &amp;ldquo;treshing&amp;rdquo; (dreschen), und die Abhilfe bei diesem Problem ist simpel: Man lege einige Megabytes RAM nach.&lt;/p&gt;
&lt;h2 id=&#34;konsequent-weiter-gedacht&#34;&gt;
    &lt;a href=&#34;#konsequent-weiter-gedacht&#34;&gt;
	Konsequent weiter gedacht
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Wenn ein neuer Prozess gestartet wird, muß er zunächst einmal in den Speicher geladen werden.
Verwendet man jedoch das eben erläuterte Virtual-Memory-Schema, bei dem jede Speicherseite des virtuellen Adreßraums genau einer Speicherseite auf der Platte entspricht, muß der Code eines  Prozesses nicht nur in den Speicher kopiert, sondern auch noch in den Paging-Bereich der Platte geschrieben werden.
Zudem werden Speicherseiten, die Code enthalten, nie geändert, so daß eigentlich gar keine private Kopie des Codes in der Paging Area angelegt werden muß.
VMS, aber auch einige neuere UNIX-Versionen und natürlich modernere Systeme wie Mach und Chorus verwenden hier einen intelligenteren Algorithmus:
Seiten mit Programmcode, die aus dem physikalisch vorhandenen Speicher verdrängt werden, werden einfach ohne Zurückschreiben aufgegeben und später aus der Programmdatei wieder nachgeladen (&amp;ldquo;paging from file&amp;rdquo;).
Dadurch entfällt beim Starten eines Programmes das Umkopieren in die Paging Area, und der Paging-Bereich wird weniger stark belastet.&lt;/p&gt;
&lt;p&gt;Die Autoren von Mach und Chorus haben diese Idee konsequent weiter gedacht:
Diese beiden Betriebssysteme können das auch mit Daten machen, die mit read() und write() aus Dateien gelesen oder geschrieben werden.
Dateien, die aus Datensätzen fester Länge bestehen, sind schließlich nur der Sonderfall eines Arrays:
In PASCAL kann man das sogar noch in der Definition sehen.&lt;/p&gt;
&lt;p&gt;Mit Hilfe der MMU blendet man einen Speicherbereich von der Größe der Datei, die verarbeitet werden soll, in den Adreßraum des Prozesses ein (&amp;ldquo;memory mapped file&amp;rdquo;).
Für den Prozess ist die Basis dieses Speicherbereiches die Startadresse eines ganz normalen Arrays. Versucht der Prozess, auf dieses Array zuzugreifen, kommt es zu einem Page Fault.
Das Betriebssystem hat diesen Speicherbereich mit einer Datei assoziiert und lädt jetzt die entsprechenden Dateiinhalte in die angesprochenen Speicherseiten, mit denen der Prozess dann wie bei einem normalen Arrayzugriff arbeitet.
Beim Schließen der Datei wird der Speicherbereich wieder aus dem Adreßraum des Prozesses ausgeblendet, und alle Modifikationen werden spätestens zu diesem Zeitpunkt in die Datei zurückgeschrieben.&lt;/p&gt;
&lt;p&gt;Auf diese Weise werden spezielle Dateioperationen in einer Programmiersprache überflüssig;
Dateien werden wieder zu dem, was sie eigentlich sind:
Arrays dynamischer Länge, deren Inhalt über die Laufzeit eines Prozesses hinaus Bestand hat.
Der Programmierer einer Anwendung braucht sich nicht mehr um das Lesen und Schreiben von Daten in Puffer zu kümmern, er greift einfach darauf zu.
Das tatsächliche Bereitstellen der Daten und das Zurückschreiben auf Platte geschieht durch das Betriebssystem, ohne daß er etwas damit zu tun hätte.&lt;/p&gt;
&lt;h2 id=&#34;inflation-der-programmzähler&#34;&gt;
    &lt;a href=&#34;#inflation-der-programmz%c3%a4hler&#34;&gt;
	Inflation der Programmzähler
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Bis jetzt sind wir stillschweigend davon ausgegangen, daß ein Prozess genau einen Kontrollfluß hat.
Bei den meisten Betriebssystemen ist das auch noch so, obwohl eine Verallgemeinerung möglich ist und bei moderneren Entwicklungen auch durchgeführt worden ist.
Es ist durchaus sinnvoll, daß im Image eines Prozesses mehr als ein Kontrollfluß (&amp;ldquo;Thread&amp;rdquo;) aktiv ist.
Man stelle sich beispielsweise eine Tabellenkalkulation vor, die in einer Warteschleife auf Nachrichteneines Menüsystems wartet.
Wenn der Benutzer jetzt einen Menüpunkt anwählt, der längere Zeit zur Durchführung braucht (etwa das Neuberechnen des gesamten Blattes), kann im Prozess ein Thread dafür abgespalten werden, während der andere Thread schon wieder in der Warteschleife bereitliegt, um neue Benutzerkommandos entgegen zu nehmen.&lt;/p&gt;
&lt;p&gt;Die Erzeugung eines Threads ist - verglichen mit der eines eigenständigen Prozesses - relativ wenig aufwendig.
Ein Thread ist kaum mehr als einige Prozessorregister und ein eigener Stackbereich, während an einem Prozess noch ungezählte Tabellen für MMU-Konfiguration, offene Dateien, etc. hängen.
Beim kommerziellen Chorus-System hat man diese Trennung zwischen Speicherverwaltung und Kontrollflußverwaltung auch begrifflich deutlich machen wollen:
Ein Kontrollfluß ist bei Chorus ein Thread, der zugehörige Kontext heißt Actor und ein Actor mit
mindestens einem Thread bildet einen Prozess.
Die Kommunikation und der Datentausch zwischen Threads sind fast ohne Aufwand möglich:
Da Threads im selben Adreßraum liegen, können sie auf dieselben gemeinsamen Variablen zugreifen, ohne auf langsame und aufwendige Mechanismen zur Prozesskommunikation zurückgreifen zu müssen.&lt;/p&gt;
&lt;h2 id=&#34;daten-über-die-grenze-schaffen&#34;&gt;
    &lt;a href=&#34;#daten-%c3%bcber-die-grenze-schaffen&#34;&gt;
	Daten über die Grenze schaffen
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Bei Prozessen, die in verschiedenen, durch die Schutzmechanismen des Betriebssystems getrennten Adreßräumen liegen, sind der Datentausch und die Kommunikation untereinander schon aufwendiger.
Einem gemeinsamen Adreßraum am nächsten kommt noch &amp;ldquo;shared memory&amp;rdquo;.
Dabei wird eine Speicherseite, die verschiedene Variablen enthalten kann, in die Adreßräume der beteiligten Kommunikationspartner eingeblendet.
Diese sind allerdings voll verantwortlich für die Regelung des Zugriffs auf diese Speicherbereiche, die Freigabe, wenn sie nicht mehr benutzt werden, etc.&lt;/p&gt;
&lt;p&gt;Viele Betriebssysteme stellen deswegen höher entwickelte, aber auch langsamere Kommunikationsmöglichkeiten zur Verfügung.
Am häufigsten findet sich ein Message-System, bei dem eine Art FIFO-Struktur realisiert wird.
Jeder Prozess hat, wenn er Nachrichten entgegennehmen möchte, einen sogenannten Port, an den andere Prozesse Nachrichten senden können.
Treffen die Nachrichten schneller ein, als der Prozess sie abarbeiten kann, bildet sich am Port eine Queue mit FIFO-Struktur.
Der empfangende Prozess arbeitet die Nachrichten jetzt in der Reihenfolge ab und sendet die Antworten an die Absender zurück.&lt;/p&gt;
&lt;p&gt;Hier kann das Betriebssystem schon einen guten Teil der Zugriffsregelung, der Speicherverwaltung und der Adreßauflösung übernehmen.
Wenn der Message-Mechanismus nämlich allgemein genug implementiert wird, muß der Message-Port des Empfängers nicht unbedingt auf der eigenen Maschine sein, sondern kann sich irgendwo im Netz befinden.
Ist der Empfänger lokal erreichbar, kann die Nachricht ohne Kopieren einfach in seinen Adreßbereich eingeblendet werden.
Andernfalls muß sie &amp;ldquo;by value&amp;rdquo; über das Netz kopiert werden.
Der Benutzer des Message-Systems merkt davon nichts, für ihn sind diese lästigen Details verborgen.
Das geht bei Chorus dann sogar soweit, daß Ports von einem Prozess zu einem anderen migrieren können, ohne daß sendende Prozesse von diesem Wechsel des Empfängers etwas merken.
Derartige Features erleichtern dem Programmierer von &amp;ldquo;fault tolerant systems&amp;rdquo; die Arbeit natürlich ungemein.&lt;/p&gt;
&lt;p&gt;Noch viel wichtiger als ein Mechanismus zur Kommunikation zwischen Prozessen ist jedoch, daß ein einheitliches, erweiterbares Format zum Datentausch besteht.
Es genügt nicht, daß das Betriebssystem Dienste zum Verschieben von Bytes zwischen einem oder mehreren Prozessen zur Verfügung stellt.
Der Empfänger muß auch in der Lage sein, diese Bytes als eine bestimmte Datenstruktur, etwa einen Bildausschnitt oder einen Text mit Steuerinformationen, zu deuten.
Wenn das Betriebssystem ein durch Subklassen erweiterbares Format für die verschiedenen am häufigsten auftretenden Datentypen bereitstellt, leistet es einen wesentlichen Teil zur Vereinheitlichung der Datenformate der Applikationen, die auf diesem Betriebssystem ablaufen.&lt;/p&gt;
&lt;p&gt;Wichtig für die Funktionsfähigkeit eines solchen Datenformates ist, und das soll noch einmal besonders herausgestellt werden, daß es von seinem Benutzer unter Wahrung der Abwärtskompatibilität erweiterbar ist.
Ein Benutzer eines Textverarbeitungsformates, beispielsweise ein DTP-Programm, muß in der Lage sein, seine programmspezifischen Zusatzinformationen in einem Text abzulegen.
Andere Anwendungen, die dieses Textformat lesen können, müssen trotzdem in der Lage sein, die Standardattribute eines Textes aus so einer Datei herauszulesen und die Nichtstandardattribute unverändert weiter zu kopieren.
Eine Anwendung, die ein zusammengesetztes Format schreibt, z.B. eine Animation oder ein Text mit Bildern, muß dies in einer Art und Weise tun können, die es anderen Anwendungen erlaubt, die Komponenten dieser Daten (etwa Einzelbilder) gezielt zu lesen, zu verarbeiten und wieder in die Gesamtdatei zu integrieren.&lt;/p&gt;
&lt;p&gt;Funktionsbibliotheken, die die Arbeit mit solchen Dateiformaten unterstützen, gehören zwar nicht zu den unmittelbaren (Kern-) Dienstleistungen eines Betriebssystems, aber sie sollten auf jeden Fall zu seinem Standardfunktionsumfang gehören, um eben eine Einheitlichkeit in den Datenformaten bei den Anwendungen zu begünstigen.&lt;/p&gt;
&lt;h2 id=&#34;einheitlichkeit---das-zweite-ziel&#34;&gt;
    &lt;a href=&#34;#einheitlichkeit---das-zweite-ziel&#34;&gt;
	Einheitlichkeit - das zweite Ziel
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Einheitlichkeit beim Zugriff auf die vom System bereitgestellten Dienste zu ermöglichen, ist, wie bereits am Anfang dieses Textes dargestellt, neben der Verteilung von Ressourcen eine der Hauptaufgaben eines Betriebssystems.
Ziel soll es sein, Anwendungen eine virtualisierte Umgebung bereitzustellen, die zwar die Nutzung der speziellen Möglichkeiten dieses konkreten Systems möglichst wenig einschränkt, aber zugleich eine einheitliche, virtuelle Maschine über die Grenzen verschiedener Systemkonfigurationen oder gar verschiedener Hardwareplattformen hinweg ermöglicht.&lt;/p&gt;
&lt;p&gt;Betriebssysteme wie UNIX und seine Abkömmlinge tun dies beispielsweise, in dem sie den meisten Systemdiensten das Dateiparadigma überstülpen:
Pipelines, zeichen- und blockorientierte Geräte, Querverweise auf andere Dateien, Netzwerkdienste - alles dies ist als Eintrag im hierarchischen Namensraum des Dateisystems zu finden.&lt;/p&gt;
&lt;p&gt;In Mach, aber auch in Plan9 und in den neuesten Versionen von UNIX, ist dieses Konzept noch  Verallgemeinert worden, indem von der Möglichkeit Gebrauch gemacht wurde, die unterschiedlichsten Typen von Dateisystemen in den Namensraum zu integrieren.
So gibt es bei System V Rel. 4 ein &lt;code&gt;/proc&lt;/code&gt;-Dateisystem, in dem die zur Zeit im Rechner laufenden Prozesse als Dateieinträge sichtbar gemacht werden.&lt;/p&gt;
&lt;p&gt;Amoeba, ein experimentelles Betriebssystem von Tanenbaum, treibt es jedoch auf die Spitze.
In Amoeba sind alle Dienste - also das Bereitstellen der Informationen in einer Datei, Pipelines, Prozesskommunikation, etc. - unter einer Kennung zu erreichen, die das jeweils angesprochene Objekt (die Datei, den Prozess, &amp;hellip;) eindeutig identifiziert.
Diese Kennung beinhaltet zugleich die Kodierung der Zugriffsrechte, die Adresse des Objektes im System und noch einige Informationen mehr.
Die vom Betriebssystem verwalteten Objekte werden durch einen Directory-Service miteinander zu einer Struktur verknüpft, die nicht mehr auf die baumartige Hierarchie eines UNIX-Dateisystems beschränkt ist, sondern jeden beliebigen, gerichteten Graphen modellieren kann.
Da der Directory-Service selbst wieder ein Objekt im Amoeba-System ist, ergibt sich, ähnlich wie beim UNIX-Dateisystem, eine interessante, rekursiv definierte Struktur.&lt;/p&gt;
&lt;p&gt;Eine andere Möglichkeit der Virtualisierung ist die Abstraktion von einem konkreten Gerät zu seinen Möglichkeiten.
In UNIX gibt es zum Beispiel die curses-Bibliothek, die es ermöglicht, ein Terminal unabhängig von den Steuercodes, die es verwendet, zu programmieren.
Windows, OS/2, AmigaDOS und andere Betriebssysteme leisten ähnliches bei der Ansteuerung von Druckern.
Statt daß die Anwendung einem bestimmten Drucker an der parallelen Schnittstelle einen bestimmten Steuercode zum Einschalten von Fettschrift zu sendet, bittet sie den Druckertreiber, den vom Anwender gewünschten Drucker in Fettschrift umzustellen, falls der Drucker das kann.
Eine austauschbare Komponente des Betriebssystems, ein Gerätetreiber, stellt jetzt fest, ob der Drucker diese Funktion hat, und veranlaßt die für den konkreten angeschlossenen Drucker passenden  Maßnahmen an einem weiteren untergeordneten Gerätetreiber für die Druckerschnittstelle.
Dies kann der Treiber für die parallele oder die serielle Schnittstelle sein, aber auch der SCSI- oder der Ethernet-Treiber für einen Drucker im Netz.
Die &amp;ldquo;passenden Maßnahmen für den konkreten Drucker&amp;rdquo; können die Generierung von fünf ASCII-Steuerzeichen zur Umschaltung auf Fettdruck sein oder das Berechnen eines neuen Fonts und das Laden dieses Zeichensatzes auf den Drucker.
In jedem Fall bekommt die Anwendung die von ihr gewünschte Dienstleistung, ohne überhaupt etwas von den Aktivitäten hinter den Kulissen zu merken und ohne daß der Hersteller der Anwendung bei jedem Update mehrere Disketten mit Gerätetreibern mitliefern muß.&lt;/p&gt;
&lt;h2 id=&#34;das-betriebssystem-der-zukunft&#34;&gt;
    &lt;a href=&#34;#das-betriebssystem-der-zukunft&#34;&gt;
	Das Betriebssystem der Zukunft?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Das Betriebssystem der Zukunft, egal ob es jetzt OS/2, Windows oder UNIX heißen wird, wird mit den heute verbreiteten Systemen, die kaum mehr als dynamisch linkbare Bibliotheken von Ein-/Ausgabefunktionen sind, wenig gemeinsam haben.
Statt dessen wird es halb-experimentellen Systemen wie Mach, Plan9 oder Amoeba ähnlich sehen.
Es wird einen kleinen Kern mit den notwendigsten Funktionen zum Multitasking und Message Passing haben und eine große Zahl von Standardserverprozessen für die unterschiedlichen Systemdienste bereitstellen.
Zu diesen Systemdiensten wird das Betreiben von Geräteabstraktionen (Standarddruckern, einheitlich steuerbaren Grafikbildschirmen) ebenso gehören wie das Bereitstellen komplexer Bibliotheksfunktionen über Serverprozesse mit eigenem Kontrollfluß (etwa die Konvertierung von Datenformaten oder eine Bibliothek mit Funktionen für grafische Benutzerführung).&lt;/p&gt;
&lt;p&gt;Der Preis für die Funktionalität: Mehr Megabytes, mehr Megaherz, mehr Megapixel.&lt;/p&gt;
&lt;h2 id=&#34;glossar&#34;&gt;
    &lt;a href=&#34;#glossar&#34;&gt;
	Glossar
    &lt;/a&gt;
&lt;/h2&gt;
&lt;dl&gt;
&lt;dt&gt;Kernel:&lt;/dt&gt;
&lt;dd&gt;Der Kernel ist das eigentliche Betriebssystem. Moderne Systeme haben die Anzahl der Funktionen im Kernel auf das allernotwendigste reduziert. Man redet dann von einem Microkernel.&lt;/dd&gt;
&lt;dt&gt;Gerätetreiber:&lt;/dt&gt;
&lt;dd&gt;Geräteabhängiges Treiberprogramm für ein Peripheriegerät, oft Bestandteil des Kernels.&lt;/dd&gt;
&lt;dt&gt;Thread:&lt;/dt&gt;
&lt;dd&gt;Kontrollflußbestandteil eines Prozesses: CPU-Register, Stack, Zustand, etc.&lt;/dd&gt;
&lt;dt&gt;Actor:&lt;/dt&gt;
&lt;dd&gt;Bezeichung im Betriebssystem Chorus für den Kontext eines Prozesses, der nicht mit dem Thread zusammenhängt: MMU-Register, Dateizeiger, etc.&lt;/dd&gt;
&lt;dt&gt;Prozess:&lt;/dt&gt;
&lt;dd&gt;Ein Actor mit mindestens einem Thread bildet einen Prozess.&lt;/dd&gt;
&lt;dt&gt;Image:&lt;/dt&gt;
&lt;dd&gt;Speicherabbild eines Prozesses.&lt;/dd&gt;
&lt;dt&gt;Virtual Memory:&lt;/dt&gt;
&lt;dd&gt;Erweitern des Speicherbereiches, der einem Prozess zur Verfügung steht, durch für den Prozess transparentes Auslagern von Prozessen (oder Prozessteilen) auf einen Hintergrundspeicher durch Swapping oder Paging.&lt;/dd&gt;
&lt;dt&gt;Swapping:&lt;/dt&gt;
&lt;dd&gt;Ein-/Auslagern ganzer Prozesse in einen speziellen Plattenbereich (swap area) bei Speicherknappheit.&lt;/dd&gt;
&lt;dt&gt;Demand Paging:&lt;/dt&gt;
&lt;dd&gt;Ein-/Auslagern von Prozessteilen fester Größe (Pages) in einen speziellen Plattenbereich bei Speicherknappheit.&lt;/dd&gt;
&lt;dt&gt;PMMU:&lt;/dt&gt;
&lt;dd&gt;Paged Memory Management Unit; Hardware zum Abbilden virtueller Prozessadressen auf physikalische Speicheradressen.&lt;/dd&gt;
&lt;dt&gt;Working Set:&lt;/dt&gt;
&lt;dd&gt;Der Teil eines Prozesses, der aus Effizienzgründen in physikalischem RAM gehalten werden sollte, weil der laufende Prozess ständig Adressen aus dem Working Set referenziert.&lt;/dd&gt;
&lt;dt&gt;Treshing:&lt;/dt&gt;
&lt;dd&gt;Dramatischer Leistungsabfall des Systems um einige Zehnerpotenzen, wenn wegen Speicherknappheit Teile der Working Sets von aktiven Prozessen ausgelagert werden.&lt;/dd&gt;
&lt;dt&gt;Server-Client Modell:&lt;/dt&gt;
&lt;dd&gt;Art der Betriebssystemarchitektur, bei der die Dienste des Systems von Serverprozessen angeboten werden. Der Client sendet eine Nachricht mit einer Dienstanforderung an den Server, der die gewünschte Funktion asynchron ausführt und das Ergebnis zurücksendet.&lt;/dd&gt;
&lt;dt&gt;Semaphore:&lt;/dt&gt;
&lt;dd&gt;Flag, das den Zugriff mehrere Prozesse auf eine Datenstruktur regelt.&lt;/dd&gt;
&lt;dt&gt;Message passing:&lt;/dt&gt;
&lt;dd&gt;Paradigma beim Aufruf von Betriebssystemfunktionen: Die Parameter eines Dienstaufrufes werden dem Dienstanbieter in einer Nachricht übermittelt. Der Dienstanbieter ist ein eigenständiger Prozess, der die Anforderung unabhängig und asynchron zum Dienstaufrufer bearbeitet.&lt;/dd&gt;
&lt;dt&gt;Time-Slice:&lt;/dt&gt;
&lt;dd&gt;Zeitscheibe; die Zeiteinheit, die ein Prozess maximal ohne Unterbrechung die CPU in Anspruch nehmen kann.&lt;/dd&gt;
&lt;dt&gt;Preemptive Multitasking:&lt;/dt&gt;
&lt;dd&gt;Verfahren, bei dem Prozesse die CPU auch ohne eigenes Zutun nach Ablauf der Zeitscheibe verlieren können.&lt;/dd&gt;
&lt;dt&gt;Cooperative Multitasking:&lt;/dt&gt;
&lt;dd&gt;Verfahren, bei dem Prozesses die CPU nur durch expliziten oder impliziten (durch Aufruf einer Systemfunktion) Aufruf des Schedulers verlieren können.&lt;/dd&gt;
&lt;dt&gt;Scheduler:&lt;/dt&gt;
&lt;dd&gt;Betriebssystemteil, der bestimmt, nach welchen Kritierien die Zeitscheiben den einzelnen Prozessen zugeteilt werden.&lt;/dd&gt;
&lt;dt&gt;Round-Robin:&lt;/dt&gt;
&lt;dd&gt;Scheduling-Algorithmus, bei dem alle lauffähigen Prozesse dieselbe Anzahl von Zeitscheiben zugeteilt bekommen.&lt;/dd&gt;
&lt;dt&gt;Priority-Aging:&lt;/dt&gt;
&lt;dd&gt;Eigenschaft von Scheduling-Algorithmen. Prozesse, die längere Zeit keine Zeitscheibe zugeteilt bekommen haben, werden in der Priorität temporär heraufgestuft.&lt;/dd&gt;
&lt;dt&gt;Wall Clock Time:&lt;/dt&gt;
&lt;dd&gt;Reale (gestoppte) Laufzeit eines Prozesses.&lt;/dd&gt;
&lt;dt&gt;Cpu Time:&lt;/dt&gt;
&lt;dd&gt;Zeit, die ein Prozess tatsächlich ablaufend auf der CPU verbracht hat. Typischerweise viel weniger als ein Zehntel der wall clock time.&lt;/dd&gt;
&lt;/dl&gt;
</description>
    </item>
    
  </channel>
</rss>

