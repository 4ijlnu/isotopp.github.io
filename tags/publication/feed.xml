<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>publication on Die wunderbare Welt von Isotopp</title>
    <link>https://blog.koehntopp.info/tags/publication.html</link>
    <description>Recent content in publication on Die wunderbare Welt von Isotopp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 13 Nov 2021 08:40:05 +0000</lastBuildDate><atom:link href="https://blog.koehntopp.info/tags/publication/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>TCP/IP Technik</title>
      <link>https://blog.koehntopp.info/1993/04/01/tcpip-technik.html</link>
      <pubDate>Thu, 01 Apr 1993 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/1993/04/01/tcpip-technik.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#tcpip-technik&#34;&gt;TCP/IP Technik&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#smtp&#34;&gt;Ein SMTP Dialog&lt;/a&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;aus »c&amp;rsquo;t - Magazin für Computertechnik«, Ausgabe 4/93&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;tcpip-technik&#34;&gt;
    &lt;a href=&#34;#tcpip-technik&#34;&gt;
	TCP/IP Technik
    &lt;/a&gt;
&lt;/h1&gt;
&lt;h4 id=&#34;rechner-miteinander-zu-vernetzen-ist-heutzutage-kein-problem-mehr-so-scheint-es-um-die-rechner-im-büro-zu-verbinden-nimmt-man-ethernet-arcnet-oder-token-ring-für-die-anbindung-von-außenstellen-stehen-modems-datx-p-und-neuerdings-auch-isdn-zur-verfügung-und-um-mal-eben-einige-daten-von-seinem-mac-auf-den-atari-zu-überspielen-legt-man-ein-nullmodemkabel-alle-diese-netze-haben-ihre-stärken-und-schwächen-und-dementsprechend-ihre-einsatzgebiete&#34;&gt;
    &lt;a href=&#34;#rechner-miteinander-zu-vernetzen-ist-heutzutage-kein-problem-mehr-so-scheint-es-um-die-rechner-im-b%c3%bcro-zu-verbinden-nimmt-man-ethernet-arcnet-oder-token-ring-f%c3%bcr-die-anbindung-von-au%c3%9fenstellen-stehen-modems-datx-p-und-neuerdings-auch-isdn-zur-verf%c3%bcgung-und-um-mal-eben-einige-daten-von-seinem-mac-auf-den-atari-zu-%c3%bcberspielen-legt-man-ein-nullmodemkabel-alle-diese-netze-haben-ihre-st%c3%a4rken-und-schw%c3%a4chen-und-dementsprechend-ihre-einsatzgebiete&#34;&gt;
	Rechner miteinander zu vernetzen ist heutzutage kein Problem mehr, so scheint es. Um die Rechner im Büro zu verbinden, nimmt man Ethernet, ARCNET oder Token-Ring; für die Anbindung von Außenstellen stehen Modems, Datx-P und neuerdings auch ISDN zur Verfügung und um mal eben einige Daten von seinem Mac auf den Atari zu überspielen, legt man ein Nullmodemkabel. Alle diese Netze haben ihre Stärken und Schwächen und dementsprechend ihre Einsatzgebiete.
    &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;Leider haben diese Netze aber auch alle eine unterschiedliche Schnittstelle der Anwendung gegenüber.
Das fängt schon bei den Adressen an (Datex-P Adressen sehen anders aus als Adressen in einem Ethernet) und hört erst wieder bei den grundlegenden Konzepten des jeweiligen Netzwerks auf.
Wie schön wäre es, würden alle diese Netzwerke zusammenarbeiten können, sodaß man Daten auf dieselbe Art und Weise vom Wohnzimmer in den Hobbykeller wie von einem Ende der Welt zum anderen verschicken könnte, wenn man die verschiedenen Netzwerke miteinander vernetzen könnte.&lt;/p&gt;
&lt;p&gt;Genau diese Anforderung erfüllen die TCP/IP-Protokolle, die im Internet verwendet werden.&lt;/p&gt;
&lt;p&gt;Was kann TCP/IP?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gibt einem Unabhängigkeit von Hardware des unterliegenden Trägernetzes.&lt;/li&gt;
&lt;li&gt;gibt einem netzwerkweit einheitliche Adressen.&lt;/li&gt;
&lt;li&gt;präsentiert dem Programmierer eine einheitliche, geschlossene API.&lt;/li&gt;
&lt;li&gt;bietet einen Baukasten von standardisierten High-Level-Protokollen für die verschiedensten Netzwerkdienste.&lt;/li&gt;
&lt;li&gt;ist eine offene Protokollfamilie, die unabhängig von Herstellern entwickelt wurde.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Um die Entwicklung und das Verständnis von Rechnernetzen zu erleichtern, hat die International Standards Organisation (ISO) ein Architekturmodell für Rechnernetze entwickelt, das OSI
Referenzmodell.
Dieses Modell teilt den Prozeß des Verschickens von Daten über ein Rechnernetz in 7 übereinanderliegende Schichten ein, die einander zuarbeiten und jede für sich eine bestimmte Abstraktionsebene kennzeichnen.
Weil diese Schichten in der Abbildung einen übereinander liegen, redet man oft auch von einem
Protokollstapel.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/osimodell.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 1: OSI Referenzmodell&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Wenn Daten zwischen zwei Rechnern übertragen werden, erscheint es im Programmiermodell so, als würden zwei gleiche Schichten auf verschiedenen Rechnern miteinander kommunizieren.
Die Details der darunterliegenden Abstraktionsebenen werden vor den darüberliegenden Schichten verborgen.
Beispielsweise ist es die Aufgabe der Schicht 2, eine fehlerfreie Verbindung zwischen zwei benachbarten Netzknoten zur Verfügung zu stellen.
Das bedeutet, dass die Schicht 3 sich mit den Details der Datenübertragung zwischen zwei Maschinen nicht mehr zu befassen hat.
Sie kann mit der Schicht 3 der Gegenstelle kommunizieren, ohne sich um Einzelheiten der Datenübertragung und möglicherweise auftretende Fehler kümmern zu müssen.&lt;/p&gt;
&lt;p&gt;In Wirklichkeit besteht jedoch die einzige Verbindung zwischen zwei Rechnern auf der Ebene 1, der physikalischen Schicht.
Wenn Daten zu senden sind, werden sie von einer Schicht zur jeweils darunterliegenden Schicht weitergereicht.
Damit die einzelnen Schichten voneinander unabhängig sind müssen die Schnittstellen zwischen den Schichten natürlich bekannt und definiert sein.
Diese Art von Modulbildung erleichtert die Wartung und Entwicklung von neuen Netzwerkprotokollen und die Fehlersuche.&lt;/p&gt;
&lt;h2 id=&#34;internetworking-protocol-ip&#34;&gt;
    &lt;a href=&#34;#internetworking-protocol-ip&#34;&gt;
	Internetworking Protocol (IP)
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Auch TCP/IP hat einen ähnlichen, schichtweisen Aufbau, wenn es auch nicht so vielfach unterteilt ist wie das OSI-Modell;
üblicherweise unterscheidet man vier Schichten.
Die Grundlage des TCP/IP-Protokollturms bildet die Netzwerkschicht, deren Aufgabe der eigentliche Datentransport ist.&lt;/p&gt;
&lt;p&gt;TCP/IP ist kein Netzwerkprotokoll, das von der Hardware direkt verstanden wird.
Normalerweise werden TCP/IP-Daten immer über ein vorhandenes Trägernetz, etwa Ethernet oder X.25, übertragen, denn die Aufgabe von TCP/IP ist es ja gerade, solche vorhandenen Netzwerke zu vereinheitlichen.
Im OSI-Modell deckt die Netzwerkschicht also die Hardwareschichten 1 und 2 sowie in einigen Fällen auch noch Teile der Schicht 3 ab.
Auf der Netzwerkschicht aufbauend liegt die Internet-Schicht, die die erste Abstraktionsschicht von einem konkreten Netzwerk darstellt.
Damit ist das Internet-Protokoll, kurz IP, der Kern von TCP/IP, denn es stellt den grundlegenden Dienst des Netzes zur Verfügung:
den Versand von Datenpaketen, sogenannten Datagrammen, über verschiedene Netze hinweg.
Die Netzwerkschicht hat keine Information darüber, von welcher Art die Daten sind, die sie befördert:
Für eine Ethernetkarte sind die ankommenden Daten eben einfach nur Daten, die vom Netz kommen.
Der Kartentreiber interpretiert einen Teil dieser Daten als IP-Header und den Rest als Datenteil eines IP-Paketes.
Auf diese Weise ist der IP-Header innerhalb eines Ethernet-Paketes gewissermaßen eingekapselt.
Aber auch das IP-Paket selbst enthält selbst wieder ein Datenpaket für eine höhere Protokollebene, dessen Header auf der IP-Ebene als Bestandteil der Daten erscheint.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/datenkapselung.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 2: Kapselung von Daten in ein Protokollpaket der nächstniederen Schicht.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;IP ist ein verbindungsloses Protokoll, das bedeutet, IP kennt keinen Verbindungszustand.
Es ist also nicht notwendig, eine IP-Verbindung zu einem Rechner zu &amp;ldquo;öffnen&amp;rdquo;, bevor man Daten zu diesem Rechner senden kann, sondern es genügt, das IP-Paket einfach abzusenden.
Bei einem verbindungsorientierten Protokoll wird beim Öffnen einer Verbindung getestet, ob der Zielrechner überhaupt erreichbar ist.
Ein verbindungsloses Protokoll macht das nicht und kann demnach auch nicht garantieren, daß ein Datenpaket überhaupt beim Empfänger ankommt.
IP garantiert auch nicht, daß ein von einem einmal abgeschickten Datenpaket nur eine Kopie beim Empfänger ankommt oder daß in einer Reihenfolge abgeschickte Datenpakete auch wieder in dieser Reihenfolge empfangen werden.
Dadurch ist es möglich, daß längere Transfers von einem Rechner zum anderen, die über mehrere Zwischenrechner laufen, beim Ausfall eines dieser Rechner dynamisch neu konfiguriert werden.
Irgendwann während der Übertragung bricht ein Übertragungsweg zusammen und es wird ein neuer Weg zum Ziel gesucht und benutzt.
Da der neue Weg zeitlich länger oder kürzer sein kann als der alte, kann man keine allgemein gültigen Aussagen darüber machen, in welcher Reihenfolge IP-Pakete beim Empfänger eintreffen.
Es kann auch sein, daß bei dieser Umschalterei IP-Pakete verloren gehen oder verdoppelt werden.
Alle diese Unebenheiten auszubügeln überläßt IP anderen, höherliegenden Schichten im Protokollturm.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/ippaket.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 3: Aufbau eines Internet Protocol (IP) Headers. Eine Zeile stellt ein Langwort (4 Byte) dar. Das höchstwertigste Byte eines Langwortes wird als erstes übertragen (Network Byte Order).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Die Hauptaufgabe von IP ist es also, die Unterschiede zwischen den verschiedenen, unterliegenden Netzwerkschichten zu verbergen und eine einheitliche Sicht auf die verschiedensten Netzwerktechnologien zu präsentieren.
Dazu gehören die Einführung eines einheitlichen Adressierungsschemas und eines Fragmentierungsmechanismus, der es ermöglicht, große Datenpakete durch Netze mit kleiner maximaler Paketgröße zu senden.&lt;/p&gt;
&lt;p&gt;Jedes IP-Paket enthält zwei Adressen in Form von 32 Bit Worten:
Die Absender- und die Empfängeradresse.
Eine Internet-Adresse wird meist in Form von vier, durch Punkte getrennten Bytes notiert, man spricht in diesem Fall von der &amp;ldquo;dotted quad&amp;rdquo;-Schreibweise.
Um die Zustellung von IP-Paketen zu vereinfachen, unterteilt man die Adresse in zwei Teile:
Den Netzwerkteil und den Rechnerteil.
Ein Router muß, um ein Datenpaket zustellen zu können, nur den Netzwerkteil einer Adresse erkennen.
Erst im Zielnetzwerk wird der Rechnerteil einer Adresse ausgewertet.
Um den verschiedenen Anforderungen gerecht zu werden, was die Größe von Netzwerken angeht, unterscheidet man verschiedene Aufteilungen der 32 Adreßbits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bei Netzwerken der Klasse A ist das erste Bit der IP-Adresse 0.
Die folgenden 7 Bit bilden den Netzwerkteil der Adresse und die restlichen 24 Bits bilden den Rechnerteil.
Es kann also weniger als 128 verschiedene Klasse A Netzwerke geben, aber jedes dieser Netze aus Millionen von Rechnern bestehen.
Ein typischer Verteter ist zum Beispiel das amerikanische MILNET, das sich über das ganze Land
erstreckt.&lt;/li&gt;
&lt;li&gt;bei Netzwerken der Klasse B fängt die Adresse mit der Bitfolge &amp;ldquo;10&amp;rdquo; an.
Die folgenden 14 Bit stellen den Netzwerkteil der Adresse dar, die restlichen 16 Bit den Rechnerteil.
Es kann also Tausende von Klasse B Netzen mit jeweils tausenden von Rechnern geben.
Ein typischer Vertreter ist das Campusnetzwerk einer großen Universität.&lt;/li&gt;
&lt;li&gt;bei Netzwerken der Klasse C fängt die Adresse mit der Bitfolge &amp;ldquo;110&amp;rdquo; an.
Die folgenden 21 Bit stellen den Netzwerkteil der Adresse dar, die restlichen 8 Bit den Rechnerteil.
Es kann also Millionen von Netzwerken der Klasse C geben, von denen jedes weniger als 256 Rechner beherbergt. Standardmäßigt bekommt man ein Klasse C Netz, wenn man ein Netzwerk beim NIC anmeldet.&lt;/li&gt;
&lt;li&gt;fängt eine Adresse mit den Bits &amp;ldquo;111&amp;rdquo; an, so hat sie eine Spezialbedeutung.
Manchmal werden solche Adressen als Klasse D Adressen bezeichnet.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Höherliegende Protokolle und Dienste bieten dem IP-Benutzer Mechanismen, die Namen Internet-Adressen zuordnen und umgekehrt.&lt;/p&gt;
&lt;p&gt;Weil das Internet-Protokoll wie bereits erwähnt normalerweise immer auf einem Trägernetzwerk aufsetzt, muß es noch eine andere Eigenschaft der unterliegenden Netzwerkschicht verbergen:
Normalerweise existiert bei allen Netzwerken eine maximale Größe, die ein Datenpaket haben kann.
Im IP-Jargon nennt man diese Grenze die &amp;ldquo;maximum transmisson unit&amp;rdquo;, MTU.
Natürlich ist diese Obergrenze je nach verwendeter Trägertechnik unterschiedlich.
Die Internet-Schicht teilt IP-Pakete, die größer als die MTU des verwendeten Netzwerks in kleinere Stücke, sogenannte Fragmente auf.
Auf dem Zielrechner werden diese Fragmente dann wieder zu vollständigen IP-Paketen zusammengesetzt, bevor sie an die darüberliegenden Protokolle weiter gegeben werden.&lt;/p&gt;
&lt;p&gt;Welches darüberliegende Protokoll der Transportschicht das Datenpaket bekommt, steht im &amp;ldquo;Protokoll&amp;rdquo;-Feld eines jeden IP-Paketes.
Jedes Protokoll der Transportschicht bekommt eine eindeutige Identifikationsnummer zugewiesen, anhand derer der IP-Treiber entscheiden kann, wie weiter mit dem Paket zu verfahren ist.
Eines der wichtigsten Protokolle der Transportschicht ist TCP.&lt;/p&gt;
&lt;h2 id=&#34;was-leistet-tcp&#34;&gt;
    &lt;a href=&#34;#was-leistet-tcp&#34;&gt;
	Was leistet TCP?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Die Aufgabe von TCP ist es, die oben geschilderten Defizite von IP zu verbergen.
Für den TCP-Benutzer soll es nicht mehr sichtbar sein, daß die darunterliegenden Protokollschichten Datenpakete versenden, sondern stattdessen soll der Benutzer mit einem Bytestrom wie bei einer normalen Datei arbeiten können.
TCP garantiert das Ankommen, die Einmaligkeit und die Reihenfolge der Daten.
Zusätzlich multiplext TCP die Verbindung zwischen zwei Rechnern:
Während auf der Internet-Schicht nur eine Verbindung zur Zeit zwischen zwei Rechnern bestehen kann, teilt TCP diese Verbindung in viele virtuelle Kanäle auf.&lt;/p&gt;
&lt;p&gt;Im Gegensatz zu IP ist TCP verbindungsorientiert.
Das muß so sein, denn TCP-Verbindungen sollen ja für den Benutzer wie Dateien zu handhaben sein.
Das bedeutet, eine TCP-Verbindung wird wie eine Datei geöffnet und geschlossen und man kann seine Position innerhalb des Datenstromes bestimmen, genau wie man bei einer Datei die Position des Dateizeigers angeben kann.&lt;/p&gt;
&lt;p&gt;Auch TCP sendet die Daten in größeren Einheiten, um den Verwaltungsaufwand durch Header und Kontrollinformation klein zu halten.
Im Gegensatz zu den IP-&amp;ldquo;Paketen&amp;rdquo; bezeichnet man in die Einheiten der Transportschicht als &amp;ldquo;Segmente&amp;rdquo;.
Jedes gesendete TCP-Segment hat eine eindeutige Folgenummer, die die Position seines ersten Bytes im Bytestrom der Verbindung angibt.
Anhand dieser Nummer kann die Reihenfolge der Segmente korrigiert werden und doppelt angekommene  Segmente können aussortiert werden.
Da die Länge des Segmentes aus dem IP-Header bekannt ist, können auch Lücken im Datenstrom entdeckt werden und der Empfänger kann verlorengegangene Segmente neu anfordern.&lt;/p&gt;
&lt;p&gt;Beim Öffnen einer TCP-Verbindung werden zwischen beiden Kommunikationspartnern Kontrollinformationen ausgetauscht, die sicherstellen, daß der Endpunkt der Verbindung existiert
und Daten annehmen kann.
Dazu schickt der Sender ein Segment mit der Aufforderung, die Folgenummern zu synchronisieren.
Der Empfänger weiß jetzt, daß der Sender eine Verbindung öffnen möchte und an welcher Position im Datenstrom der Sender anfangen wird zu zählen.
Der Empfänger bestätigt den Empfang der Nachricht und legt seinerseits eine Folgenummer für Übertragungen in Gegenrichtung fest.
Der Sender bestätigt nun seinerseits den Empfang der Folgenummer von B und beginnt dann mit der Übertragung von Daten.
Diese Art des Austausches von Kontrollinformation, bei der jede Seite die Aktionen der Gegenseite bestätigen muß, ehe sie wirksam werden können, heisst &amp;ldquo;Dreiweg-Handshake&amp;rdquo;.
Auch beim Abbau einer Verbindung wird auf diese Weise sichergestellt, daß beide Seiten alle Daten korrekt und vollständig empfangen haben.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/tcppaket.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;Bild 4: Aufbau eines Transmission Control Protocol (TCP) Headers.*&lt;/p&gt;
&lt;p&gt;Während der Übertragung kann der Empfänger dem Sender im Feld &amp;ldquo;Fenstergröße&amp;rdquo; signalisieren, für wieviele Bytes er noch Pufferkapazität frei hat.
Der Sender darf nicht mehr Daten senden, als der Empfänger auf diese Weise freigegeben hat, bis er eine weitere Empfangsbestätigung mit einer neu festgelegten Fenstergröße vom Sender erhält.
Auf diese Weise kann der Empfänger den Datenfluß vom Sender nach Wunsch dosieren.
Wenn der Empfänger dem Sender eine Fenstergröße von Null Byte signalisiert, muß der Sender den Transfer unterbrechen, bis er eine zweite Bestätigung mit einer Fenstergröße ungleich Null bekommt.&lt;/p&gt;
&lt;p&gt;Auf einem Rechner können mehrere Prozesse zu einem Zeitpunkt TCP-Verbindungen geöffnet haben.
Die Portnummer in jedem TCP-Segment gibt an, welche virtuelle Verbindung zu welchem Prozeß gehört.
So ist es möglich, Leitungen für eine Vielzahl von Prozessen zu multiplexen.
Vom Standpunkt eines Modembenutzers aus kann man TCP/IP also in gewisser Weise als eine Art glorifiziertes ZMODEM- oder BIMODEM-Protokoll betrachten:
Es ist nicht nur eine Übertragung von Daten in beide Richtungen gleichzeitig möglich, sondern es können pro Richtung noch mehrere Verbindungen zugleich unterhalten werden.&lt;/p&gt;
&lt;p&gt;Damit die verschiedenen Schichten des Protokollturms miteinander Daten austauschen können, müssen jeweils zwei aneinanderstoßende Schichten sich jeweils über ein gemeinsames Interface einig sein.
Normalerweise sind diese Interfaces nicht interessant, weil sie für den Anwender unsichtbar sind.
Das Interface der Internet-Schicht ist zum Beispiel nur für denjenigen interessant, der TCP oder ein vergleichbares Protokoll selbst implementieren möchte.
Das Interface zwischen der Transportschicht und der Anwendungsschicht ist jedoch von besonderem Interesse, denn es stellt das Interface dar, mit dem ein Programmierer umgehen muß, der eine Anwendung schreiben möchte, die von den Möglichkeiten von TCP/IP Gebrauch macht.&lt;/p&gt;
&lt;p&gt;Leider gibt es zwei verschiedene, inkompatible APIs für TCP/IP.
Die ältere der beiden ist als &amp;ldquo;Berkeley Sockets&amp;rdquo; bekannt geworden und in BSD UNIX zusammen mit der ersten Version von TCP/IP implementiert worden.
Die andere API ist das &amp;ldquo;Transport Level Interface&amp;rdquo;, kurz TLI, von AT&amp;amp;T.
Es stellt den Versuch dar, eine generelle, TCP/IP unabhängige API für Netzwerkprogrammierung zu schaffen.
Die Namen und Parameter der TLI-Aufrufe orientieren sich dabei an der Begriffswelt der OSI.&lt;/p&gt;
&lt;p&gt;Die Grenze zwischen der Anwendungsschicht und der Transportschicht ist in den meisten Implementierungen zugleich die Grenze zwischen dem Betriebssystem und den Anwendungsprogrammen.
Im OSI-Modell ist diese Grenze in etwa die Grenze zwischen den Schichten 4 und 5.
Daher ordnet man IP meist ungefähr in die Ebene 3 und TCP ungefähr in Ebene 4 des OSI-Modells ein.
Da TCP/IP jedoch älter und einfacher als das OSI-Modell sind, kann diese Einordnung nicht genau passen.&lt;/p&gt;
&lt;h2 id=&#34;typische-tcpip-dienste&#34;&gt;
    &lt;a href=&#34;#typische-tcpip-dienste&#34;&gt;
	Typische TCP/IP Dienste
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Auf TCP/IP setzen viele verschiedene Dienste auf, von denen die meisten ein eigenes, anwendungsspezifisches Protokoll zwischen ihrem Server und den verschiedenen Client-Programmen verwenden.
Der UNIX-Tradition folgend kommunizieren viele dieser Anwendungen zwar in einem formalisierten Format miteinander, aber dieses Format ist meist so gehalten, daß es noch von einem Menschen ohne besondere Debugging-Werkzeug gelesen und erzeugt werden kann.&lt;/p&gt;
&lt;p&gt;Eines dieser Protokolle ist zum Beispiel das &amp;ldquo;simple mail transport protocol&amp;rdquo;, SMTP.
Es dient der synchronen Auslieferung von Electronic Mail im Internet und wird von einer ganzen Palette von Mailtransportprogrammen direkt verstanden.
Ist eine Mail zu versenden, so baut der sendende Mailer eine TCP/IP-Verbindung direkt zum Zielrechner auf.
Der physikalische Weg zu diesem Rechner muß nicht direkt vorhanden sein, aber das braucht den Absender nicht zu kümmern.
Die Internet-Schicht des Netzes wird einen Weg zum Zielrechner konstruieren, wenn es einen gibt.
Für den Mailer sieht es so aus, als hätte er eine direkte, virtuelle Verbindung zum Zielrechner.
Kommt eine Verbindung zustande, so meldet sich auf dem Zielrechner ein Hintergrundprozeß, der auf eingehende Nachrichten wartet.
Zwischen den beiden Mailern läuft dann ein SMTP-Dialog ab.
Da der Dialog aber in reinem ASCII und sogar relativ lesbar ist, kann man ihn bei Kenntnis des SMTP-Protokolls auch als Mensch simulieren.
Im Kasten &lt;a href=&#34;#smtp&#34;&gt;SMTP&lt;/a&gt;

 ist so eine Simulation eines SMTP-Dialoges zu sehen.&lt;/p&gt;
&lt;p&gt;So wie SMTP der Zustellung persönlicher Nachrichten an einzelne Personen dient, ermöglicht das NNTP-Protokoll die Verbreitung öffentlicher Nachrichten, der USENET News, im Internet.
Das FTP-Protokoll dient zur Übertragung von Dateien durch das Netz, das TELNET- und das rlogin-Protokoll ermöglichen es, Sessions auf entfernten Rechnern zu fahren und wieder andere Protokolle ermöglichen die Einrichtung von Namensverzeichnissen oder die Fernabfrage der eigenen Mail.&lt;/p&gt;
&lt;p&gt;TCP/IP ist durch das schichtweise Design ein modularer Protokollstandard.
Die einzelnen Komponenten sind in den sogenannten &amp;ldquo;Requests for Comments&amp;rdquo; (RFCs) genormt und  offengelegt.
Am Zustandekommen einer einzelnen SMTP-Verbindung über TCP über IP über Ethernet-Verbindung sind dann auch eine ganze Reihe dieser Normen beteiligt.
Das Format der übertragenen Nachricht ist in RFC 822, &amp;ldquo;Standard for the format of ARPA Internet text messages&amp;rdquo; festgelegt.
Die Nachrichten werden nach dem in RFC 821 definierten SMTP-Verfahren übertragen.
SMTP bedient sich wiederum des in RFC 793 spezifizierten TCP, das auf dem in RFC 791 und RFC  792 definierten Internet Protocol aufsetzt.
Wie Internet-Pakete auf einem Ethernet als Träger verschickt werden, ist wiederum in RFC 894 festgelegt, während RFC 826 die Zuordnung von Ethernet-Adressen zu IP-Adressen regelt.&lt;/p&gt;
&lt;p&gt;Die Universalität von TCP/IP verbirgt die Eigenheiten der unterliegenden Trägernetze vollständig.
Für einen TCP/IP-Benutzer, ja sogar für den Programmierer ist es egal, auf welche Weise der Zielrechner erreicht wird, er hat eine einheitliche Sicht auf ein riesiges, weltweites, aus
tausenden von Teilnetzen zusammengesetztes Netzwerk.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&#34;smtp&#34;&gt;
    &lt;a href=&#34;#smtp&#34;&gt;
	SMTP
    &lt;/a&gt;
&lt;/h1&gt;
&lt;h4 id=&#34;smtp-dialog-zwischen-tpkitoppointde-und-blacktoppointde&#34;&gt;
    &lt;a href=&#34;#smtp-dialog-zwischen-tpkitoppointde-und-blacktoppointde&#34;&gt;
	SMTP Dialog zwischen tpki.toppoint.de und black.toppoint.de
    &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;Von tpki.toppoint.de gesendete Zeichen sind fett gesetzt.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
220-black.toppoint.de Smail3.1.26.7 #3 ready at Wed, 9 Dec 92 00:08 
MET
220 call +49 431 676689 for operator.
&lt;b&gt;helo tpki.toppoint.de&lt;/b&gt;
250 black.toppoint.de Hello tpki.toppoint.de
&lt;b&gt;mail from: kris@tpki.toppoint.de&lt;/b&gt;
250 &amp;lt;kris@tpki.toppoint.de&gt; ... Sender Okay
&lt;b&gt;rcpt to: kris@black.toppoint.de&lt;/b&gt;
250 &amp;lt;kris@black.toppoint.de&gt; ... Recipient Okay
&lt;b&gt;data&lt;/b&gt;
354 Enter mail, end with &#34;.&#34; on a line by itself
&lt;b&gt;.&lt;/b&gt;
250 Mail accepted
&lt;b&gt;quit&lt;/b&gt;
221 black.toppoint.de closing connection
&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>TCP/IP Dienste</title>
      <link>https://blog.koehntopp.info/1993/03/01/tcpip-dienste.html</link>
      <pubDate>Mon, 01 Mar 1993 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/1993/03/01/tcpip-dienste.html</guid>
      <description>&lt;p&gt;&lt;strong&gt;für c&amp;rsquo;t - Magazin für Computertechnik, Ausgabe 3/93&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;tcpip-dienste&#34;&gt;
    &lt;a href=&#34;#tcpip-dienste&#34;&gt;
	TCP/IP Dienste
    &lt;/a&gt;
&lt;/h1&gt;
&lt;h4 id=&#34;das-größte-problem-bei-einem-artikel-über-das-internet-ist-es-zu-definieren-was-das-internet-überhaupt-ist-eigentlich-existiert-so-etwas-wie-das-internet-nämlich-überhaupt-nicht-das-ändert-natürlich-nichts-an-der-tatsache-daß-millionen-menschen-es-jeden-tag-benutzen-wie-erklärt-sich-ein-solcher-widerspruch&#34;&gt;
    &lt;a href=&#34;#das-gr%c3%b6%c3%9fte-problem-bei-einem-artikel-%c3%bcber-das-internet-ist-es-zu-definieren-was-das-internet-%c3%bcberhaupt-ist-eigentlich-existiert-so-etwas-wie-das-internet-n%c3%a4mlich-%c3%bcberhaupt-nicht-das-%c3%a4ndert-nat%c3%bcrlich-nichts-an-der-tatsache-da%c3%9f-millionen-menschen-es-jeden-tag-benutzen-wie-erkl%c3%a4rt-sich-ein-solcher-widerspruch&#34;&gt;
	Das größte Problem bei einem Artikel über das Internet ist es, zu definieren, was das Internet überhaupt ist. Eigentlich existiert so etwas wie &amp;ldquo;das Internet&amp;rdquo; nämlich überhaupt nicht. Das ändert natürlich nichts an der Tatsache, daß Millionen Menschen es jeden Tag benutzen. Wie erklärt sich ein solcher Widerspruch?
    &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;Am Besten, man beginnt am Anfang:
Ende der Siebziger Jahre hatte das amerikanische Verteidigungsminsterium Bedarf an einer Technologie, die unterschiedlichsten Computersysteme an verschiedenen Orten miteinander zu vernetzen.
Um die Möglichkeiten einer solchen Vernetzung auszuloten und die dazu notwendigen Technologien zu entwickeln und zu erproben, wurde im Jahre 1969 im Rahmen eines Forschungsprojektes ein experimentelles Computernetz ins Leben gerufen.
Schon bald zeigte sich, daß nicht nur das Verteidigungsminsterium einen Bedarf an derartiger Technik hatte.
Das ARPANET war viel erfolgreicher als ursprünglich geplant:
Nach kurzer Zeit schon begannen viele Organisationen das Netz nicht nur für experimentelle Zwecke zu nutzen, sondern verwendeten es auch für ihre tägliche Arbeit.
Auch Institutionen und Firmen, die nicht direkt an der Entwicklung von Netzwerktechnologien beteiligt waren, sondern diese einfach nur benutzen wollten, zeigten Interesse an der Vernetzung.
Daher zog man 1975 die Konsequenz und änderte den Status von ARPANET in den eines Produktionsnetzwerks, das von der Defense Communications Agency (heute die Defense Information Systems Agency) verwaltet wurde.&lt;/p&gt;
&lt;p&gt;Doch die Entwicklung des Netzes blieb damit nicht stehen.
Die heute verwendeten &lt;a href=&#34;#rfc&#34;&gt;Netzwerkprotokolle&lt;/a&gt;

, TCP und IP, stammen im Prinzip aus den frühen achtziger Jahren.
Weil das ARPANET immer stärker wuchs und zum Teil nicht zu experimenteller Arbeit, sondern immer mehr auch zu Produktionszwecken genutzt wurde, teile man es in einen Forschungsteil (ARPANET) und das MILNET auf.
Zugleich stellte man das Protokoll zwischen den zentralen Netzwerkknoten auf TCP/IP um.
Um den Umstieg zu erleichtern und auch Universitäten für die verwendete Technik zu interessieren, wurde eine frei verfügbare Implementation von TCP/IP für BSD UNIX in Auftrag gegeben und damit der Grundstein zu dem gelegt, was heute als &amp;ldquo;open systems&amp;rdquo; in aller Munde ist.
Die Rechnung ging auf: Schon mitte der achtziger Jahre begann die National Science Foundation in den Vereinigten Staaten mit dem Aufbau des NSFNET, einem Netz mit Verbindung zum ARPANET, aber auch zu regionalen Netzwerken auf gleicher Technologiebasis.&lt;/p&gt;
&lt;p&gt;Heute bezeichnet man mit dem Namen &amp;ldquo;internetwork&amp;rdquo; Netzwerk aus Teilnetzwerken der verschiedensten Technologien, die durch das darüberliegende TCP/IP zusammengebunden werden.
Die weltweite Verbindung von TCP/IP-Netzwerken, die aus dem ARPANET entstanden ist, trägt jedoch den Namen &amp;ldquo;das Internet&amp;rdquo; (mit betontem &amp;ldquo;das&amp;rdquo; und großem &amp;ldquo;I&amp;rdquo;).
Alle wichtigen staatlichen und wirtschaftlichen Institutionen in den USA sind mittlerweile auf die eine oder andere Weise mit dem Internet verbunden.
Auch in Deutschland findet, wenn auch mit mehreren Jahren Verzögerung, eine ähnliche Entwicklung statt.
So etwas wie eine einheitliche Verwaltung gibt es jedoch nicht.
Das Internet Activities Board definiert das Internet selbst dann in einem seiner Informationenpapiere auch als einen &amp;ldquo;lockeren, internationalen Zusammenschluß miteinander verbundener Netzwerke, das direkten Kontakt von Rechner zu Rechner durch freiwilliges befolgen offener Protokollstandards und -prozeduren ermöglicht.&amp;rdquo;
Diese Definition ist in der Tat schwammig genug, um einem Gebilde wie dem Internet gerecht zu werden.&lt;/p&gt;
&lt;p&gt;Ein anderer Pluspunkt von TCP/IP ist eher für den Programmierer interessant:
Die totale Unabhängigkeit der Applikation von der darunterliegenden Netzwerkebene.
Ein Programm, das in einer Internet-Umgebung läuft, muß sich nicht darum kümmern, wie es seine Datenpakete aus dem lokalen Ethernet über das Datex-P-Gateway nach Übersee und dort in das lokale Token-Ring-Netzwerk schicken muss.
Das Internet-Protokoll kümmert sich darum, die Details der verschiedenen unterliegenden Netzwerke und Transportmechanismen zu verbergen.
Es kümmert sich auch darum, die schnellste oder am wenigsten ausgelastete Route durch das Netz zu suchen.&lt;/p&gt;
&lt;p&gt;Diese Transparenz wird vom Protokoll auch an die darüberliegenden Anwendungen und letztendlich an den Benutzer weitergegeben.
Für einen Benutzer einer Anwendung im Internet ist es vom Aufwand her kein Unterschied, ob er seine Daten von einer lokalen Platte, aus dem inhouse-Netzwerk, von einem Server irgendwo in Deutschland oder gar in Taiwan oder den USA bekommt.
Allein an der Übertragungsgeschwindigkeit könnte man einen Unterschied  feststellen.
Leider birgt diese Transparenz gelegentlich Probleme in sich:
Für den Benutzer ist es gleich schwierig, einen Dienst über Transatlantik-Leitungen zu benutzen wie einen Dienst im lokalen Ethernet.
Es könnte sogar sein, daß sich ein guter Teil der Netzwerk-Benutzer gar nicht darum kümmert, woher genau die Daten jetzt kommen und wieviel Technik dafür in Bewegung gesetzt werden muß.
In Folge kommt es zu den Stoßzeiten auf überregionalen Leitungen mehr oder weniger stark zu Kapazitätsproblemen.&lt;/p&gt;
&lt;h2 id=&#34;reichhaltiges-angebot&#34;&gt;
    &lt;a href=&#34;#reichhaltiges-angebot&#34;&gt;
	Reichhaltiges Angebot
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Das Internet stellt seinen Benutzern auf der Basis von TCP/IP als Transportprotokoll eine Vielzahl von Dienstleistungen zur Verfügung.
Diese Dienste sind normalerweise auf der Basis eines weiteren Protokolles realisiert, das wiederum auf TCP/IP aufsetzt
(vgl. &lt;a href=&#34;https://blog.koehntopp.info/1993/04/01/tcpip-technik.html&#34;&gt;Internet Technik Artikel&lt;/a&gt;

).&lt;/p&gt;
&lt;p&gt;Der erste Dienst, den man als Benutzer im Internet kennenlernt, ist wahrscheinlich electronic mail.
Mail erlaubt es, Textnachrichten und neuerdings auch multimediale Dokumente an andere Benutzer im Netz zu verschicken.
Die Zustellung der Mail erfolgt, in dem der eigene Rechner nach dem Abschicken der Mail eine Verbindung zum Zielrechner aufbaut und die Mail dort online und direkt einliefert.
Bei einer schnellen Netzverbindung ist die Mail praktisch Sekunden nach dem Drücken der Returntaste beim Empfänger.&lt;/p&gt;
&lt;p&gt;Viele bekannte Firmen sind im Netz durch Mitarbeiter oder sogar mit einer Supportadresse vertreten.
Darunter sind so illustre Namen wie Motorola, Intel, AT&amp;amp;T, Microsoft, Borland, Seagate, Prime, NeXT, SUN, DEC, IBM, HP, Commodore, Atari und viele andere mehr, darunter auch zahllose kleinere Firmen.
Auch sind fast alle Universitäten in den meisten Ländern direkt zu erreichen.
Wer Freunde oder Bekannte hat, die als Austauschstudent an einer ausländischen Universität sind, der wird electronic mail als schnelles und billiges Briefmedium schätzen lernen.
Für den Studenten taugt Mail auch, um sich mit den Autoren von Seminarpapieren kurzzuschließen und zusätzliches Material für den Vortrag zu bekommen oder um Fragen zu stellen.&lt;/p&gt;
&lt;p&gt;Wer die Mailgrößen und die Zustellgeschwindigkeiten von Mailboxnetzen gewohnt ist, wird im Internet allerdings umdenken müssen.
Internet ist in der Lage, in kurzer Zeit große Datenmengen zu bewegen und dementsprechend wird dieser Dienst auch genutzt.
Es kann einem leicht passieren, daß man auf eine Anfrage, ob diese oder jene Datei vorhanden sei, kein &amp;ldquo;Ja&amp;rdquo;, sondern kurzerhand die Quelle zugestellt bekommt.&lt;/p&gt;
&lt;p&gt;Mit Mail ist es möglich, private Nachrichten an Personen zu verschicken.
Auf dem Internet gibt es einen anderen Dienst, News, der es erlaubt öffentliche Nachrichten an Sachgruppen, sogenannte Newsgroups, zu adressieren.
Eine Newsgroup ist gewissermaßen ein öffentliches Diskussionsforum, das einem bestimmten Thema gewidmet ist.
Insgesamt gibt es weit über 2500 verschiedene Newsgroups mit einem Themenspektrum, das von Computerthemen über Wissenschaft, Hobby, politischer Diskussion bis hin zu bloßem Jux reicht.
Typische Laufzeiten von Nachrichten in einer Newsgroup liegen dabei in der Gegend von 6-10 Stunden.
In dieser Zeit ist der eigene Text einmal rund um die Erde verteilt worden und viele tausend Mal kopiert worden.&lt;/p&gt;
&lt;p&gt;Mit einer Nachricht in einer Newsgroup erreicht man schnell ein großes Publikum.
Selbst bei exotischen Problemen oder Fragestellungen ist es wahrscheinlich, innerhalb eines Tages Personen zu finden, die ein ähnliches Problem auch schon einmal gehabt haben und einem möglicherweise weiter helfen können.
Gerade für jemanden, der sich mit Softwareentwicklung befaßt, sind die News eine wichtige Quelle für Informationen, praktische Erfahrungsberichte und Support, die beim Hersteller oft nur schwer zu bekommen sind.&lt;/p&gt;
&lt;p&gt;Viele nützliche PD-Programme konnten nur deswegen entstehen, weil Programmierer in den entferntesten Gegenden der Erde per News und Mail Quellen und Fehlerreports austauschen können und so trotz der großen Entfernungen eng zusammenarbeiten können.
Die public domain UNIX-Versionen Linux und 386BSD sind nach Megbytes gemessen die größten Produkte einer solchen Zusammenarbeit, aber auch viele andere Werkzeuge für den täglichen Einsatz sind auf diese Weise entstanden.
Allen voran stehen die Programme, die man zur effizienten Nutzung von News und Mail benötigt:
Programmpakete zum Lesen, Schreiben, Verschicken und Archivieren von News und Mail.&lt;/p&gt;
&lt;p&gt;Die neuesten Versionen dieser Programmpakete finden sich in Archiven, die per anonymous FTP zugänglich sind.
FTP steht für &amp;ldquo;File Transfer Protocol&amp;rdquo; und ist zugleich der Name eines Übertragungsprotokolls als auch der Name der Anwendung, die dieses Protokoll benutzt, um per Internet Dateien zu übertragen.
Viele Institutionen, die einen schnellen Internet-Anschluß haben und ein wenig Plattenplatz erübrigen können, richten Bereiche ein, in denen man auch ohne Paßwort per FTP Programme ablegen oder abholen kann.
Teilweise sind diese Rechner so konfiguriert, daß sie ihre Datenbestände untereinander automatisch abgleichen, ihre Platten also gegenseitig spiegeln.
Auf diese Weise erübrigt sich für den Benutzer das Horten von Quelltexten auf der eigenen Platte:
Wenn man ein Programmpaket benötigt, um es zu installieren oder mit den Quellen zu arbeiten, wird man sowieso nicht das private Archiv mit der veralteten Version aufsuchen, sondern sich per FTP eine aktuelle Version desselben Paketes holen.&lt;/p&gt;
&lt;p&gt;Das Hauptproblem dabei ist es lediglich, einen Server zu lokalisieren, der die gewünschten Daten auch anbietet.
Dafür gibt es im Netz öffentlich zugängliche Datenbanken, die einen Index über dreistellige Gigabytemengen auf Software enthalten, die Archies.
Ein Archie ist eine Datenbank, die typischerweise im Tages- oder Wochenrhytmus die kompletten Inhaltsverzeichnisse einiger hundert FTP-Server abfragt und zu einem Gesamtindex verarbeitet.
Man kann den Archie nach Namen oder Beschreibungen von Programmpaketen suchen lassen und erhält eine Liste aller Quellen für das gesuchte Programmpaket, die dem Archie bekannt sind.
Dazu kann man sich direkt auf dem Archie einloggen und einer simplen Abfragesprache bedienen.
Richtig bequem wird so eine Abfrage aber erst mit einem Abfrageprogramm wie xarchie (für XWindows), das man mit der Maus bedienen kann.
Die Beschaffung eines bestimmten Programmpaketes beschränkt sich dann auf die Eingabe des Paketnamens und das Anklicken der Knöpfe &amp;ldquo;Query&amp;rdquo; und (nach Auswahl des gewünschten Servers) &amp;ldquo;FTP&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Es gibt im Internet noch weitere frei zugängliche Datenbanken.
Da es jedoch keine zentrale Administration des Netzwerks gibt, ist es hier etwas schwierig einen Überblick zu bekommen.
Es ist zum Beispiel bekannt, daß sehr viele Bibliotheken in den USA einen Zugang ins Internet haben und ihre Kataloge als Datenbank öffentlich zugänglich machen.
Aber auch andere Institutionen bieten Datenbanken zur freien Abfrage an.
Man erreicht diese Datenbanken per TELNET, einem TCP/IP-Dienst, der es einem erlaubt, sich auf einem entfernten Rechner einzuloggen.
Per FTP sind Texte erhältlich, die den Versuch einer Katalogisierung solcher Dienste darstellen und die Netzadressen, Logins und Passwörter enthalten, die man benötigt, um arbeiten zu können.
Der nächste logische Schritt sind Datenbankabfrageprogramme, die eine Anfrage nehmen und sie allen Datenbanken stellen, die ihnen bekannt sind.
Solche Dienste sind WAIS (Wide Area information Service) und gopher.&lt;/p&gt;
&lt;h2 id=&#34;wie-man-sich-anschließt&#34;&gt;
    &lt;a href=&#34;#wie-man-sich-anschlie%c3%9ft&#34;&gt;
	Wie man sich anschließt
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Man kann auf zwei Wegen an einen Internet-Zugang kommen.
Die eine Methode ist es, sich einen Systembetreiber zu suchen, dessen Rechner am Internet angeschlossen ist und der einem die Benutzung seines Rechners erlaubt.
Man kann sich dann auf diesem Rechner einloggen und die Internet-Dienste dieses Rechner online nutzen.
Die andere Methode wäre, auf dem eigenen Rechner zu arbeiten und nur die eigenen IP-Pakete an einen Internet-Rechner weiter zu routen, etwa über ein Modem und SL/IP (Serial Line Internet Protocol).
Die meisten Internet-Anbieter lassen einem die Auswahl zwischen beiden Methoden des Anschlusses.&lt;/p&gt;
&lt;p&gt;Ein Anschluß ans Internet ist derzeit jedoch eine teure Sache, falls man nicht gerade Student an einer Universität mit freiem Zugang zum Internet ist.
Wer immer Internet anbietet, der muß eine Standleitung oder etwas mit ähnlicher Charateristik unterhalten.
Dabei kann es sich um eine Datex-P, ISDN- oder Modemstrecke handeln.
Der Betreiber dieser Strecke wird natürlich versuchen, seine Kosten auf die Nutzer umzulegen.
Im Endeffekt liegen die Kosten für vernünftig nutzbaren Internet-Anschluß derzeit bei etwa 50 DM/Monat mit starken geographischen Abweichungen.&lt;/p&gt;
&lt;p&gt;In Deutschland gibt es drei verschiedene Anbieter, die Internet-Dienste verkaufen können.
Diese sogenannten Provider sind jedoch nur für kommerzielle Kunden und Institutionen interessant.
Es handelt sich um EuNet Germany GmbH in Dortmund, XLINK in Karlsruhe und den DFN Verein.
Für Privatpersonen ist eher der Individual Network e.V. (&amp;ldquo;das IN&amp;rdquo;) interessant.
Dieser Verein hat bei zweien dieser drei Anbieter das Recht gekauft, deren Internet-Leitungen zu benutzen und dieses Recht an seine Mitglieder weiterzugeben.
Auf diese Weise kann das IN seinen Mitgliedern einen günstigen Zugang ins Internet verschaffen, wenn diese die dazu notwendig Infrastruktur vor Ort organisieren können.&lt;/p&gt;
&lt;p&gt;Wenn man sich in der Nähe eines solchen Zugangspunktes wohnt, also etwa in Kiel, Hamburg, Berlin, Oldenburg, im Ruhrgebiet, in Frankfurt oder
in München, dann genügt es, sich an den entsprechenden Anbieter zu wenden (siehe Kasten&amp;quot;Adressen&amp;quot;).
Ansonsten wird man sich überlegen müssen, ob man einen Anschlußpunkt in der Nähe finden kann oder wie man die Entfernung zum nächsten Anschlußpunkt überbrücken kann.&lt;/p&gt;
&lt;h2 id=&#34;informationsquellen&#34;&gt;
    &lt;a href=&#34;#informationsquellen&#34;&gt;
	Informationsquellen
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Um Neueinsteigern ins Internet bei der Orientierung zu helfen und einen Überblick über die verfügbaren Informationen und Dienste zu geben, hat man eine Reihe von RFCs mit Einsteierinformationen zusammengestellt.
Diese RFCs sind in einer gesonderten Reihe als &amp;ldquo;For your information&amp;rdquo; oder kurz FYI-Texte zusammengefaßt worden.
Von besonderem Interesse sind FYI 4, der sich mit häufig gestellten Fragen von Internet-Neulingen beschäftigt, FYI 8, der sich mit der Sicherheit einer Internet-Installation befaßt und FYI 10, der einen Überblick über im Internet verfügbare Dienste gibt.&lt;/p&gt;
&lt;h2 id=&#34;literatur&#34;&gt;
    &lt;a href=&#34;#literatur&#34;&gt;
	Literatur
    &lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Internetworking with TCP/IP; Principles, Protocols, and Architecture&amp;rdquo;,  by Douglas Comer, Prentice Hall, ISBN 0-13-470154-2.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;The Matrix; Computer Networks and Conferencing Systems Worldwide&amp;rdquo;, by John S. Quarterman, Digital Press, ISBN 0-13-565607-9.&lt;/LI&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;!%@:: A Directory of Electronic Mail Addressing and Networks&amp;rdquo;, by Donnalyn Frey and Rick Adams, O&amp;rsquo;Reilly &amp;amp; Associates, Inc., ISBN 0-937175-39-0.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;The User&amp;rsquo;s Directory of Computer Networks&amp;rdquo;,  Edited by Tracy L. LaQuey, Digital Press, ISBN 0-13-950262-9.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Where to Start - A Bibliography of General Internetworking Information&amp;rdquo;, by Bowers, K., T. LaQuey, J. Reynolds, K. Roubicek, M. Stahl, and A. Yuan, RFC 1175, FYI 3, CNRI, U Texas, ISI, BBN, SRI, Mitre, August 1990.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;The Hitchhikers Guide to the Internet&amp;rdquo;, by Krol, E., RFC 1118, University of Illinois Urbana, September 1989.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;IAB Official Protocol Standards&amp;rdquo;&lt;/I&gt;, (currently, RFC 1280).&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;rfc&#34;&gt;
    &lt;a href=&#34;#rfc&#34;&gt;
	RFC
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Ein &amp;ldquo;Request for Comments&amp;rdquo;, kurz RFC,  ist ein Papier, das sich in irgendeiner Form mit im Internet verwendeten Verfahren beschäftigt.
Es kann sich dabei um eine Anmerkung zu bestehenden Verfahren, einen Verbesserungsvorschlag oder den Vorschlag zu einem neuen Verfahren handeln.
Jeder, der am Internet interessiert ist, kann einen solchen RFC beim RFC Editor einreichen.
Derzeit ist der RFC Editor Jon Postel, der unter der Internet-Adresse &lt;a href=&#34;mailto:RFC-EDITOR@ISI.EDU&#34;&gt;RFC-EDITOR@ISI.EDU&lt;/a&gt;

 zu erreichen ist.
Wie eine Einsendung an den RFC-Editor auszusehen hat, um ihm die Arbeit zu vereinfachen ist auch in einem RFC (&lt;a href=&#34;http://src.doc.ic.ac.uk/public/rfc/rfc1111.txt.gz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 1111&lt;/a&gt;

 beschrieben.&lt;/p&gt;
&lt;p&gt;Ein solches Papier kann den Status &amp;ldquo;zur Information&amp;rdquo; erhalten, wenn es sich nur um eine Anmerkung handelt.
Enthält der RFC eine Spezifikation, die einmal ein Standard werden soll, so kann das Internet Activities Board (IAB) das Papier prüfen und zum &amp;ldquo;proposed standard&amp;rdquo; erklären.
So eine Spezifikation soll dann die Grundlage für zu entwickelnde Programmpakete sein, d.h. es braucht noch keine funktionierende Implementation des Standards zu geben.&lt;/p&gt;
&lt;p&gt;Sobald es Erfahrungen mit dem neuen Vorschlag gibt, frühestens aber nach einem halben Jahr, kann die Spezifikation zum &amp;ldquo;draft standard&amp;rdquo; werden.
Dazu muß es mindestens zwei Implementationen geben, die unabhängig voneinander aus der Spezifikation entwickelt worden sind und die trotzdem zusammenarbeiten können.
An einem &amp;ldquo;draft standard&amp;rdquo; wird nichts wesentliches mehr geändert; Modifikationen dienen nur noch der Ausbesserung von Fehlern und Ungenauigkeiten.&lt;/p&gt;
&lt;p&gt;Schließlich wird die Spezifikation nach angemessener Zeit zum &amp;ldquo;standard&amp;rdquo; befördert und ist damit ein fester Teil der Internet-Spezifikationen.
&lt;a href=&#34;http://src.doc.ic.ac.uk/public/rfc/rfc1280.txt.gz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC  1280&lt;/a&gt;

 gibt eine Übersicht über den Standardisierungsprozeß und nennt den Status der verschiedenen Dokumente.&lt;/p&gt;
&lt;p&gt;Nicht alle Standards im Internet müssen von allen Programmpaketen unterstützt werden.
Die RFCs unterscheiden zwischen Fähigkeiten, die alle beteiligten Programme unterstützen müssen (required), zwischen Optionen, die alle unterstützen sollten (recommended) und zusätzlichen Features, die wirklich optional sind (elective).&lt;/p&gt;
&lt;p&gt;Um in der Entwicklung der Standards im Internet auf dem Laufenden zu bleiben, kann man die neu erscheinenden RFCs abonnieren.
Dazu sendet man eine E-Mail an &lt;a href=&#34;mailto:RFC-REQUEST@NIC.DDN.MIL&#34;&gt;RFC-REQUEST@NIC.DDN.MIL&lt;/a&gt;

, die die eigene Netzadresse enthält.
Diese Adresse wird dann in einen Verteiler übernommen und fortan bekommt man alle neuen RFCs per E-Mail zugestellt.
Vorausgegangene RFCs sind in verschiedenen Archiven zu bekommen.
Eine Liste dieser Archive und eine Anleitung, wie man die betreffenden Dokumente bekommen kann, kann per FTP als isi.edu:/in-notes/rfc-retrieval.txt bezogen werden.
Alternativ kann man auch eine E-Mail an &lt;a href=&#34;mailto:rfc-info@isi.edu&#34;&gt;rfc-info@isi.edu&lt;/a&gt;

 senden, die als Nachrichtentext nur die eine Zeile &amp;ldquo;help: ways_to_get_rfcs&amp;rdquo; (ohne die Anführungszeichen) enthält.
Die RFCs bis Nummer 1357 sind außerdem auf der Desktop Library CD von Walnut Creek enthalten.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Betriebssysteme</title>
      <link>https://blog.koehntopp.info/1992/03/17/betriebssysteme.html</link>
      <pubDate>Tue, 17 Mar 1992 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/1992/03/17/betriebssysteme.html</guid>
      <description>&lt;p&gt;&lt;strong&gt;Abgeschickt an die c&amp;rsquo;t am 17. März 1992.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Aus technischen Gründen stehen die Abbildungen zu diesem Artikel nicht im Web zur Verfügung.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#betr%c3%bcbssysteme&#34;&gt;Text des Artikels&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#glossar&#34;&gt;Glossar&lt;/a&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;betrübssysteme&#34;&gt;
    &lt;a href=&#34;#betr%c3%bcbssysteme&#34;&gt;
	Betrübssysteme
    &lt;/a&gt;
&lt;/h1&gt;
&lt;h4 id=&#34;jeder-hat-eines-angeblich-kennt-sich-kaum-einer-wirklich-damit-aus-und-natürlich-ist-meines-besser-als-deines-die-rede-ist-von-betriebssystemen&#34;&gt;
    &lt;a href=&#34;#jeder-hat-eines-angeblich-kennt-sich-kaum-einer-wirklich-damit-aus-und-nat%c3%bcrlich-ist-meines-besser-als-deines-die-rede-ist-von-betriebssystemen&#34;&gt;
	Jeder hat eines, angeblich kennt sich kaum einer wirklich damit aus und natürlich ist meines besser als Deines. Die Rede ist von Betriebssystemen.
    &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;Das Betriebssystem ist das Grundprogramm eines Rechners.
Es wird beim Einschalten des Rechners gestartet und erst beim Abschalten wieder beendet.
Entsprechend seiner Funktion als Zwischenstück zwischen der realen Welt der konkreten Hardware und der abstrakten Welt der Algorithmen ist seine Aufgabe eine doppelte:
Für alle Benutzer eines Rechners teilt es die Rechenleistung, den Speicher und die Geräte der Maschine fair zwischen ihnen auf.
Es verhindert, so ist zumindest die Theorie, ungewollte Beeinflussung der verschiedenen Programme auf einem Rechner untereinander.
Für ein einzelnes Programm ist das Betriebssystem mehr wie eine große Befehlsbibliothek, die die doch recht sparsame Maschinensprache eines Rechners um so wirksame Funktionen wie &amp;ldquo;mehr Speicher zur Verfügung stellen&amp;rdquo;, &amp;ldquo;Satz aus einer Datei lesen&amp;rdquo; oder gar &amp;ldquo;diesen Bildschirmaufbau präsentieren und Ergebnis der Benutzeraktion hier abliefern&amp;rdquo; erweitert.&lt;/p&gt;
&lt;h2 id=&#34;mit-gespaltener-zunge&#34;&gt;
    &lt;a href=&#34;#mit-gespaltener-zunge&#34;&gt;
	Mit gespaltener Zunge
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Diese doppelte Aufgabenstruktur des Aufteilens und Multiplexens von knappen Betriebsmitteln auf der einen Seite und des Verbergens von lästigen Details aus der realen Welt vor den Anwendungen auf
der anderen Seite bestimmt die Struktur eines Betriebssystems.
Die Betriebsmittel, die ein Betriebssystem verwaltet, lassen sich grob in drei Gruppen unterteilen:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Zum ersten ist da - aus der Hardwaresicht - der Prozessor.
Er ist die einzig aktive Komponente des Systems und zudem in den meisten Fällen leider nur einmal vorhanden.
Aus der abstrakteren Sicht der Software erscheint er als Thread (&amp;ldquo;Kontrollfluß&amp;rdquo;) eines Programmes.
Ein gutes Betriebssystem wird die kostbare - weil seltene - Prozessorhardware multiplexen, um mehr als einen Kontrollfluß zur Zeit ablaufen zu lassen.&lt;/li&gt;
&lt;li&gt;Zum zweiten gibt es den Arbeitsspeicher.
Damit der Prozess ablaufen kann, müssen er selbst und seine Daten irgendwo gespeichert werden.
Realer Speicher in Form von RAM hat irgendwelche Adressen und ist nicht notwendigerweise mit den von der Anwendung benötigten Eigenschaften (&amp;ldquo;an einem Stück&amp;rdquo;, &amp;ldquo;an einer bestimmten Stelle&amp;rdquo;) vorhanden.&lt;br&gt;
Es ist Aufgabe des Betriebssystems, mit Unterstützung einer MMU diese Anforderungen zu erfüllen.
Andererseits muß aber verhindert werden, daß ein Prozess mehr als den ihm zugesicherten Speicher benutzt und dadurch eventuell andere Prozesse in ihrem Ablauf stört.
Das Betriebssystem muß die images (&amp;ldquo;Laufzeitbilder&amp;rdquo;) verschiedener Programme verwalten.&lt;/li&gt;
&lt;li&gt;Und zum dritten sind auch noch Ein/Ausgabegeräte verschiedenster Art zu verwalten.
Einige dieser Geräte, zum Beispiel Drucker oder Bandlaufwerke, sind nur von einem Prozess zur Zeit nutzbar.
In diesem Fall muß das Betriebssystem den Zugriff auf diese Geräte zuteilen - etwa über einen Druckerspooler oder durch Locks.
Andere Geräte, Festplatten beispielsweise, können aufgeteilt werden.
Hier muß das Betriebssystem einen entsprechenden Dienst zur Verfügung stellen - im Beispiel wäre dies ein Dateisystem.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ein Betriebssystem stellt dem Anwendungsprogramm, wie bereits festgestellt, verschiedene Dienste zur Verfügung.
Allerdings gibt es verschiedene Konzepte bei den Betriebssystem-Herstellern, wie diese Dienste in Anspruch zu nehmen sind.&lt;/p&gt;
&lt;h2 id=&#34;message-passing&#34;&gt;
    &lt;a href=&#34;#message-passing&#34;&gt;
	Message passing
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Ältere Betriebssysteme wie MS-DOS, aber auch UNIX und OS/2, stellen Dienste des Systems per Prozeduraufruf zur Verfügung.
Ob der Funktionsaufruf dabei durch einen Unterprogrammaufruf wie bei OS/2 oder durch einen Software-Interrupt wie bei MS-DOS und UNIX erfolgt, ist dabei zunächst nebensächlich.
Wesentlich ist, daß der Kontrollfluß des Prozesses auf das Betriebssystem über geht.
Diese Art des Dienstaufrufes hat aber einige Eigenschaften, die auf den ersten Blick als selbstverständlich, auf den zweiten Blick aber eher als unerwünscht gelten können:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ein solcher Unterprogrammaufruf ist immer synchron:
Das eigene Programm wartet solange, bis der Betriebssystemaufruf beendet ist.
Bei einigen Systemaufrufen, die mit Ein-/Ausgabefunktionen zu tun haben, könnte es aber vorteilhaft sein, daß das eigene Programm zwar den Wunsch nach bestimmten Daten absetzt, aber dann
erst einmal selbst weiterläuft und später nachsieht, ob die Daten denn jetzt zur Verfügung stehen.&lt;/li&gt;
&lt;li&gt;Durch einen Unterprogrammaufruf wird außerdem stillschweigend vorausgesetzt, daß das Betriebssystem den Dienst auf derselben CPU wie die Anwendung erbringt.
Eine Funktion &amp;ldquo;Fourieranalyse der Daten in diesem Puffer&amp;rdquo; unter Benutzung der wesentlich schnelleren Hardware eines Signalprozessors ist auf diese Weise nicht mit Unterstützung des Betriebssystems möglich - der Anwendungsprogrammierer muß das selbst hinbasteln.&lt;/li&gt;
&lt;li&gt;Wenn der Dienstaufruf dann auch noch durch einen gewöhnlichen Unterprogrammaufruf geschieht, ist es einer Anwendung möglich, außer den definierten Betriebssystemfunktionen auch noch andere, nicht dokumentierte Funktionen aufzurufen, in dem nicht zugelassene Sprungadressen
benutzt werden.
Es soll sogar Systeme geben, auf denen dies die gängige Praxis ist.
Der Systemsicherheit und der späteren Erweiterbarkeit ist eine so etwas natürlich nicht
dienlich.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Moderne Betriebssystemarchitekturen, allen voran Mach auf dem NeXT, aber auch Tanenbaums Amoeba oder Plan9 von AT&amp;amp;T, sind deswegen nach dem Client-Server Modell aufgebaut:
Die Dienste des Systems stehen dabei an Serverprozessen zur Verfügung.
Der Aufrufer sendet dem Server eine Nachricht (request-message), die von diesem ausgewertet wird.
Das Resultat wird dem Absender in einer Antwortnachricht (reply-message) zugestellt.&lt;/p&gt;
&lt;p&gt;Der Server ist dabei kein Teil des Betriebssystems selbst, sondern ein normaler Prozess, der möglicherweise einige zusätzliche Privilegien gegenüber gewöhnlichen Anwendungen hat.
Dazu gehört etwa die Zugriffsmöglichkeit auf einige Hardwareregister.
Das eigentliche Betriebssystem ist dann auf die allerwesentlichsten Funktionen reduziert:
Es verwaltet lediglich die Umschaltung zwischen den verschiedenen Prozessen, den lokalen Speicher des Systems und natürlich den Versand der Messages.
Alle anderen Dienste werden durch leicht austauschbare Serverprozesse realisiert.&lt;/p&gt;
&lt;p&gt;Dieses Modell des Dienstaufrufes hat nicht die Nachteile des Unterprogrammaufrufes:
Die Dienstleistungen des Systems können asynchron in Anspruch genommen werden, indem die Anwendung beispielsweise eine Nachricht mit einem Lesekommando an den Fileserver sendet, dann aber weiterarbeitet.
Später, wenn die Daten benötigt werden, sieht die Anwendung nach, ob die Antwort des Servers schon vorliegt.
Wenn ja, kann ohne Pause weitergearbeitet werden, ansonsten muß die Anwendung (wie beim Dienstaufruf durch Sprung in ein Unterprogramm auch) warten.&lt;/p&gt;
&lt;p&gt;Für die Anwendung ist es egal, ob der angeforderte Dienst lokal auf der eigenen CPU vorhanden ist oder ob ein Server über ein Netz auf einem anderen Rechner läuft.
Die Netzadresse mag sich ändern, aber der Aufrufmechanismus bleibt derselbe.
Unterschiedliche Datenformate, Maschinensprachen oder Aufrufkonventionen werden durch den Message-Mechanismus verborgen.&lt;/p&gt;
&lt;p&gt;Auch kann das Verhalten den Servers, der ja von seinem Client vollständig getrennt ist, genau durch seine Reaktion auf die verschiedenen Kommandonachrichten beschrieben werden.
Für den Client ist der Server auf jeden Fall eine Black Box.
Unsaubere Gemeinheiten wie das heimliche Auslesen von undokumentierten Variablen oder der Sprung in interne Funktionen, die eine Anwendung eigentlich nicht kennen geschweige denn aufrufen sollte, sind nicht mehr machbar, denn der Server läuft in einem vom Client vollständig getrennten Adreßraum oder sogar auf einer ganz anderen Maschine in einem Netz.&lt;/p&gt;
&lt;h2 id=&#34;rechenleistung-verteilen&#34;&gt;
    &lt;a href=&#34;#rechenleistung-verteilen&#34;&gt;
	Rechenleistung verteilen
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Wie oben erwähnt gibt es Systemzustände, in denen der Rechner ein Programm nicht fortsetzen kann, weil es auf irgendwelche Ereignisse (das Eintreffen von Daten von einem Gerät, das Erreichen einer bestimmten Zeit etc.) wartet.
Offenbar reicht ein einzelnes Programm nicht aus, einen Prozessor durchgehend zu beschäftigen.
Bei genauerer Untersuchung stellt sich sogar heraus, daß die meisten Programme mehr als 90 % ihrer realen Laufzeit in derartigen Wartezuständen zubringen.&lt;/p&gt;
&lt;p&gt;Aus dieser Beobachtung heraus ist das Konzept des Multitasking geboren worden.
In regelmäßigen Zeitabständen wird das laufende Programm unterbrochen, sein augenblicklicher Zustand wird eingefroren.
Der Scheduler des Betriebssystems wählt dann einen anderen Prozess aus, dessen Zustand aufgetaut wird und der dann für die Dauer der nächsten Zeitscheibe zum Ablauf kommt.
Ein Scheduler, der mit Zeitscheiben arbeitet, heißt &amp;ldquo;preemptive&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Viele Betriebssysteme, die nachträglich auf Multitasking nachgerüstet worden sind, haben keinen solchen Scheduler, sondern sind darauf angewiesen daß ein Task den Prozessor freiwillig hergibt.
Das kann ausdrücklich durch den Aufruf einer &lt;code&gt;schedule()&lt;/code&gt;-Funktion in regelmäßigen Abständen geschehen oder versteckt, indem man im Betriebssystem am Ende jeder Systemfunktion einen Aufruf des Schedulers vor dem Verlassen des Betriebssystems einsetzt.
Eine solche Form von Multitasking nennt man &amp;ldquo;kooperativ&amp;rdquo; oder &amp;ldquo;non-preemptive&amp;rdquo;.
Bei einem System mit kooperativem Multitasking kann die Umschaltung für den Benutzer aber leicht schwerfällig wirken, wenn rechenintensive Anwendungen laufen, die selten Systemaufrufe tätigen.&lt;/p&gt;
&lt;p&gt;Einer der schwersten Fehler, den ein Programmierer auf einem Rechner mit Multitasking-Betriebssystem machen kann, ist es, in einer aktiven Warteschleife auf das Eintreffen eines Ereignisses zu warten (&amp;ldquo;busy waiting&amp;rdquo;).
Die Effektivität von Multitasking beruht ja gerade darauf, daß Prozesse, die gerade keine echte Arbeit zu tun haben, stillgelegt werden und vom Betriebssystem erst dann wieder Rechenzeit zugeteilt bekommen, wenn sie etwas damit anfangen können.&lt;/p&gt;
&lt;p&gt;Deswegen ist es fast unmöglich, ein Betriebssystem wie beispielsweise MS-DOS nachträglich multitaskingfähig zu machen oder in einer Multitaskingumgebung (z.B. eine DOS-Box in UNIX oder OS/2) zu betreiben.
Nahezu jedes Programm, angefangen vom Kommandointerpreter der Shell, &amp;ldquo;verbrät&amp;rdquo; die ihm zugeteilte Rechenzeit vollständig in Zeicheneinleseroutinen und anderen engen Warteschleifen, anstatt diese anderen Programmen zur Verfügung zu stellen.
MS-DOS Prozesse sind gewissermaßen immer im Zustand &amp;ldquo;ready&amp;rdquo;.
Wenn man einem solchen System nachträglich eine Multitaskingerweiterung überstülpt, fehlt diesem System notgedrungen der Zustand &amp;ldquo;sleeping&amp;rdquo;, und jeder laufende Prozess erhält genau 1/ntel der Gesamtleistung der CPU - selbst dann, wenn er eigentlich gar nichts damit anfangen könnte.&lt;/p&gt;
&lt;p&gt;Nach welcher Strategie die &lt;code&gt;schedule()&lt;/code&gt;-Funktion letztendlich bestimmt, welcher Prozess aus der &amp;ldquo;ready&amp;rdquo;-Queue in den Zustand &amp;ldquo;running&amp;rdquo; gehen darf und damit auf die CPU gelangen kann, hängt stark von den gewünschten Eigenschaften des Systems ab.
Der einfachste Zuteilungsalgorithmus ist das &amp;ldquo;round-robin&amp;rdquo;-Verfahren.
Dabei wird die zur Verfügung stehende CPU-Zeit gleichmäßig zwischen allen Prozessen aufgeteilt, die sich darum bewerben.
Alle diese Prozesse kommen reihum auf die CPU - daher der Name.&lt;/p&gt;
&lt;p&gt;Oft wird dieses Verfahren noch so erweitert, daß man Prozesse unterschiedlicher Priorität unterscheidet.
Der Scheduler von AmigaOS, aber auch der von VAX/VMS, ist ein Round-Robin Scheduler mit Prioritäten.
Das bedeutet: Der Ringtausch der Prozesse auf der CPU funktioniert innerhalb der höchsten vorhandenen Prioritätsebene.
Erst wenn alle Prozesse einer höheren Prioritätsebene aus der Ready-Queue entfernt sind, etwa weil sie terminiert sind oder weil sie auf ein Ereignis warten und deswegen stillgelegt sind, kommen
Prozesse mit niederen Prioritäten auf die CPU.&lt;/p&gt;
&lt;p&gt;Andererseits kann ein CPU-intensiver Prozess mit einer hohen Priorität den Rest des Systems recht schwerfällig machen oder gar blockieren.
Gelegentlich (bei Echtzeitanwendungen zum Beispiel) ist dieser Effekt erwünscht:
Man geht davon aus, daß ein Prozess mit einer hohen Priorität die Rechenzeit, die er beansprucht, auch unbedingt und gerade zu diesem Zeitpunkt benötigt.
Im allgemeinen Fall allerdings möchte man eine Lösung haben, die auch dann noch eine gewisse
Fairness gewährleistet, wenn ein Programm böswillig Rechenzeit schluckt.
In UNIX zum Beispiel sind die Prioritäten von Prozessen nicht fest, sondern hängen davon ab, wie lange der Prozess schon in der Warteschlange steht und wie CPU-intensiv er ist.&lt;/p&gt;
&lt;p&gt;Prozesse, die frühzeitig die CPU verlassen (etwa weil sie viel I/O machen und deswegen häufig im Zustand &amp;ldquo;sleeping&amp;rdquo; sind) bekommen ihre Restzeit als Bonus für die nächste Zeitscheibe gutgeschrieben, der in die Berechnung der Priorität eingeht.
Dadurch bekommen solche Prozesse automatisch eine bessere Priorität als solche, die die Zeitscheiben immer voll ausnutzen.&lt;/p&gt;
&lt;p&gt;Prozesse, die lange in der Ready-Queue gestanden haben (weil sie eine schlechte Priorität haben), werden temporär aufgewertet, damit sie auch eine Chance haben, einmal zum Ablauf zu kommen (priority aging).&lt;/p&gt;
&lt;h2 id=&#34;synchronisation&#34;&gt;
    &lt;a href=&#34;#synchronisation&#34;&gt;
	Synchronisation
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Eines der zentralen Probleme in einem System, in dem mehr als ein Programm zur Zeit aktiv sein kann, ist die Synchronisation von Prozessen bzw. der gegenseitige Ausschluß von Prozessen, die auf einen gemeinsamen Datenbereich zugreifen.
Gemeinhin löst man in der Information ein solches Problem mit Semaphoren:
Man definiert sich ein Flag, das anzeigt, ob ein Datenbereich zur Zeit &amp;ldquo;frei&amp;rdquo; oder &amp;ldquo;in Bearbeitung&amp;rdquo; ist, und zwei Operationen zum Setzen bzw. Löschen dieses Flags.
Der Punkt ist, daß diese Operationen atomar sein müssen, das heißt, die Semaphor-Setzfunktion und die Löschfunktion dürfen auf keinen Fall unterbrochen werden.&lt;/p&gt;
&lt;p&gt;Auf Rechnern mit nur einem Prozessor läßt sich dieses Problem recht leicht dadurch lösen, daß man in diesen beiden Funktionen kurze Zeit sämtliche Unterbrechungen verbietet und die gewünschte Operation durchführt.
Auf Mehrprozessorsystemen nützt dies natürlich nichts mehr, denn während der eine Prozessor den Semaphor bearbeitet, kann ein anderes Programm auf einem anderen Prozessor dasselbe tun.
Hier ist das Betriebssystem auf die Unterstützung der Hardware angewiesen, die nicht unterbrechbare Semaphor-Operationen schon als Prozessorbefehl anbieten muß.
Prozessoren wie der 680x0 und der 80x86 haben solche Operationen bereits eingebaut:
Der TAS-Befehl des 680x0 führt zum Beispiel eine solche Semaphor-Operation in einem nicht unterbrechbaren Read-Modify-Write-Zyklus aus, und der 80x86 kennt das LOCK-Prefix für eine ganze Reihe von Befehlen, die dann ebenfalls nicht unterbrechbar werden.&lt;/p&gt;
&lt;h2 id=&#34;speicher-auf-kredit&#34;&gt;
    &lt;a href=&#34;#speicher-auf-kredit&#34;&gt;
	Speicher auf Kredit
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Eine andere nützliche Sache, die einen sicheren Multitasking-Betrieb unterstützt, ist in den neueren
Prozessoren der verschiedenen Hersteller ebenfalls gleich mit eingebaut:
Alle diese Geräte haben eine PMMU, das bedeutet, sie sind in der Lage, physikalisch vorhandenes RAM an jeder beliebigen Stelle des Adreßraumes der CPU einzublenden und die Speicherzugriffe eines jeden Programmes genau zu kontrollieren.&lt;/p&gt;
&lt;p&gt;Auf diese Weise läßt sich ein Prozess in seinem eigenen Speicher einzäunen.
Zwar erlaubt man ihm, auf den eigenen vom System angeforderten Speicher zuzugreifen, doch sobald versucht wird, auf andere, nicht erlaubte Speicherbereiche zuzugreifen, wird der Prozess unterbrochen und das Betriebssystem übernimmt die Kontrolle (&amp;ldquo;memory protection&amp;rdquo;, &amp;ldquo;Speicherschutz&amp;rdquo;).
Es kann den problematischen Prozess stillegen und ein Image seines Zustandes zur späteren Fehlersuche auf Platte ablegen.
Auf diese Weise verhindert man zwar nicht, daß ein fehlerhaftes Programm abstürzt, aber immerhin wird sichergestellt, daß keine anderen Programme in Mitleidenschaft gezogen werden.&lt;/p&gt;
&lt;p&gt;Die MMU-Hardware kann man auch dazu benutzen, dem Programm mehr RAM vorzuspiegeln, als tatsächlich in der verwendeten Maschine vorhanden ist (&amp;ldquo;virtual memory&amp;rdquo;).
Die meisten Programme brauchen nicht alle ihre Daten und ihren gesamten Code zur gleichen Zeit, sondern sind oft nur in einem kleinen, eng begrenzten Speicherbereich (dem &amp;ldquo;working set&amp;rdquo;) aktiv.
Je nach Benutzung des Programmes verschiebt sich dieser Bereich von Zeit zu Zeit, aber im Prinzip würde ein kleiner Speicherbereich ausreichen, um das ganze Programm ablaufen zu lassen.&lt;/p&gt;
&lt;p&gt;Betriebssysteme wie UNIX unterteilen deswegen den gesamten Speicher der Maschine in Seiten fester Größe - bei einer 80386 CPU zum Beispiel werden durch die Hardware Pages von 4 KB Größe vorgegeben.
Nicht alle Speicherseiten eines Prozesses sind gleichzeitig im RAM, sondern Teile davon befinden sich in der &amp;ldquo;paging area&amp;rdquo;, einem abgeteilten Bereich einer Festplatte.
Wenn ein Prozess versucht, eine Speicherseite anzusprechen, die gerade nicht präsent ist, generiert die MMU wieder eine Unterbrechung (&amp;ldquo;page fault&amp;rdquo;) und läßt das Betriebssystem zum Zuge kommen.
Dieses sucht jetzt eine andere Speicherseite, die möglichst lange nicht benutzt worden ist, speichert diese in der Paging Area zwischen, adressiert sie um und stellt sie dann dem unterbrochenen Prozess an der richtigen Adresse und mit dem richtigen Inhalt, der inzwischen von der Platte geladen wurde, zur Verfügung.
Dieser wird nach der kurzen Unterbrechung dann fortgesetzt.&lt;/p&gt;
&lt;p&gt;Wenn genug Speicher vorhanden ist, um die aktiven Teile der verschiedenen lauffähigen Prozesse gleichzeitig im Speicher zu halten, fallen die kurzen Unterbrechungen beim Paging nicht weiter  ins Gewicht.
Wenn der Rechner jedoch überlastet wird und für die Anzahl der gleichzeitig laufenden Prozesse zu wenig Speicher hat, fängt er an, auch Teile von Prozessen auf Platte auszulagern, die gleich wieder geladen werden müssen.
Die Rechenleistung der Maschine fällt plötzlich um einige Zehnerpotenzen, und die Antwortzeiten auf ein simples Return an der Console liegen auf einmal im Minutenbereich.
Man bezeichnet diesen Vorgang als &amp;ldquo;treshing&amp;rdquo; (dreschen), und die Abhilfe bei diesem Problem ist simpel: Man lege einige Megabytes RAM nach.&lt;/p&gt;
&lt;h2 id=&#34;konsequent-weiter-gedacht&#34;&gt;
    &lt;a href=&#34;#konsequent-weiter-gedacht&#34;&gt;
	Konsequent weiter gedacht
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Wenn ein neuer Prozess gestartet wird, muß er zunächst einmal in den Speicher geladen werden.
Verwendet man jedoch das eben erläuterte Virtual-Memory-Schema, bei dem jede Speicherseite des virtuellen Adreßraums genau einer Speicherseite auf der Platte entspricht, muß der Code eines  Prozesses nicht nur in den Speicher kopiert, sondern auch noch in den Paging-Bereich der Platte geschrieben werden.
Zudem werden Speicherseiten, die Code enthalten, nie geändert, so daß eigentlich gar keine private Kopie des Codes in der Paging Area angelegt werden muß.
VMS, aber auch einige neuere UNIX-Versionen und natürlich modernere Systeme wie Mach und Chorus verwenden hier einen intelligenteren Algorithmus:
Seiten mit Programmcode, die aus dem physikalisch vorhandenen Speicher verdrängt werden, werden einfach ohne Zurückschreiben aufgegeben und später aus der Programmdatei wieder nachgeladen (&amp;ldquo;paging from file&amp;rdquo;).
Dadurch entfällt beim Starten eines Programmes das Umkopieren in die Paging Area, und der Paging-Bereich wird weniger stark belastet.&lt;/p&gt;
&lt;p&gt;Die Autoren von Mach und Chorus haben diese Idee konsequent weiter gedacht:
Diese beiden Betriebssysteme können das auch mit Daten machen, die mit read() und write() aus Dateien gelesen oder geschrieben werden.
Dateien, die aus Datensätzen fester Länge bestehen, sind schließlich nur der Sonderfall eines Arrays:
In PASCAL kann man das sogar noch in der Definition sehen.&lt;/p&gt;
&lt;p&gt;Mit Hilfe der MMU blendet man einen Speicherbereich von der Größe der Datei, die verarbeitet werden soll, in den Adreßraum des Prozesses ein (&amp;ldquo;memory mapped file&amp;rdquo;).
Für den Prozess ist die Basis dieses Speicherbereiches die Startadresse eines ganz normalen Arrays. Versucht der Prozess, auf dieses Array zuzugreifen, kommt es zu einem Page Fault.
Das Betriebssystem hat diesen Speicherbereich mit einer Datei assoziiert und lädt jetzt die entsprechenden Dateiinhalte in die angesprochenen Speicherseiten, mit denen der Prozess dann wie bei einem normalen Arrayzugriff arbeitet.
Beim Schließen der Datei wird der Speicherbereich wieder aus dem Adreßraum des Prozesses ausgeblendet, und alle Modifikationen werden spätestens zu diesem Zeitpunkt in die Datei zurückgeschrieben.&lt;/p&gt;
&lt;p&gt;Auf diese Weise werden spezielle Dateioperationen in einer Programmiersprache überflüssig;
Dateien werden wieder zu dem, was sie eigentlich sind:
Arrays dynamischer Länge, deren Inhalt über die Laufzeit eines Prozesses hinaus Bestand hat.
Der Programmierer einer Anwendung braucht sich nicht mehr um das Lesen und Schreiben von Daten in Puffer zu kümmern, er greift einfach darauf zu.
Das tatsächliche Bereitstellen der Daten und das Zurückschreiben auf Platte geschieht durch das Betriebssystem, ohne daß er etwas damit zu tun hätte.&lt;/p&gt;
&lt;h2 id=&#34;inflation-der-programmzähler&#34;&gt;
    &lt;a href=&#34;#inflation-der-programmz%c3%a4hler&#34;&gt;
	Inflation der Programmzähler
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Bis jetzt sind wir stillschweigend davon ausgegangen, daß ein Prozess genau einen Kontrollfluß hat.
Bei den meisten Betriebssystemen ist das auch noch so, obwohl eine Verallgemeinerung möglich ist und bei moderneren Entwicklungen auch durchgeführt worden ist.
Es ist durchaus sinnvoll, daß im Image eines Prozesses mehr als ein Kontrollfluß (&amp;ldquo;Thread&amp;rdquo;) aktiv ist.
Man stelle sich beispielsweise eine Tabellenkalkulation vor, die in einer Warteschleife auf Nachrichteneines Menüsystems wartet.
Wenn der Benutzer jetzt einen Menüpunkt anwählt, der längere Zeit zur Durchführung braucht (etwa das Neuberechnen des gesamten Blattes), kann im Prozess ein Thread dafür abgespalten werden, während der andere Thread schon wieder in der Warteschleife bereitliegt, um neue Benutzerkommandos entgegen zu nehmen.&lt;/p&gt;
&lt;p&gt;Die Erzeugung eines Threads ist - verglichen mit der eines eigenständigen Prozesses - relativ wenig aufwendig.
Ein Thread ist kaum mehr als einige Prozessorregister und ein eigener Stackbereich, während an einem Prozess noch ungezählte Tabellen für MMU-Konfiguration, offene Dateien, etc. hängen.
Beim kommerziellen Chorus-System hat man diese Trennung zwischen Speicherverwaltung und Kontrollflußverwaltung auch begrifflich deutlich machen wollen:
Ein Kontrollfluß ist bei Chorus ein Thread, der zugehörige Kontext heißt Actor und ein Actor mit
mindestens einem Thread bildet einen Prozess.
Die Kommunikation und der Datentausch zwischen Threads sind fast ohne Aufwand möglich:
Da Threads im selben Adreßraum liegen, können sie auf dieselben gemeinsamen Variablen zugreifen, ohne auf langsame und aufwendige Mechanismen zur Prozesskommunikation zurückgreifen zu müssen.&lt;/p&gt;
&lt;h2 id=&#34;daten-über-die-grenze-schaffen&#34;&gt;
    &lt;a href=&#34;#daten-%c3%bcber-die-grenze-schaffen&#34;&gt;
	Daten über die Grenze schaffen
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Bei Prozessen, die in verschiedenen, durch die Schutzmechanismen des Betriebssystems getrennten Adreßräumen liegen, sind der Datentausch und die Kommunikation untereinander schon aufwendiger.
Einem gemeinsamen Adreßraum am nächsten kommt noch &amp;ldquo;shared memory&amp;rdquo;.
Dabei wird eine Speicherseite, die verschiedene Variablen enthalten kann, in die Adreßräume der beteiligten Kommunikationspartner eingeblendet.
Diese sind allerdings voll verantwortlich für die Regelung des Zugriffs auf diese Speicherbereiche, die Freigabe, wenn sie nicht mehr benutzt werden, etc.&lt;/p&gt;
&lt;p&gt;Viele Betriebssysteme stellen deswegen höher entwickelte, aber auch langsamere Kommunikationsmöglichkeiten zur Verfügung.
Am häufigsten findet sich ein Message-System, bei dem eine Art FIFO-Struktur realisiert wird.
Jeder Prozess hat, wenn er Nachrichten entgegennehmen möchte, einen sogenannten Port, an den andere Prozesse Nachrichten senden können.
Treffen die Nachrichten schneller ein, als der Prozess sie abarbeiten kann, bildet sich am Port eine Queue mit FIFO-Struktur.
Der empfangende Prozess arbeitet die Nachrichten jetzt in der Reihenfolge ab und sendet die Antworten an die Absender zurück.&lt;/p&gt;
&lt;p&gt;Hier kann das Betriebssystem schon einen guten Teil der Zugriffsregelung, der Speicherverwaltung und der Adreßauflösung übernehmen.
Wenn der Message-Mechanismus nämlich allgemein genug implementiert wird, muß der Message-Port des Empfängers nicht unbedingt auf der eigenen Maschine sein, sondern kann sich irgendwo im Netz befinden.
Ist der Empfänger lokal erreichbar, kann die Nachricht ohne Kopieren einfach in seinen Adreßbereich eingeblendet werden.
Andernfalls muß sie &amp;ldquo;by value&amp;rdquo; über das Netz kopiert werden.
Der Benutzer des Message-Systems merkt davon nichts, für ihn sind diese lästigen Details verborgen.
Das geht bei Chorus dann sogar soweit, daß Ports von einem Prozess zu einem anderen migrieren können, ohne daß sendende Prozesse von diesem Wechsel des Empfängers etwas merken.
Derartige Features erleichtern dem Programmierer von &amp;ldquo;fault tolerant systems&amp;rdquo; die Arbeit natürlich ungemein.&lt;/p&gt;
&lt;p&gt;Noch viel wichtiger als ein Mechanismus zur Kommunikation zwischen Prozessen ist jedoch, daß ein einheitliches, erweiterbares Format zum Datentausch besteht.
Es genügt nicht, daß das Betriebssystem Dienste zum Verschieben von Bytes zwischen einem oder mehreren Prozessen zur Verfügung stellt.
Der Empfänger muß auch in der Lage sein, diese Bytes als eine bestimmte Datenstruktur, etwa einen Bildausschnitt oder einen Text mit Steuerinformationen, zu deuten.
Wenn das Betriebssystem ein durch Subklassen erweiterbares Format für die verschiedenen am häufigsten auftretenden Datentypen bereitstellt, leistet es einen wesentlichen Teil zur Vereinheitlichung der Datenformate der Applikationen, die auf diesem Betriebssystem ablaufen.&lt;/p&gt;
&lt;p&gt;Wichtig für die Funktionsfähigkeit eines solchen Datenformates ist, und das soll noch einmal besonders herausgestellt werden, daß es von seinem Benutzer unter Wahrung der Abwärtskompatibilität erweiterbar ist.
Ein Benutzer eines Textverarbeitungsformates, beispielsweise ein DTP-Programm, muß in der Lage sein, seine programmspezifischen Zusatzinformationen in einem Text abzulegen.
Andere Anwendungen, die dieses Textformat lesen können, müssen trotzdem in der Lage sein, die Standardattribute eines Textes aus so einer Datei herauszulesen und die Nichtstandardattribute unverändert weiter zu kopieren.
Eine Anwendung, die ein zusammengesetztes Format schreibt, z.B. eine Animation oder ein Text mit Bildern, muß dies in einer Art und Weise tun können, die es anderen Anwendungen erlaubt, die Komponenten dieser Daten (etwa Einzelbilder) gezielt zu lesen, zu verarbeiten und wieder in die Gesamtdatei zu integrieren.&lt;/p&gt;
&lt;p&gt;Funktionsbibliotheken, die die Arbeit mit solchen Dateiformaten unterstützen, gehören zwar nicht zu den unmittelbaren (Kern-) Dienstleistungen eines Betriebssystems, aber sie sollten auf jeden Fall zu seinem Standardfunktionsumfang gehören, um eben eine Einheitlichkeit in den Datenformaten bei den Anwendungen zu begünstigen.&lt;/p&gt;
&lt;h2 id=&#34;einheitlichkeit---das-zweite-ziel&#34;&gt;
    &lt;a href=&#34;#einheitlichkeit---das-zweite-ziel&#34;&gt;
	Einheitlichkeit - das zweite Ziel
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Einheitlichkeit beim Zugriff auf die vom System bereitgestellten Dienste zu ermöglichen, ist, wie bereits am Anfang dieses Textes dargestellt, neben der Verteilung von Ressourcen eine der Hauptaufgaben eines Betriebssystems.
Ziel soll es sein, Anwendungen eine virtualisierte Umgebung bereitzustellen, die zwar die Nutzung der speziellen Möglichkeiten dieses konkreten Systems möglichst wenig einschränkt, aber zugleich eine einheitliche, virtuelle Maschine über die Grenzen verschiedener Systemkonfigurationen oder gar verschiedener Hardwareplattformen hinweg ermöglicht.&lt;/p&gt;
&lt;p&gt;Betriebssysteme wie UNIX und seine Abkömmlinge tun dies beispielsweise, in dem sie den meisten Systemdiensten das Dateiparadigma überstülpen:
Pipelines, zeichen- und blockorientierte Geräte, Querverweise auf andere Dateien, Netzwerkdienste - alles dies ist als Eintrag im hierarchischen Namensraum des Dateisystems zu finden.&lt;/p&gt;
&lt;p&gt;In Mach, aber auch in Plan9 und in den neuesten Versionen von UNIX, ist dieses Konzept noch  Verallgemeinert worden, indem von der Möglichkeit Gebrauch gemacht wurde, die unterschiedlichsten Typen von Dateisystemen in den Namensraum zu integrieren.
So gibt es bei System V Rel. 4 ein &lt;code&gt;/proc&lt;/code&gt;-Dateisystem, in dem die zur Zeit im Rechner laufenden Prozesse als Dateieinträge sichtbar gemacht werden.&lt;/p&gt;
&lt;p&gt;Amoeba, ein experimentelles Betriebssystem von Tanenbaum, treibt es jedoch auf die Spitze.
In Amoeba sind alle Dienste - also das Bereitstellen der Informationen in einer Datei, Pipelines, Prozesskommunikation, etc. - unter einer Kennung zu erreichen, die das jeweils angesprochene Objekt (die Datei, den Prozess, &amp;hellip;) eindeutig identifiziert.
Diese Kennung beinhaltet zugleich die Kodierung der Zugriffsrechte, die Adresse des Objektes im System und noch einige Informationen mehr.
Die vom Betriebssystem verwalteten Objekte werden durch einen Directory-Service miteinander zu einer Struktur verknüpft, die nicht mehr auf die baumartige Hierarchie eines UNIX-Dateisystems beschränkt ist, sondern jeden beliebigen, gerichteten Graphen modellieren kann.
Da der Directory-Service selbst wieder ein Objekt im Amoeba-System ist, ergibt sich, ähnlich wie beim UNIX-Dateisystem, eine interessante, rekursiv definierte Struktur.&lt;/p&gt;
&lt;p&gt;Eine andere Möglichkeit der Virtualisierung ist die Abstraktion von einem konkreten Gerät zu seinen Möglichkeiten.
In UNIX gibt es zum Beispiel die curses-Bibliothek, die es ermöglicht, ein Terminal unabhängig von den Steuercodes, die es verwendet, zu programmieren.
Windows, OS/2, AmigaDOS und andere Betriebssysteme leisten ähnliches bei der Ansteuerung von Druckern.
Statt daß die Anwendung einem bestimmten Drucker an der parallelen Schnittstelle einen bestimmten Steuercode zum Einschalten von Fettschrift zu sendet, bittet sie den Druckertreiber, den vom Anwender gewünschten Drucker in Fettschrift umzustellen, falls der Drucker das kann.
Eine austauschbare Komponente des Betriebssystems, ein Gerätetreiber, stellt jetzt fest, ob der Drucker diese Funktion hat, und veranlaßt die für den konkreten angeschlossenen Drucker passenden  Maßnahmen an einem weiteren untergeordneten Gerätetreiber für die Druckerschnittstelle.
Dies kann der Treiber für die parallele oder die serielle Schnittstelle sein, aber auch der SCSI- oder der Ethernet-Treiber für einen Drucker im Netz.
Die &amp;ldquo;passenden Maßnahmen für den konkreten Drucker&amp;rdquo; können die Generierung von fünf ASCII-Steuerzeichen zur Umschaltung auf Fettdruck sein oder das Berechnen eines neuen Fonts und das Laden dieses Zeichensatzes auf den Drucker.
In jedem Fall bekommt die Anwendung die von ihr gewünschte Dienstleistung, ohne überhaupt etwas von den Aktivitäten hinter den Kulissen zu merken und ohne daß der Hersteller der Anwendung bei jedem Update mehrere Disketten mit Gerätetreibern mitliefern muß.&lt;/p&gt;
&lt;h2 id=&#34;das-betriebssystem-der-zukunft&#34;&gt;
    &lt;a href=&#34;#das-betriebssystem-der-zukunft&#34;&gt;
	Das Betriebssystem der Zukunft?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Das Betriebssystem der Zukunft, egal ob es jetzt OS/2, Windows oder UNIX heißen wird, wird mit den heute verbreiteten Systemen, die kaum mehr als dynamisch linkbare Bibliotheken von Ein-/Ausgabefunktionen sind, wenig gemeinsam haben.
Statt dessen wird es halb-experimentellen Systemen wie Mach, Plan9 oder Amoeba ähnlich sehen.
Es wird einen kleinen Kern mit den notwendigsten Funktionen zum Multitasking und Message Passing haben und eine große Zahl von Standardserverprozessen für die unterschiedlichen Systemdienste bereitstellen.
Zu diesen Systemdiensten wird das Betreiben von Geräteabstraktionen (Standarddruckern, einheitlich steuerbaren Grafikbildschirmen) ebenso gehören wie das Bereitstellen komplexer Bibliotheksfunktionen über Serverprozesse mit eigenem Kontrollfluß (etwa die Konvertierung von Datenformaten oder eine Bibliothek mit Funktionen für grafische Benutzerführung).&lt;/p&gt;
&lt;p&gt;Der Preis für die Funktionalität: Mehr Megabytes, mehr Megaherz, mehr Megapixel.&lt;/p&gt;
&lt;h2 id=&#34;glossar&#34;&gt;
    &lt;a href=&#34;#glossar&#34;&gt;
	Glossar
    &lt;/a&gt;
&lt;/h2&gt;
&lt;dl&gt;
&lt;dt&gt;Kernel:&lt;/dt&gt;
&lt;dd&gt;Der Kernel ist das eigentliche Betriebssystem. Moderne Systeme haben die Anzahl der Funktionen im Kernel auf das allernotwendigste reduziert. Man redet dann von einem Microkernel.&lt;/dd&gt;
&lt;dt&gt;Gerätetreiber:&lt;/dt&gt;
&lt;dd&gt;Geräteabhängiges Treiberprogramm für ein Peripheriegerät, oft Bestandteil des Kernels.&lt;/dd&gt;
&lt;dt&gt;Thread:&lt;/dt&gt;
&lt;dd&gt;Kontrollflußbestandteil eines Prozesses: CPU-Register, Stack, Zustand, etc.&lt;/dd&gt;
&lt;dt&gt;Actor:&lt;/dt&gt;
&lt;dd&gt;Bezeichung im Betriebssystem Chorus für den Kontext eines Prozesses, der nicht mit dem Thread zusammenhängt: MMU-Register, Dateizeiger, etc.&lt;/dd&gt;
&lt;dt&gt;Prozess:&lt;/dt&gt;
&lt;dd&gt;Ein Actor mit mindestens einem Thread bildet einen Prozess.&lt;/dd&gt;
&lt;dt&gt;Image:&lt;/dt&gt;
&lt;dd&gt;Speicherabbild eines Prozesses.&lt;/dd&gt;
&lt;dt&gt;Virtual Memory:&lt;/dt&gt;
&lt;dd&gt;Erweitern des Speicherbereiches, der einem Prozess zur Verfügung steht, durch für den Prozess transparentes Auslagern von Prozessen (oder Prozessteilen) auf einen Hintergrundspeicher durch Swapping oder Paging.&lt;/dd&gt;
&lt;dt&gt;Swapping:&lt;/dt&gt;
&lt;dd&gt;Ein-/Auslagern ganzer Prozesse in einen speziellen Plattenbereich (swap area) bei Speicherknappheit.&lt;/dd&gt;
&lt;dt&gt;Demand Paging:&lt;/dt&gt;
&lt;dd&gt;Ein-/Auslagern von Prozessteilen fester Größe (Pages) in einen speziellen Plattenbereich bei Speicherknappheit.&lt;/dd&gt;
&lt;dt&gt;PMMU:&lt;/dt&gt;
&lt;dd&gt;Paged Memory Management Unit; Hardware zum Abbilden virtueller Prozessadressen auf physikalische Speicheradressen.&lt;/dd&gt;
&lt;dt&gt;Working Set:&lt;/dt&gt;
&lt;dd&gt;Der Teil eines Prozesses, der aus Effizienzgründen in physikalischem RAM gehalten werden sollte, weil der laufende Prozess ständig Adressen aus dem Working Set referenziert.&lt;/dd&gt;
&lt;dt&gt;Treshing:&lt;/dt&gt;
&lt;dd&gt;Dramatischer Leistungsabfall des Systems um einige Zehnerpotenzen, wenn wegen Speicherknappheit Teile der Working Sets von aktiven Prozessen ausgelagert werden.&lt;/dd&gt;
&lt;dt&gt;Server-Client Modell:&lt;/dt&gt;
&lt;dd&gt;Art der Betriebssystemarchitektur, bei der die Dienste des Systems von Serverprozessen angeboten werden. Der Client sendet eine Nachricht mit einer Dienstanforderung an den Server, der die gewünschte Funktion asynchron ausführt und das Ergebnis zurücksendet.&lt;/dd&gt;
&lt;dt&gt;Semaphore:&lt;/dt&gt;
&lt;dd&gt;Flag, das den Zugriff mehrere Prozesse auf eine Datenstruktur regelt.&lt;/dd&gt;
&lt;dt&gt;Message passing:&lt;/dt&gt;
&lt;dd&gt;Paradigma beim Aufruf von Betriebssystemfunktionen: Die Parameter eines Dienstaufrufes werden dem Dienstanbieter in einer Nachricht übermittelt. Der Dienstanbieter ist ein eigenständiger Prozess, der die Anforderung unabhängig und asynchron zum Dienstaufrufer bearbeitet.&lt;/dd&gt;
&lt;dt&gt;Time-Slice:&lt;/dt&gt;
&lt;dd&gt;Zeitscheibe; die Zeiteinheit, die ein Prozess maximal ohne Unterbrechung die CPU in Anspruch nehmen kann.&lt;/dd&gt;
&lt;dt&gt;Preemptive Multitasking:&lt;/dt&gt;
&lt;dd&gt;Verfahren, bei dem Prozesse die CPU auch ohne eigenes Zutun nach Ablauf der Zeitscheibe verlieren können.&lt;/dd&gt;
&lt;dt&gt;Cooperative Multitasking:&lt;/dt&gt;
&lt;dd&gt;Verfahren, bei dem Prozesses die CPU nur durch expliziten oder impliziten (durch Aufruf einer Systemfunktion) Aufruf des Schedulers verlieren können.&lt;/dd&gt;
&lt;dt&gt;Scheduler:&lt;/dt&gt;
&lt;dd&gt;Betriebssystemteil, der bestimmt, nach welchen Kritierien die Zeitscheiben den einzelnen Prozessen zugeteilt werden.&lt;/dd&gt;
&lt;dt&gt;Round-Robin:&lt;/dt&gt;
&lt;dd&gt;Scheduling-Algorithmus, bei dem alle lauffähigen Prozesse dieselbe Anzahl von Zeitscheiben zugeteilt bekommen.&lt;/dd&gt;
&lt;dt&gt;Priority-Aging:&lt;/dt&gt;
&lt;dd&gt;Eigenschaft von Scheduling-Algorithmen. Prozesse, die längere Zeit keine Zeitscheibe zugeteilt bekommen haben, werden in der Priorität temporär heraufgestuft.&lt;/dd&gt;
&lt;dt&gt;Wall Clock Time:&lt;/dt&gt;
&lt;dd&gt;Reale (gestoppte) Laufzeit eines Prozesses.&lt;/dd&gt;
&lt;dt&gt;Cpu Time:&lt;/dt&gt;
&lt;dd&gt;Zeit, die ein Prozess tatsächlich ablaufend auf der CPU verbracht hat. Typischerweise viel weniger als ein Zehntel der wall clock time.&lt;/dd&gt;
&lt;/dl&gt;
</description>
    </item>
    
  </channel>
</rss>

