<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>postgres on Die wunderbare Welt von Isotopp</title>
    <link>/tags/postgres.html</link>
    <description>Recent content in postgres on Die wunderbare Welt von Isotopp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 19 Sep 2011 00:00:00 +0000</lastBuildDate><atom:link href="/tags/postgres/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Checkpoint Blues</title>
      <link>/2011/09/19/checkpoint-blues.html</link>
      <pubDate>Mon, 19 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/09/19/checkpoint-blues.html</guid>
      <description>Wer dies und dies gelesen hat, versteht mehr.
InnoDB ist eine Storage Engine, die mit Hilfe von MVCC Transaktionen implementiert. Transaktionen zu implementieren bedeutet, daß man in der Lage ist, mehrere Änderungen zusammenzufassen und als eine Einheit als gültig zu markieren oder zurück zu nehmen. Damit das Ganze trotzdem schnell ist, muß man ein wenig herumtricksen.
Angenommen, wir wollen eine Spalte in einer Zeile in der Tabelle t ändern:
UPDATEtSETx=17WHEREid=3Dann muß InnoDB das zunächst einmal in eine Zeilennummer in einer Speicherseite übersetzen: InnoDB speichert Daten in Seiten von 16 KB (Defaultgröße) ab, und macht allen I/O in Richtung Tablespace immer nur in ganzen Seiten.</description>
    </item>
    
    <item>
      <title>Neue Releases im Datenbankland</title>
      <link>/2011/09/13/neue-releases-im-datenbankland.html</link>
      <pubDate>Tue, 13 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>/2011/09/13/neue-releases-im-datenbankland.html</guid>
      <description>MongoDB 2.0 ist draußen, und implementiert eine Reihe interessanter neuer Dinge, die ich anderswo gerne hätte, insbesondere im Bereich Replica Sets .
Postgres hat das Release 9.1 draußen. Die versprochene synchrone Replikation ist jetzt verfügbar, sie ist grob vergleichbar mit der Semisynchronen Replikation in MySQL 5.5. Ein wesentlicher Unterschied ist, daß man bei Postgres einzelne, bestimmte Server als synchrone Slaves benennen kann, während MySQL nur garantiert, daß es mindestens einen (wechselnden) Slave gibt, der synchron repliziert hat.</description>
    </item>
    
    <item>
      <title>Red vs Blue at Oracle, und ein paar Gedanken zu Postgres</title>
      <link>/2010/11/04/red-vs-blue-at-oracle-und-ein-paar-gedanken-zu-postgres.html</link>
      <pubDate>Thu, 04 Nov 2010 00:00:00 +0000</pubDate>
      
      <guid>/2010/11/04/red-vs-blue-at-oracle-und-ein-paar-gedanken-zu-postgres.html</guid>
      <description>Ich schrieb :
 heretic666 schrieb am 4. November 2010 12:11
&amp;hellip;das man nicht auch wahlweise mit PostgreSQL oder MS SQL erschlagen kann?
Mir fällt da im Moment kein Punkt ein&amp;hellip;
 Postgres ist ein Repräsentant der klassischen Datenbanken und fällt in dieselbe Kategorie wie Oracle, MS SQL oder DB/2. MySQL ist eine Datenbank, die sich in vielen Punkten an den Erfordernissen des Webs orientiert und ganz andere Schwerpunkte als Postgres oder Oracle setzt.</description>
    </item>
    
    <item>
      <title>Covering indexes und MVCC</title>
      <link>/2010/09/09/covering-indexes-und-mvcc.html</link>
      <pubDate>Thu, 09 Sep 2010 00:00:00 +0000</pubDate>
      
      <guid>/2010/09/09/covering-indexes-und-mvcc.html</guid>
      <description>Für viele MySQL-Anwendungen sind Covering Indexes eine wichtige Sache. Domas hat einen Artikel darüber Wie Wikipedia von Covering Indexes profitiert , und auch sonst sind solche Indices für viele MySQLer ein täglicher Bestandteil der Optimierungsarbeit.
Nun las ich neulich in einem Artikel eine Seitenbemerkung, daß Postgres keine Covering Indices unterstützt und das scheint tatsächlich der Fall zu sein , auch wenn ich in der Doku selber keine Hinweise darauf gefunden habe.</description>
    </item>
    
  </channel>
</rss>
