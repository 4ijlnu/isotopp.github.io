<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>monitoring on Die wunderbare Welt von Isotopp</title>
    <link>/tags/monitoring.html</link>
    <description>Recent content in monitoring on Die wunderbare Welt von Isotopp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/monitoring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>On the Observability of Outliers</title>
      <link>/2020/11/19/on-the-observability-of-outliers.html</link>
      <pubDate>Thu, 19 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/11/19/on-the-observability-of-outliers.html</guid>
      <description>At work, I am in an ongoing discussion with a number of people on the Observability of Outliers. It started with the age-old question “How do I find slow queries in my application?” aka “What would I want from tooling to get that data and where should that tooling sit?”
 As a developer, I just want to automatically identify and isolate slow queries!
 Where I work, we do have SolarWinds Database Performance Monitor aka Vividcortex to find slow queries, so that helps.</description>
    </item>
    
    <item>
      <title>The lack of developer centric MySQL monitoring - a rant</title>
      <link>/2020/03/18/the-lack-of-developer-centric-mysql-monitoring.html</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/2020/03/18/the-lack-of-developer-centric-mysql-monitoring.html</guid>
      <description>So where I work we have a large number of MySQL instances. They are organized in a slightly smaller number of replication hierarchies, which tend to cross region boundaries.
Structure of a large database setup   A rough sketch of the setup we have. Variants of this exist in various sizes - from 6 replicas in 3 regions to hundreds of replicas per region, with Group Replication at the top and per Region Intermedia Master.</description>
    </item>
    
    <item>
      <title>Monitoring - the data you have and the data you want</title>
      <link>/2017/08/09/monitoring-the-data-you-have-and-the-data-you-want.html</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/08/09/monitoring-the-data-you-have-and-the-data-you-want.html</guid>
      <description>So you are running systems in production and you want to collect data from your systems. You need to build a monitoring system. That won&amp;rsquo;t work and it won&amp;rsquo;t scale. So please stop for a moment, and think. What kind of monitoring do you want do build? I know at least three different types of monitoring system, and they have very different objectives, and consequently designs.
Three types of Monitoring Systems   The first and most important system you want to have is checking for incidents.</description>
    </item>
    
    <item>
      <title>Understanding sysdig</title>
      <link>/2017/04/20/understanding-sysdig.html</link>
      <pubDate>Thu, 20 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/04/20/understanding-sysdig.html</guid>
      <description>The open source sysdig is a piece of software that does not quite, but almost, what strace or oprofile do: It instrument the kernel, and traces system calls as well as a few other kernel activities.
Youtube: Sysdig Open Source - Getting Started With Csysdig It does not utilize the ptrace(2) kernel facility, though, but its own interface. This interface picks up data in the kernel and writes it into a ring buffer.</description>
    </item>
    
    <item>
      <title>House und Heisenberg revisited</title>
      <link>/2012/09/25/house-und-heisenberg-revisited.html</link>
      <pubDate>Tue, 25 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>/2012/09/25/house-und-heisenberg-revisited.html</guid>
      <description>Ich habe heute an dem Problem weiter geforscht und wir haben etabliert, dass die Ursache nicht der Quelltext des betreffenden Diamond-Collectors sein kann.
Auf allen betroffenen Kisten habe ich dann gesehen, daß die entsprechenden Queries gegen Performance-Schema ein
mysql&amp;gt;select\*fromperformance_schema.threads;Emptyset(0.01sec)zurück liefern.
Weitere Untersuchung stellt heraus: P_S ist aber an. Jedoch:
mysql&amp;gt;select\*fromperformance_schema.setup_instruments;Emptyset(0.03sec)mysql&amp;gt;select\*fromperformance_schema.setup_timers;Emptyset(0.01sec)mysql&amp;gt;select\*fromperformance_schema.setup_consumers;Emptyset(0.02sec)und das bleibt auch so, sogar über Server-Restarts hinweg. Warum ist das so?
# cd /mysql/\*/data/performance_schema/ # ls -l total 1840 -rw-rw---- 1 mysql mysql 8624 Oct 6 2011 cond_instances.</description>
    </item>
    
    <item>
      <title>Der Herr House und der Herr Heisenberg haben Replication Delay</title>
      <link>/2012/09/24/der-herr-house-und-der-herr-heisenberg-haben-replication-delay.html</link>
      <pubDate>Mon, 24 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>/2012/09/24/der-herr-house-und-der-herr-heisenberg-haben-replication-delay.html</guid>
      <description>Heute erreicht mich eine Mail, in der ein DBA sich über steigende Replication Delay in einer bestimmten Replikationshierarchie beschwert.
Das ist schlecht, denn die betreffende Hierarchie ist wichtig. Also die &amp;lsquo;Wenn die nicht geht schlafen Leute unter Brücken&amp;rsquo;-Art von wichtig.
Die Theorie war, daß die Änderungsrate in dieser Hierarchie so hoch ist, daß die Schreiblast von MySQL Replikation, die ja Single Threaded ist, nicht mehr bewältigt werden kann. Für diese Theorie sprach nach dem ersten Augenschein, daß alle betroffenen Kisten keine lokalen Platten hatten, sondern auf einem Filer lagen, und Filer sterben wegen der hohen Kommunikationslatenz im SAN bei uns in der Regel weit vor lokalen Platten, wenn es um Replikation geht: Filer sind mehr so beim parallelen Schreiben mit mehreren Threads gut.</description>
    </item>
    
    <item>
      <title>Wie man einen Graph plottet</title>
      <link>/2012/03/12/wie-man-einen-graph-plottet.html</link>
      <pubDate>Mon, 12 Mar 2012 00:00:00 +0000</pubDate>
      
      <guid>/2012/03/12/wie-man-einen-graph-plottet.html</guid>
      <description>Ein total kaputtes Stück Graph.
Das da ist das, was ich bekomme, wenn ich mir eine Woche Daten in dem Datenbank-Monitoringprodukt meiner Wahl anschaue. Aber das spielt keine Rolle. Ich kann mir so ziemlich jeden Zeitreihengraphen anschauen, aus so ungefähr jedem Stück Software, das mir zur Installation zur Verfügung steht, und falls es nicht rrdtools ist, ist es genau so kaputt.
Das ist bemerkenswert, weil der Plot wahrscheinlich von einem Rudel Diplom- oder Master-Abgänger gebaut worden ist.</description>
    </item>
    
    <item>
      <title>Wieso zehn Prozent?</title>
      <link>/2010/05/16/wieso-zehn-prozent.html</link>
      <pubDate>Sun, 16 May 2010 00:00:00 +0000</pubDate>
      
      <guid>/2010/05/16/wieso-zehn-prozent.html</guid>
      <description>In Sicherheitsmetrik heißt es als Antwort auf meinen Artikel DENIC erklärt sich :
 Wir IT-Akademiker forschen gerne an Fragen herum, die einen vagen Relitätsbezug haben, die man aber in der Praxis pragmatisch handhabt. Nach ein paar Jahren haben wir die Lösungen der Pragmatiker formal dokumentiert und wissenschaftlich nachgewiesen, was die Kollegen immer schon wussten, nämlich dass das so tatsächlich funktioniert…. Die zehn Prozent sind formal betrachtet völlig willkürlich gewählt, tatsächlich aber wohl ein Erfahrungswert, der sich aus informellen Beobachtungen typischer Vorgänge ergibt.</description>
    </item>
    
    <item>
      <title>Ein Nagios-Plugin für MySQL</title>
      <link>/2007/01/20/ein-nagios-plugin-fuer-mysql.html</link>
      <pubDate>Sat, 20 Jan 2007 00:00:00 +0000</pubDate>
      
      <guid>/2007/01/20/ein-nagios-plugin-fuer-mysql.html</guid>
      <description>Auf Sourceforge findet man Plug-in development guidelines für den Nagios Netzwerkmonitor. Demnach ist es trivial, Nagios-Plugins zu entwickeln: Der Check ist ein externes Programm, das den Returncode 0, 1 oder 2 zurückgibt und eine einzeilige Nachricht auf stdout druckt.
Tun wir das doch mal für MySQL: Wir wollen die Anzahl der Threads_connected überwachen und den Replikationsstatus: SQL-Thread und IO-Thread müssen laufen und der Slave-Lag darf nicht zu groß sein.
Wir schreiben das Plugin in C, damit wir zugleich mal lernen, die MYSQL Client-API in C zu verwenden - Shellscripte, die sich das Abbrechen gibt es ja schon genug.</description>
    </item>
    
  </channel>
</rss>
