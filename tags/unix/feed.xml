<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>unix on Die wunderbare Welt von Isotopp</title>
    <link>https://blog.koehntopp.info/tags/unix.html</link>
    <description>Recent content in unix on Die wunderbare Welt von Isotopp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 08 Nov 2021 19:16:49 +0000</lastBuildDate><atom:link href="https://blog.koehntopp.info/tags/unix/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Fertig gelesen: UNIX: A History and a Memoir</title>
      <link>https://blog.koehntopp.info/2021/09/05/fertig-gelesen-unix-a-history-and-a-memoir.html</link>
      <pubDate>Sun, 05 Sep 2021 15:47:06 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2021/09/05/fertig-gelesen-unix-a-history-and-a-memoir.html</guid>
      <description>&lt;p&gt;The memoir of Brian Kernighan, and the story of how UNIX came to be and what working at Bell Labs was like at that time:
&lt;a href=&#34;https://www.amazon.de/UNIX-History-English-Brian-Kernighan-ebook/dp/B07ZQHX3R1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;UNIX: A History and a Memoir&lt;/a&gt;

 is required reading for anyone who wants to know where Unix concepts came from and what ideas were behind its inception.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.de/UNIX-History-English-Brian-Kernighan-ebook/dp/B07ZQHX3R1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2021/09/unix.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/a&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;quot;&lt;a href=&#34;https://www.amazon.de/UNIX-History-English-Brian-Kernighan-ebook/dp/B07ZQHX3R1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;UNIX: A History and a Memoir&lt;/a&gt;

&amp;quot;, Brian Kernighan&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Kernighan takes us through the history and the setting of Bell Labs, why it existed and what it did.
He explains the hardware of the time, in terms of size, power and capabilities, and why Bell did get involved into writing an Operating System, and the failure of Multics.
Unix inception and its co-evolution with the C language was a kind of response to the Multics project, at the same time pioneering novel ideas and taking tested salvageable concepts from Multics, making something new and much more useful.&lt;/p&gt;
&lt;p&gt;While he roughly follows the timeline of Unix releases, Kernighan takes short detours, including mini-biographies of his colleagues and the influence they had on the design of the system and the ideas embodied in it.
He finishes with the commercialization of Unix, Unix descendants - BSD, Minix, Linux and Plan 9, and with the closure of Bell Labs.&lt;/p&gt;
&lt;p&gt;If you work with Linux, the C language or any Unix tools, you should read this book to understand where these things came from and what formed this environment.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why do Ops and Sec people wear black</title>
      <link>https://blog.koehntopp.info/2020/08/19/why-do-ops-and-sec-people-wear-black.html</link>
      <pubDate>Wed, 19 Aug 2020 17:05:47 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2020/08/19/why-do-ops-and-sec-people-wear-black.html</guid>
      <description>&lt;p&gt;For &lt;a href=&#34;https://www.imdb.com/title/tt0108756&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;reasons that don&amp;rsquo;t need exploring at this juncture&lt;/a&gt;

 I &lt;a href=&#34;https://twitter.com/isotopp/status/1296073392655933444&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tweeted&lt;/a&gt;

&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Once upon a time there were shared boxes, on which the local Unix easily had 200-300 users, Junior Developers at a University.&lt;/p&gt;
&lt;p&gt;A /tmp/ls found easily 3-4 people per day that had . (dot) in their path.&lt;/p&gt;
&lt;p&gt;No particular reason. Why?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;and followed up with&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hope is not a strategy.&lt;/p&gt;
&lt;p&gt;Neither is &lt;code&gt;curl stackoverflow | sudo bash&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;tmpls&#34;&gt;
    &lt;a href=&#34;#tmpls&#34;&gt;
	/tmp/ls
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;I was asked to explain: &amp;ldquo;What is /tmp/ls?&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;/tmp/ls is a shell script installed as executable in /tmp/ls. If you have . (dot, the current directory) early in your path, it shadows the command /bin/ls, which you use to list the current directory.&lt;/p&gt;
&lt;p&gt;So when you &lt;code&gt;cd /tmp&lt;/code&gt; and then &lt;code&gt;ls&lt;/code&gt; you are executing my script instead of the actual &lt;code&gt;/bin/ls&lt;/code&gt; command. You are now inadvertently running my code under your permissions. When I finish my script with &lt;code&gt;exec /bin/ls &amp;quot;$@&amp;quot;&lt;/code&gt; you won&amp;rsquo;t even notice, because it will run the normal &lt;code&gt;/bin/ls&lt;/code&gt; command at the end.&lt;/p&gt;
&lt;p&gt;The mistake is to have any directory in your path that can contain code controlled by another person besides you and root. That is, a world-writeable &lt;code&gt;/usr/local/bin&lt;/code&gt; in - say - an AIX install would amount to the same exposure (A lot of old Unices such as AIX, HP/UX and SGI would ship with world writeable directories of one kind or the other by default).&lt;/p&gt;
&lt;h2 id=&#34;the-777-root-cron&#34;&gt;
    &lt;a href=&#34;#the-777-root-cron&#34;&gt;
	The 777 root cron
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The same scenario is a script globally installed on all Macs by JAMF, running through cron as root every minute. The same JAMF sets the enclosing directory to 777 (full access for everybody). Due to how permissions work in Unix, this allows anybody to remove, rename or replace the script itself, no matter what the script permissions are.&lt;/p&gt;
&lt;p&gt;It is instant root for anybody who cares: You replace the script with your own content, wait a minute for the cron to hit it, and put the original script back. Or not, depending on how you feel that day.&lt;/p&gt;
&lt;p&gt;The remarkable part of this particular incident is that none of the multitude of endpoint security products also installed by the same JAMF detected or quarantined this script. So much for that.&lt;/p&gt;
&lt;h2 id=&#34;the-world-writeable-fileshare&#34;&gt;
    &lt;a href=&#34;#the-world-writeable-fileshare&#34;&gt;
	The world writeable fileshare
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Other fun things that should not have happened: A university of applied science exported their AIX home directories by NFS, world-writeable, once. That is, for several years, their site was a well known Shell-o-matic.&lt;/p&gt;
&lt;p&gt;Why is this bad?&lt;/p&gt;
&lt;p&gt;Anybody who mounted this on their own machine could create a user account with a matching UID, go into the mounted user home and drop a .rlogin file of appropriate content (The .rlogin reference should tell you how old that is).&lt;/p&gt;
&lt;p&gt;The fun part is that the university in question eventually migrated to Solaris, and that included all the&amp;hellip; interesting configuration.&lt;/p&gt;
&lt;p&gt;Apparently SMB fileshares can serve the same purpose. Also, Windows always has . (dot) in the front of the path, implicitly.&lt;/p&gt;
&lt;h2 id=&#34;external-storage&#34;&gt;
    &lt;a href=&#34;#external-storage&#34;&gt;
	External storage
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;A lot of people have world-readable backup devices such as a 644 /dev/rmt. If the backup tape from last night is left in that drive it does not matter much what the permissions on the original files are.&lt;/p&gt;
&lt;p&gt;You can read the files from backup, and restore them with any permission you like.&lt;/p&gt;
&lt;h2 id=&#34;this-makes-me-sad&#34;&gt;
    &lt;a href=&#34;#this-makes-me-sad&#34;&gt;
	This makes me sad
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;For some reasons each of these things, all of which are from personal experience up to 25 years ago, still happen today.&lt;/p&gt;
&lt;p&gt;That is why ops people wear black. Now you know.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Everything was a file, but we got better</title>
      <link>https://blog.koehntopp.info/2019/11/14/everything-was-a-file-but-we-got-better.html</link>
      <pubDate>Thu, 14 Nov 2019 11:42:07 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2019/11/14/everything-was-a-file-but-we-got-better.html</guid>
      <description>&lt;p&gt;I fell into the Twitters again. &lt;a href=&#34;https://twitter.com/carrickdb/status/1194842452361789441&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@CarrickDB&lt;/a&gt;

 joked about Unix,
Files and Directories:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/carrickdb/status/1194842452361789441&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/everything-is-a-file.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/a&gt;

&lt;/p&gt;
&lt;p&gt;And that is a case of &amp;ldquo;Haha, only serious&amp;rdquo;. Because directories
used to be files, and that was a bad time. Check out the V7 Unix
&lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/mkdir.c#L49&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mkdir&lt;/a&gt;


command. At this point in history we do not have a &lt;code&gt;mkdir(2)&lt;/code&gt;
syscall, yet, so we need to construct the entire directory in
multiple steps.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/mkdir.c#L49&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;mknod(2)&lt;/code&gt; an inode that has the &lt;code&gt;S_IFDIR&lt;/code&gt; flag set&lt;/a&gt;

,
even if that macro does not even exist yet.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/mkdir.c#L57&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;manually link the entry for the current directory &lt;code&gt;.&lt;/code&gt; into that&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/mkdir.c#L64&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;manually link the entry for the parent directory &lt;code&gt;..&lt;/code&gt; into that&lt;/a&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This fragile and broken: &lt;code&gt;mkdir&lt;/code&gt; could be interrupted while
doing that or another program could try to race &lt;code&gt;mkdir&lt;/code&gt; while it
is doing that. In both cases we get directories that are invalid
and dangerous to traverse, because they break crucial
assumptions users make about directories.&lt;/p&gt;
&lt;p&gt;This is also before &lt;code&gt;readdir(2)&lt;/code&gt; and friends, so programs like
&lt;code&gt;ls&lt;/code&gt; &lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/ls.c#L304&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;open directories like files&lt;/a&gt;


and then make assumptions about the format of dentries on disk.
Specifically, they assume a 16 bit inode number and then a
filename of 14 characters or less and a directory that is an array
of these entries. Unfortunately, time has not been kind to the
assumption of 65535 files or less per partition, and also we
require filenames that are longer than 14 bytes these days.&lt;/p&gt;
&lt;p&gt;Finally have a look at the hot mess that the
&lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/rmdir.c#L29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rmdir&lt;/a&gt;


command is. What could probably go wrong?&lt;/p&gt;
&lt;p&gt;Well, &lt;a href=&#34;https://twitter.com/opheleon/status/1194941703632932865&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jan Kraetzschmar&lt;/a&gt;


reminds us that this kind of non-atomic rmdir can also produce
structures in the filesystem that are disconnected from the main
tree starting at &lt;code&gt;/&lt;/code&gt;. In that case you end up with orphaned, unreachable
inodes that still have a non-zero link count. &lt;code&gt;fsck&lt;/code&gt; should be
able to find them and free them, but of course that would be a
disruptive operation. Making &lt;code&gt;mkdir&lt;/code&gt; and &lt;code&gt;rmdir&lt;/code&gt; system call avoids
all of these problems.&lt;/p&gt;
&lt;p&gt;That&amp;rsquo;s why all of this was fixed in 1984 or so, when BSD
FFS came around and we got long filenames, wider inodes,
&lt;code&gt;mkdir&lt;/code&gt;, &lt;code&gt;rmdir&lt;/code&gt; and &lt;code&gt;readdir&lt;/code&gt; as syscalls and many other
improvements.&lt;/p&gt;
&lt;h2 id=&#34;what-if-really-everything-was-a-file&#34;&gt;
    &lt;a href=&#34;#what-if-really-everything-was-a-file&#34;&gt;
	What if really everything was a file?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Another decade later, around 1995 or so, we got Plan 9, not from
outer space, but from Bell Labs.&lt;/p&gt;
&lt;p&gt;It not only brought us Unicode everywhere, but also an
exploration of &amp;lsquo;What if really everything was a file?&amp;rsquo;,
including other machines on the network and processes on our
machine. From that we get todays
&lt;a href=&#34;https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs#/proc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;procfs&lt;/a&gt;


in Linux (and in many other modern Unices).&lt;/p&gt;
&lt;p&gt;Except that you can&amp;rsquo;t &lt;code&gt;rm -rf /proc/1&lt;/code&gt; to shut down the box.&lt;/p&gt;
&lt;h2 id=&#34;things-that-still-are-not-a-file-and-should-be-dead&#34;&gt;
    &lt;a href=&#34;#things-that-still-are-not-a-file-and-should-be-dead&#34;&gt;
	Things that still are not a file, and should be dead
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;I am not going to mention System V IPC here at all. Not shm, not
sem, and not msq. They are abominations that should never have
escaped the lab cages they have been conceived in.&lt;/p&gt;
&lt;p&gt;There is &lt;code&gt;mmap&lt;/code&gt;, and mmap is good. Or can be, as long as you do
not conflate in memory and on disk representations of data, and
understand the value of MVCC. But that is another story and
should be told another day.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>But is it atomic?</title>
      <link>https://blog.koehntopp.info/2018/11/29/but-is-it-atomic.html</link>
      <pubDate>Thu, 29 Nov 2018 15:38:05 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2018/11/29/but-is-it-atomic.html</guid>
      <description>&lt;p&gt;From &lt;a href=&#34;https://pluspora.com/posts/310948&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pluspora&lt;/a&gt;

&lt;/p&gt;
&lt;h2 id=&#34;but-is-it-atomic&#34;&gt;
    &lt;a href=&#34;#but-is-it-atomic&#34;&gt;
	But is it atomic?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;So a few days ago, a colleague asked “Why do we love files on disk?” and in the course of that discussion, I made a comment that, among other things, used the assumption that somebody is updating some file on some Linux system atomically. I wrote:&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s assume we are using local files, and we do so in a managed, sane way:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All these state files are always JSON,&lt;/li&gt;
&lt;li&gt;there is a JSON schema, so
&lt;ul&gt;
&lt;li&gt;it is clear which attributes can be there,&lt;/li&gt;
&lt;li&gt;must be there, and&lt;/li&gt;
&lt;li&gt;what they mean and&lt;/li&gt;
&lt;li&gt;what changes to data mean as well.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Files are updated atomically&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And immediately the question came up: “I either misunderstand you or I have a gap in the knowledge. When writes to a file became atomic? They are not in general case.”&lt;/p&gt;
&lt;p&gt;There is &lt;a href=&#34;https://dilbert.com/strip/1995-06-24&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;a Dilbert for that&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;So let’s go back in time, it’s &lt;a href=&#34;http://silvertonconsulting.com/gbos2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Greybeards time&lt;/a&gt;

! We’re going to find out where the things you are working with are actually coming from. With sources and references.&lt;/p&gt;
&lt;h2 id=&#34;the-write2-system-call&#34;&gt;
    &lt;a href=&#34;#the-write2-system-call&#34;&gt;
	The write(2) system call
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;A write(2) system call is atomic. The size or amount of data written does not matter. How come?&lt;/p&gt;
&lt;p&gt;The system call will, before trying to write data to disk, lock the in-memory inode. That is, it will effectively lock the entire file. It then performs the file changes, and only then unlocks. That can take a long, long, long time, depending on the amount of data and the media the file is being stored on.&lt;/p&gt;
&lt;p&gt;It means that on a single physical file in Unix there can be only one write(2) or read(2) system call active at any point in time.&lt;/p&gt;
&lt;p&gt;One exception to this is XFS, but only when a file is opened with O_DIRECT. In this special case, XFS instead locks the byte range in a structure attached to the inode, performs the write and then unlocks. So, in XFS with O_DIRECT, any number of concurrent, non-overlapping write(2) system calls can be active.&lt;/p&gt;
&lt;p&gt;The Posix specification requires that write(2) is atomic, it does not require that only one write per file can happen.&lt;/p&gt;
&lt;h2 id=&#34;that-is-a-horrible-thing&#34;&gt;
    &lt;a href=&#34;#that-is-a-horrible-thing&#34;&gt;
	That is a horrible thing!
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The locking behavior of write(2) (and read(2)) is a problem for databases that require many concurrent writes to happen.&lt;/p&gt;
&lt;p&gt;Ingres and some other early SQL databases used to solve that problem by avoiding filesystem entirely, they recommended that tablespaces use raw disks. No filesystem, no files, no locks.&lt;/p&gt;
&lt;p&gt;Oracle solved the problem by introducing the concept of tablespaces, which are data storage spaces made up by a fleet of files, e.g. one file for each GB of data storage. Tables are assigned tablespaces, not data files directly. Since there is one write lock per inode, concurrent writes to different files in the same tablespace can happen.&lt;/p&gt;
&lt;p&gt;Only in 1994, when SGI published XFS, the actual problem was tackled by splitting the lock at the kernel level for buffer cache less writes. XFS also contained many other improvements over the 1984 BSD Fast Filing System that made it superior for concurrent I/O, streaming I/O, very large file systems, and many other modern use-cases. BSD FFS was in turn an improvement over 1974’s original Unix Filesystem.&lt;/p&gt;
&lt;p&gt;In Linux terms, the 1974 Unix Filesystem is mirrored by the Minix File system, the 1984 BSD FFS is roughly equivalent to ext2, and XFS was donated and ported to Linux by SGI, bringing that up into the tech level of 1994.&lt;/p&gt;
&lt;p&gt;Sun ZFS and Linux Btrfs are from 2004, and are a complete deviation from earlier Unix ideas. They are a different, much longer writeup, which will actually end with the git and the Blockchain.&lt;/p&gt;
&lt;h2 id=&#34;source-dive-why-are-writes-atomic&#34;&gt;
    &lt;a href=&#34;#source-dive-why-are-writes-atomic&#34;&gt;
	Source Dive: Why are writes atomic?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;“Posix requiring a file write to be atomic” comes from the behavior of the original Version 7 Unix and later systems. In there, we find the &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/sys2.c#L20&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;write(2)&lt;/a&gt;

 system call, which just calls the &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/sys2.c#L30&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;rdwr()&lt;/code&gt;&lt;/a&gt;

 function.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * write system call 
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
  &lt;span class=&#34;n&#34;&gt;rdwr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FWRITE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You are looking very old K&amp;amp;R style C code here, which predates even ANSI-C and function prototypes, by the way.&lt;/p&gt;
&lt;p&gt;So &lt;code&gt;rdwr()&lt;/code&gt; a few lines down the function calls &lt;code&gt;plock()&lt;/code&gt;, for as long as we are not dealing with a device special file (Here is where the Ingres “use raw devices” idea comes into play), then does the I/O and finally calls prele().&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_mode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFCHR&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFBLK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;plock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FREAD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;readi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;writei&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_mode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFCHR&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFBLK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;prele&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;plock()&lt;/code&gt; is what locks the actual inode and the origin of the observed behavior. It is is a misnomer, it’s not a pipe lock, it’s an inode lock.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Lock a pipe.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * If its already locked,
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * set the WANT bit and sleep.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;plock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;register&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ILOCK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IWANT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;caddr_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PINOD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ILOCK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;See the locking loop here: As as we do not have the lock, indicate desire to get the lock, then sleep on a lock release. When we exit the loop (because the inode is unlocked), lock the inode.&lt;/p&gt;
&lt;p&gt;These are simple C Code lines, not special magic macros that translate into special magic TAS machine instructions. That is because the code here is so old that it comes from a world where we have single-die, single-core, single-thread CPUs. If your code is actually running (and this is kernel code!), then you are alone in the entire system. There is nobody else touching these variables as long as you have the CPU.&lt;/p&gt;
&lt;p&gt;Under the lock, &lt;code&gt;rdwr()&lt;/code&gt; above calls &lt;code&gt;writei()&lt;/code&gt;. And &lt;code&gt;writei()&lt;/code&gt; has a do loop which uses variables from the u-Area.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;	&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BSHIFT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;on&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BMASK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BSIZE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFBLK&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFMPB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B_WRITE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;dev&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_dev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BSIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
			&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getblk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;iomove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b_un&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b_addr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B_WRITE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_error&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;brelse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;bdwrite&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
		   &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFDIR&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFREG&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IUPD&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ICHG&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The u-Area of a process at that time was a common data structure that the userland and the kernel used to communicate. Here it is being used to shift syscall parameters into the kernel. The write writes the data at &lt;code&gt;u.u_base&lt;/code&gt; in userland into the current inode, at &lt;code&gt;u.u_offset&lt;/code&gt; bytes in the file. There are &lt;code&gt;u.u_count&lt;/code&gt; many bytes to write.&lt;/p&gt;
&lt;p&gt;We convert the &lt;code&gt;u.u_offset&lt;/code&gt; into a logical block number (the n-th block of a file), and an offset &lt;code&gt;on&lt;/code&gt; within the block. We need to call &lt;code&gt;bmap()&lt;/code&gt;. This function turns an inode number and block number within the file into a physical block number on a device.&lt;/p&gt;
&lt;p&gt;We can then bring the relevant physical block into the buffer cache, using &lt;code&gt;bread()&lt;/code&gt;, and then use &lt;code&gt;iomove()&lt;/code&gt; to modify and dirty the block. As we &lt;code&gt;brelse()&lt;/code&gt; it, it will eventually be written back to disk later.&lt;/p&gt;
&lt;p&gt;There is an optimization here:&lt;/p&gt;
&lt;p&gt;When the write is a full block, we do not read the block from disk. We just allocate a buffer using &lt;code&gt;getblk()&lt;/code&gt;, and fill it. It will overwrite the data on disk completely, there is no old and new data to merge. Disk accesses are slow, in the 1970ies even more so than today, so not reading data that you are going to obliterate completely pays off substantially.&lt;/p&gt;
&lt;p&gt;The loop continues as long as there are no errors and still blocks to write.&lt;/p&gt;
&lt;p&gt;As we return from &lt;code&gt;writei()&lt;/code&gt;, &lt;code&gt;rdrw()&lt;/code&gt; resumes and will eventually &lt;code&gt;prele()&lt;/code&gt; the inode lock.&lt;/p&gt;
&lt;h2 id=&#34;how-old-is-this-stuff&#34;&gt;
    &lt;a href=&#34;#how-old-is-this-stuff&#34;&gt;
	How old is this stuff?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;This is of course extremely old code, original V7 unix, almost as old as me: git blames places its age at 41 years. I was in the third class of a German basic school when this was written.&lt;/p&gt;
&lt;p&gt;I chose this implementation, because it is very simple, and because it is also what became immortalised in the performance destroying standard which we got to know as Posix File System Semantics.&lt;/p&gt;
&lt;h2 id=&#34;homework&#34;&gt;
    &lt;a href=&#34;#homework&#34;&gt;
	Homework
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;You can have fun to find the matching functionality in a &lt;a href=&#34;https://github.com/torvalds/linux&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;modern Linux kernel&lt;/a&gt;

, threads, multicore, capabilities, namespaces, cgroups and dynamic data structures and all.&lt;/p&gt;
&lt;p&gt;Compare code readability and complexity. Discuss. Is this progress? Why do you think so?&lt;/p&gt;
&lt;p&gt;You can try to get a &lt;a href=&#34;http://160592857366.free.fr/joe/ebooks/ShareData/Design%20of%20the%20Unix%20Operating%20System%20By%20Maurice%20Bach.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;copy&lt;/a&gt;

 of “&lt;a href=&#34;https://www.amazon.de/Design-UNIX-Operating-System-Prentice/dp/0132017997&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Design of the Unix Operating System&lt;/a&gt;

” by Maurice J. Bach. It will take you on a guided tour through the origins of our craft and the legacy we build on. The topics discussed in this note can be found on the pages 101ff, “WRITE” and “FILE AND RECORD LOCKING”.&lt;/p&gt;
&lt;p&gt;If you are into operating systems, continue reading after Bach: “&lt;a href=&#34;https://www.amazon.de/Design-Implementation-4-3Bsd-Operating-System/dp/0201061961&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Design and Implementation of the 4.3 BSD Operating System&lt;/a&gt;

” builds on Bach’s work and showcases the progress and inventions that Kirk McKusick, Sam Leffler et al made after that.&lt;/p&gt;
&lt;p&gt;If you are into comparative operating system design, read “&lt;a href=&#34;https://www.amazon.com/Inside-Windows-NT-Helen-Custer/dp/155615481X&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Inside Windows NT&lt;/a&gt;

” by Helen Custer after Bach and Leffler/McKusick, and try to understand the different ideas and world view behind that.&lt;/p&gt;
&lt;h2 id=&#34;but-we-dont-use-write2-for-atomic-file-updates&#34;&gt;
    &lt;a href=&#34;#but-we-dont-use-write2-for-atomic-file-updates&#34;&gt;
	But we don’t use write(2) for atomic file updates!
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Well, some of us do, but I agree that it is hard to get right: write(2) and writev(2) are very hard to handle properly in applications, as you need to write everything in a single call.&lt;/p&gt;
&lt;p&gt;Most programs use another atomic operation in Unix, the rename(2) system call. You write file.new at your leisure, printf(), chunked writes() and all. When completed, rename file.new to file. This automatically unlinks the old version of file as well.&lt;/p&gt;
&lt;p&gt;This is also the recommended approach to atomicity, because unlike write(2) it is stable in the face of the dreaded nightmare file system.&lt;/p&gt;
&lt;p&gt;rename(2) was introduced really early in BSD Unix because of specific race problems in the V7 Unix early BSD patched and improved.&lt;/p&gt;
&lt;p&gt;Before BSD, we only had link(2) and unlink(2). You can use a combination of these syscalls to implement a rename-like operation, but you need more than one syscall to do that.&lt;/p&gt;
&lt;p&gt;In Unix, at the end of a syscall, before return to userland, the scheduler runs (Bach, Chapter 8). That is, at the end of each syscall, a process can be forced to yield the CPU. This is the cause for potential race conditions when not having a rename(2) as a single syscall, and that is why BSD came up with a single syscall for renaming files in the first place.&lt;/p&gt;
&lt;p&gt;Renaming files for atomic updates can be taken to an art form: try looking into the Maildir/ implementations as invented by qmail, and implemented in Dovecot and Cyrus&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.qmail.org/man/man5/maildir.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Maildir Man Page&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cr.yp.to/proto/maildir.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;On Maildir at DJBs site&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://danluu.com/file-consistency/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dan Luu on File Consistency&lt;/a&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And that concludes this issue of Our Systems Legacy.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dennis Ritchie (Sep 1941-Okt 2011)</title>
      <link>https://blog.koehntopp.info/2011/10/13/dennis-ritchie-sep-1941-okt-2011.html</link>
      <pubDate>Thu, 13 Oct 2011 03:39:44 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2011/10/13/dennis-ritchie-sep-1941-okt-2011.html</guid>
      <description>&lt;p&gt;Das da ist
&lt;a href=&#34;http://en.wikipedia.org/wiki/Dennis_Ritchie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dennis Ritchie&lt;/a&gt;

,
&lt;a href=&#34;http://cm.bell-labs.com/who/dmr/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;dmr&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/dennis_ritchie.jpg&#34; alt=&#34;Dennis Ritchie&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;Dennis Ritchie schrieb zusammen mit Ken Thompson und vielen anderen Menschen
in den späten 60er und den 70er Jahren die ersten Versionen des
Unix-Betriebssystems, von dem viele der Systeme, die wir heute einsetzen,
direkt abstammen oder substantiell beeinflußt wurden. Zusammen mit Brian
Kernighan entwarf er die Programmiersprache C. Ritchie schrieb auch die
Dokumentation zu diesen Systemen, und jeder Informatikstudent auf diesem
Planeten hat seine Bücher &amp;lsquo;The C Programming Language&amp;rsquo; und eine Version des
&amp;lsquo;Unix Programmers Manual&amp;rsquo; lesen müssen - sie sind noch heute im Druck.&lt;/p&gt;
&lt;p&gt;1983 bekam Ritchie für seine Arbeiten den
&lt;a href=&#34;http://awards.acm.org/images/awards/140/articles/2898606.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Turing-Award&lt;/a&gt;

,
quasi den Nobelpreis für Informatiker.&lt;/p&gt;
&lt;p&gt;Es ist absolut unmöglich, mit Computern zu arbeiten und mit den Arbeiten und
den Ideen von Dennis Ritchie nicht an jedem einzelnen Tag in direkten
Kontakt zu kommen.&lt;/p&gt;
&lt;p&gt;Dennis Ritchie starb am 9. Oktober 2011. Seine Arbeit ist unsterblich.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Acht Jahre SCO-Prozeß</title>
      <link>https://blog.koehntopp.info/2011/08/31/acht-jahre-sco-proze.html</link>
      <pubDate>Wed, 31 Aug 2011 18:46:23 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2011/08/31/acht-jahre-sco-proze.html</guid>
      <description>&lt;p&gt;Im März 2003 begann die Firma, die mal Caldera hieß und sich in SCO Group
umbenannte, IBM auf eine Fantasiesumme von Schadenersatz zu verklagen, weil
Ex-Caldera sich im Besitz des Unix-Copyrights wähnte und der Auffassung war,
daß IBM im Rahmen seiner Linux-Initiative Ex-Caldera geraubmordkopiert
hätte. Sich mit den Anwälten von IBM anzulegen ist eine unglaublich gute
Idee, die der Idee, einen Feldzug in Rußland im Winter zu führen, in nichts
nachsteht. So bekam Ex-Caldera dann auch bald bescheinigt: Linux enthält
keinen original Unix-Quellcode, SCO-Caldera hatte ihr IP unter der GPL
freigegeben und hat so keinen Grund zu klagen &lt;em&gt;und&lt;/em&gt; das Copyright am
Original-Unix System V liegt übrigens nicht bei Euch, liebes Ex-Caldera,
sondern bei Novell.&lt;/p&gt;
&lt;p&gt;Heute, &lt;a href=&#34;http://www.heise.de/open/meldung/SCO-vs-Linux-Es-ist-vorbei-1333811.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;8 Jahre später&lt;/a&gt;

,
geht die Akte endgültig zu. Endlich ist dieser Zombie tot.&lt;/p&gt;
&lt;p&gt;Bester Seiteneffekt der ganzen Aktion: &lt;a href=&#34;http://groklaw.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Groklaw&lt;/a&gt;

 -
Tausende von Geeks lernen (amerikanisches) Recht, und Armeen von verteilten
Beweisfindern dokumentieren diesen Prozeß im Detail, suchen Dokumente in
alten Papierstapeln, und finden Fehler und Schwachstellen in den
Argumentationen von Ex-Caldera. Die Firma muß feststellen, daß IBMs Anwälte,
bei aller Drohkraft, nicht der eigentliche Endgegner sind: Es ist das Netz
selber, die Masse der Geeks, die sich da mobilisiert und gegenhält.&lt;/p&gt;
&lt;p&gt;Nach dem Ende des SCO-Prozesses definiert sich Groklaw mit neuer Belegschaft
um: Themen sind nun Oracle vs. Google, Patenttrolle wie Lodsys und ähnliche
Themen. An Prozessen herrscht ja seit zehn Jahren im IT-Umfeld kein Mangel.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unix-&#34;Standards&#34;</title>
      <link>https://blog.koehntopp.info/2009/07/26/unix-standards.html</link>
      <pubDate>Sun, 26 Jul 2009 17:14:50 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2009/07/26/unix-standards.html</guid>
      <description>&lt;p&gt;Die Geschichte von Unix ist eine Geschichte der gescheiterten oder unbrauchbaren Standards - ihre Zahl ist Legion.&lt;/p&gt;
&lt;p&gt;Egal in welche Richtung man schaut: Sun zum Beispiel hatte einmal einen auf Postscript basierenden Desktop - &lt;a href=&#34;http://en.wikipedia.org/wiki/NeWS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NeWS&lt;/a&gt;

, der in gewissser Weise X11 um Jahrzehnte voraus war, sich aber nie hat durchsetzen können, unter anderem deswegen, weil das Ding von Sun als Waffe gegen andere Unix-Anbieter verwendet worden war und quasi tot-lizensiert wurde, gefolgt von&lt;a href=&#34;http://en.wikipedia.org/wiki/OPEN_LOOK&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Look&lt;/a&gt;

 und dann dem Motif-basierenden &lt;a href=&#34;http://en.wikipedia.org/wiki/Common_Desktop_Environment&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CDE&lt;/a&gt;

. Speziell letzteres war endlich ein herstellerübergreifendes Projekt, das von allen kommerziellen Unix-Anbietern unterstützt wurde (siehe auch &lt;a href=&#34;http://en.wikipedia.org/wiki/Solaris_%28operating_system%29#Desktop_environments&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;den Solaris-Artikel&lt;/a&gt;

). Da Motif als Toolkit aber bis zur Obsoleszens keine freie Software war und CDE auch keine nennenswerte Weiterentwicklung erfuhr, wurde es inzwischen großflächig durch KDE oder Gnome ersetzt - beides nativ freie Software.&lt;/p&gt;
&lt;p&gt;Auch auf Ebenen weiter unten war Standardisierung schwierig und ist vielfach gescheitert - so hat &lt;a href=&#34;http://en.wikipedia.org/wiki/POSIX&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;POSIX&lt;/a&gt;

 bis heute keine Norm für Access Control Lists von Dateisystemen und entsprechend ist etwa die Kommandozeilensyntax (und Ausdrucksstärke) von Access Control Lists auf einem Mac, einem Linux und einem Solaris unterschiedlich. Schaut man sich die Datumsangaben in dem verlinkten Wikipedia-Artikel an, kann man erkennen, daß Posix ein klassischer Nachfolgestandard ist - also kein Standard, der irgendetwas definiert oder voran bringt, sondern einer, der nur eine bereits vollzogene Entwicklung dokumentiert und festschreibt. Auch hier sind Herstellerkriege um Definitionsmacht die Ursache dafür.&lt;/p&gt;
&lt;p&gt;Auf der anderen Seite findet man eine Reihe von Innovationen in Unix, die sich universell durchgesetzt haben, aber erst nachdem ein Hersteller sie in klarer Verletzung aller formellen und informellen Standards eingeführt hat. Um bei Sun zu bleiben: Die heutige Architektur von Shared Libraries (.so&amp;rsquo;s) wie wir sie kennen ist einem Alleingang von Sun geschuldet, der so erfolgreich war, daß wir ihn heute in allen Unices finden, die überlebt haben. Genau so ist das heutige Layout von Dateisystemen, also die Einführung von /var, /home, /opt und die Aufgabe der Trennung von / und /usr ein Alleingang von Sun, der so erfolgreich war, daß er über den Umweg von SVR4 in alle nennenswerten modernen Unices Einzug gehalten hat.&lt;/p&gt;
&lt;p&gt;Sun hat das damals machen können, weil sie Workstations in großer Zahl abgesetzen konnten und so die entsprechende Definitionsmacht hatten. Außerdem sind die oben genannten Innovationen Beispiele für Innovationen, die nicht totlizensiert waren und so ohne Risiko experimentell von anderen Herstellern übernommen werden konnten.&lt;/p&gt;
&lt;p&gt;Die Rolle von Sun im heutigen Unix-Markt ist eine viel kleinere - Sun hat nicht nur nach Stückzahlen, sondern vor allen Dingen nach Developer- Mindshare eine sehr viel kleinere Rolle. Sun hat immer noch Ideen, einige von denen sind sogar kopierenswert. In die nach Stückzahlen und vor allen Dingen nach Developer-Mindshare sehr viel größere Linux-Welt werden sie jedoch nicht.&lt;/p&gt;
&lt;p&gt;Die Gründe sind immer noch dieselben wie oben:&lt;/p&gt;
&lt;p&gt;ZFS und Dtrace sind zwei Ideen, die sehr kopierenswert sind, die aber aus der Sicht der Linux-Welt totlizensiert sind. Sie sind totlizensiert in dem Sinne, daß die Lizenz dieser Stücke Software frei im Sinne von DFSG sein mag, aber die Lizenz ist mit der GPL inkompatibel. Das mag Absicht oder ein unglücklicher Zufall sein, Fakt ist, daß diese Ideen so nicht direkt als Code in Linux übernommen werden können. Also entwickeln sich in Linux alternative Projekte und es ist absehbar, daß diese in den nächsten 5 Jahren die entsprechenden Sun-Konzepte verdrängen werden - falls Oracle den Kram (&lt;strong&gt;Update wegen &lt;a href=&#34;http://blog.vodkamelone.de/archives/157-BTRFS-und-die-Lizenz....html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ixs Artikel&lt;/a&gt;

:&lt;/strong&gt; gemeint ist ZFS, das ja nun wie ganz Sun auch Oracle gehört) nicht Linux-kompatibel relizensiert. Letzteres wäre immerhin denkbar, denn die BTRFS-Entwicklung wurde zu einem guten Teil von Oracle finanziert und BTRFS ist das Linux-Gegenstück zu ZFS.&lt;/p&gt;
&lt;p&gt;Ein anderes Beispiel für eine Sun-Idee, die kopierbar wäre, aber nicht kopiert wird, ist SMF - hier ist die Sun-Lösung zu häßlich oder verkopft und es gibt zu viele konkurrierende Ideen, um &lt;a href=&#34;http://en.wikipedia.org/wiki/Init#Other_styles&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;init&lt;/a&gt;

 zu ersetzen. Wahrscheinlicher ist es, daß sich Konzepte wie &lt;a href=&#34;http://en.wikipedia.org/wiki/Upstart&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstart&lt;/a&gt;

 auf breiter Front durchsetzen.&lt;/p&gt;
&lt;p&gt;Unter dem Strich bleiben einige Erkenntnisse:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Standards sind öfter als nicht Festschreibungen bereits erfolgter Standardisierungsprozesse. Sie sind meist mehr Dokumentation als Innovation.&lt;/li&gt;
&lt;li&gt;Innovation wird im Unix-Bereich oft als Abweichung von einem vermeintlich oder tatsächlich bestehenden Standard wahrgenommen und daher oft schon aus Prinzip und ungeachtet ihres Nutzens mit Kritik überzogen.&lt;/li&gt;
&lt;li&gt;In 2009 haben die verschiedenen Linux-Distributionen endlich eine solche Marktmacht, daß sie de-facto Standards setzen können, die mit großer Wahrscheinlichkeit bald in Standarddokumenten dokumentiert werden. Die Tatsache, daß Sun
die GNU Tools im Pfad vor den eigenen Tools positioniert ist Testament dieser Entwicklung.&lt;/li&gt;
&lt;li&gt;Die Tatsache, daß es einen Unterschied macht ob man Sun Tools oder GNU Tools vorne im Pfad hat (oder BSD- statt SysV-Tools vorne im Pfad plaziert), ist Dokumentation der Tatsache, daß die existierenden Standardisierungen im Unix-Bereich noch lange nicht weit genug gehen, um eine Plattform zu erzeugen, die für die Anwendungsentwicklung groß genug wäre. Kommandozeilenwerkzeuge sind aber nur ein Aspekt der Sache - das Spiel setzt sich in rpm, deb, pkg und anderen Paketformaten, tar-Versionen, Desktop-Umgebungen und so weiter fort.&lt;/li&gt;
&lt;li&gt;Andererseits dokumentiert der bisherige Erfolg von Linux, daß das gar nicht so schlimm ist - von allen Unix-Versionen außer Linux sind überhaupt nur noch Solaris und AIX übrig geblieben und beide werden immer Linux-ähnlicher. Das ist eine gute Sache, und wenn man das erst einmal akzeptiert hat, kann man sich an den Tisch setzen und konstruktiv dokumentatorische Standards verabschieden.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(geschrieben nach der Lektüre von
&lt;a href=&#34;http://www.c0t0d0s0.org/archives/5785-Thoughts-of-an-admin-starting-to-get-old-....html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jörgs Rant&lt;/a&gt;

)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Historische Kernelsourcen</title>
      <link>https://blog.koehntopp.info/2008/05/27/historische-kernelsourcen.html</link>
      <pubDate>Tue, 27 May 2008 08:08:46 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2008/05/27/historische-kernelsourcen.html</guid>
      <description>&lt;p&gt;In anderen Artikeln habe ich ja schon an Hand von &lt;a href=&#34;http://lxr.linux.no/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/&lt;/a&gt;

 Strukturen im Linux-Kernel referenziert und in Erklärungen verwendet.&lt;/p&gt;
&lt;p&gt;Auf &lt;a href=&#34;http://www.tamacom.com/tour.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tamacom&lt;/a&gt;

 gibt es zum Vergleich die Quellen von Linux 2.6, FreeBSD 7, NetBSD 4.x, OpenBSD 4.x, GNU Hurd 0.3 und OpenSolaris zum verlinken. Auch liegen dort ein UNIX V7 Kernel und ein 4.3BSD rum.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://minnie.tuhs.org/UnixTree/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Minnie&lt;/a&gt;

 hat eine schöne Sequenz wirklich alter Unix-Trees, der die Entwicklung der 70er Jahre und einige BSD-Trees miteinander vergleicht. Das älteste nützliche Zeugs von dort ist &lt;a href=&#34;http://minnie.tuhs.org/UnixTree/Nsys/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;von 1973&lt;/a&gt;

.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The nsys files are timestamped August 31, 1973. This is consistent with other known dates. The files use structs, but in December 1972 the C compiler didn&amp;rsquo;t support structs. In September 1973, the C version of the kernel finally supplanted the assembly version, and the kernel here certainly works fine.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Mit anderen Worten, wir schauen hier der gleichzeitigen Entstehung der Sprache C und des Unix-Kernels zu. So kennt der V3 Kernel &lt;a href=&#34;http://minnie.tuhs.org/UnixTree/V3/usr/man/man2/stat.2.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;noch keine GID&lt;/a&gt;

 im stat(2) Systemaufruf, und der Compiler kann noch keine &amp;ldquo;struct&amp;rdquo; - im nsys-Kernel 6 Monate später existieren beide - und andere wichtige Erfindungen werden gemacht.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://minnie.tuhs.org/UnixTree/Nsys/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Goldenes Zitat&lt;/a&gt;

:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The number of UNIX installations is now above 20&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>fork und exec vs. CreateProcess</title>
      <link>https://blog.koehntopp.info/2007/01/07/fork-und-exec-vs-createprocess.html</link>
      <pubDate>Sun, 07 Jan 2007 09:06:13 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2007/01/07/fork-und-exec-vs-createprocess.html</guid>
      <description>&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; Meine Windows-Kenntnisse sind beschränkt, veraltet und ausschließlich theoretischer Natur. Im Zweifel erzählt dieser Artikel Unsinn nach Hörensagen.&lt;/p&gt;
&lt;p&gt;Nach dem Artikel &lt;a href=&#34;https://blog.koehntopp.info/2007/01/07/fork-exec-wait-und-exit.html&#34;&gt;form, exec, wait und exit&lt;/a&gt;

 habe ich mir aber einmal meine Kopie von Jeffrey Richters &lt;a href=&#34;http://www.amazon.de/Microsoft-Windows-Programmierung-fuer-Experten/dp/3860633899/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Windows - Programmierung für Experten (Advanced Windows)&lt;/a&gt;

 (1997) gegriffen und dort nachgeschlagen, wie man sich das mit den Prozessen und Programmen unter Windows vorstellt (oder jedenfalls vor 10 Jahren vorgestellt hat).&lt;/p&gt;
&lt;p&gt;Windows hat zu diesem Zweck die Systemfunktion &lt;a href=&#34;http://msdn.microsoft.com/library/default.asp?url=https://blog.koehntopp.info/library/en-us/dllproc/base/createprocess.asp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CreateProcess&lt;/a&gt;

(10 Parameters). Die liest sich so:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;BOOL WINAPI CreateProcess(  LPCTSTR lpApplicationName,  LPTSTR lpCommandLine,  LPSECURITY_ATTRIBUTES lpProcessAttributes,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  BOOL bInheritHandles,  DWORD dwCreationFlags,  LPVOID lpEnvironment,  LPCTSTR lpCurrentDirectory,  LPSTARTUPINFO lpStartupInfo,  LPPROCESS_INFORMATION lpProcessInformation);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Die Funktion erzeugt einen neuen Prozeß und lädt in diesen ein neues Programm. Dieses wird dann gestartet. lpApplicationName ist der Pfadname des auszuführenden Programmes.&lt;/p&gt;
&lt;p&gt;lpCommandLine ist die Kommandozeile (der argv) des neuen Programmes. Sie wird als String und nicht als Vektor von Strings übergeben. Das Parsen der Kommandozeile in Wort wird also durch das Betriebssystem übernommen und kann nicht durch den Aufrufer kontrolliert werden. In Unix muß man bei execve() einen Vektor von Strings übergeben, das Zerlegen der Kommandozeile in Worte muß also durch den Aufrufer, z.B. die Shell übernommen werden. Die anderen Funktionen der exec-Familie sind Bibliotheksfunktionen, die einem hier einen Teil der Arbeit abnehmen.&lt;/p&gt;
&lt;p&gt;lpApplicationName und lpCommandLine interagieren: lpApplicationName darf NULL sein, dann wird das erste Wort von lpCommandLine nach der Zerlegung in Worte als lpApplicationName interpretiert. lpApplicationName darf ohne Endung angegeben werden, dann rät Windows die Extension bzw. probiert eine Liste von ausführbaren System-Extensions aus.&lt;/p&gt;
&lt;p&gt;lpApplicationName darf auch ein unqualifizierter Pfadname sein. In diesem Fall wird das Absuchen eines System-Suchpfades wird durch diese Funktion von Windows übernommen. In Unix führt execve() genau das Binary aus, dessen Pfadnamen man angegeben hat. Will man einen Suchpfad absuchen, muß man execve() in einer Schleife so lange ausführen, bis es nicht mehr zurück kommt.&lt;/p&gt;
&lt;p&gt;lpProcessAttributes ist kein einzelner Parameter, sondern ein Zeiger auf eine &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/aa379560.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SECURITY_ATTRIBUTES&lt;/a&gt;

-Struktur, die man ausfüllen kann und die viele Parameter enthalten kann. Die Struktur enthält eine ACL für die Discretionary Access Control, bestimmt also im wesentlichen, wer diesen Prozeß anfassen und was mit ihm machen darf. In Unix gibt es kein vergleichbares Konzept für Prozesse: Ein Prozeß hat entweder die entsprechende Capability (etwa CAP_KILL oder CAP_SYS_PTRACE) oder nicht.&lt;/p&gt;
&lt;p&gt;lpThreadAttributes erzeugt ist der passende Parameter für den in dem Prozeß zwingend enthaltenen Thread. bInheritHandles definiert, ob vererbbare Handles auf Objekte von dem neu erzeugten Prozeß geerbt werden.&lt;/p&gt;
&lt;p&gt;dwCreationFlags legt die Priorität des Prozesses und &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms684863.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;weitere Flags&lt;/a&gt;

 für den neuen Prozeß fest. In Unix würde man all dies zwischen dem fork() und dem exec() mit einzelnen Calls machen, etwa mit Calls aus der setpriority()-Familie oder mit Aufrufen nach setpgrp().&lt;/p&gt;
&lt;p&gt;lpEnvironment entspricht konzeptuell, aber nicht im Format dem envp von execve.&lt;/p&gt;
&lt;p&gt;lpCurrentDirectory ist das aktuelle Verzeichnis des neuen Prozesses. In Unix würde man den identischen Effekt erreichen, indem man zwischen dem fork() und dem exec()-Systemaufruf ein chdir() (oder chroot()) aufruft.&lt;/p&gt;
&lt;p&gt;lpStartupInfo ist ein Zeiger auf eine eine Struktur &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms686331.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;STARTUPINFO&lt;/a&gt;

, die keine Entsprechung in Unix hat, weil hier Dinge angegeben werden, die mit den Fenstern einer Anwendung zu tun haben. Unix handhabt diese Dinge komplett vom Betriebssystemkern getrennt und daher finden wir in den Betriebssystem-Primitiven zu Prozessen keine Fensterinformationen. Genaugenommen ist lpStartupInfo entweder ein Zeiger auf eine STARTUPINFO oder STARTUPINFOEX-Struktur. Was es genau ist wird mit einem Flag in dwCreationFlags angegeben. Das ist nicht typsicher, und das ist bemerkenswert, weil Windows an anderer Stelle sehr viel Wert auf solche Dinge legt.&lt;/p&gt;
&lt;p&gt;Der letzte Parameter von CreateProcess, lpProcessInformation, ist ein Referenzparameter auf eine &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms684873.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PROCESS_INFORMATION&lt;/a&gt;

-Struktur, die von Windows überschrieben und ausgefüllt wird. Wir finden dort die Handles zu unserem Prozeß und dem darin enthaltenen Thread sowie eine ProcessId und eine ThreadId.&lt;/p&gt;
&lt;p&gt;Will man das Äquivalent zu einem setuid()-Eignerwechsel in Unix in Windows durchführen, kommt dieses Konzept an seine Grenzen - so etwas ist trotz der Vielzahl der Parameter von CreateProcess() in Windows nicht vorgesehen. Man braucht eine neue Funktion, &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms682429.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CreateProcessAsUser&lt;/a&gt;

(11 Parameter).&lt;/p&gt;
&lt;h2 id=&#34;analyse&#34;&gt;
    &lt;a href=&#34;#analyse&#34;&gt;
	Analyse
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Hier wird der grundlegende Unterschied zwischen den Konzepten von Windows und Unix deutlich: Die Unix-API stammt von Mitte der 70er Jahre und hat sich in den vergangenen mehr als 30 Jahren nicht wesentlich verändert.&lt;/p&gt;
&lt;p&gt;Sie genügt heutigen Ansprüchen, weil sie alle Ansprüche nicht erfüllt - sie liefert stattdessen relativ atomare primitive Funktionen und trennt sogar auf den ersten, flüchtigen Blick zusammengehörende Dinge wie Erzeugen von Prozessen und Laden von Programmen. Dadurch muß ein Programmierer einer Anwendung entweder eine Bibliotheksfunktion verwenden, die fork() und exec() in etwas bequemeres einpackt (etwa system() oder popen()) oder all die Dinge selber machen, die Windows im Kernel für den Programmierer erledigt. fork() hat keine Parameter und execve() hat deren drei.&lt;/p&gt;
&lt;p&gt;Will man mehr, hat man die Gelegenheit, das Environment des neuen Prozesses nach dem fork() vor dem Start des neuen Programmes mit execve() von innen zu verändern.&lt;/p&gt;
&lt;p&gt;Windows dagegen erzeugt eine alles-in-einem Funktion, die für den häufigen Anwendungsfall und alle denkbaren Varianten Extraparameter hat. Windows hat dabei die Sicht von außen auf den Kindprozeß. Dies führt zu nützlichen Dingen wie einer Thread- und Prozeß DACL, ist aber konzeptuell nicht gut erweiterbar. Dinge wie ein setuid()-Aufruf zwischen fork() und exec() sind mit CreateProcess() nicht abbildbar und machen weitere Funktionen erforderlich, die noch mehr Parameter haben.&lt;/p&gt;
&lt;p&gt;Das Konzept von Unix ist auf den ersten Blick umständlich und wenig intuitiv. Es genügt von der Aufteilung her jedoch den Ansprüchen, die man als Datenbanker an eine Normalform hätte und ist daher flexibel und ohne Änderungen am Kern erweiterbar - unabhängige Konzepte sind als unabhängige Funktionen implementiert und Erweiterung erfolgt durch Einschieben weiterer Aufrufe zwischen fork() und exec(). Neben dem Vorteil der Erweiterbarkeit hat dies den Nachteil, daß mehr Systemaufrufe notwendig sind als bei Windows (Unix-Systemaufrufe müssen schnell sein, damit dieses Konzept aufgeht) und daß man unter Umständen ein Problem mit der Atomizität bekommen kann.&lt;/p&gt;
&lt;p&gt;Beispiel ist hier die Aufgabe: &amp;ldquo;Starte aus einem Debugger einen Programm in einem Kindprozeß und zwar so, daß der Kindprozeß ohne Racecondition auf der ersten Anweisung des Kindes stoppt und debugbar ist.&amp;rdquo;. Das Problem war lange Zeit nicht lösbar, und wurde von Linux durch das PTRACE_TRACEME-Flag zu ptrace() gelöst, das neben einigen anderen Dingen bewirkt, daß ein Kindprozeß nach einem execve() erst mal mit einem SIGTRAP stehen, bleibt bevor er irgendwas selber macht. Bemerkenswert ist, daß die Erweiterung möglich war, ohne das bestehende 30 Jahre alte Konzept von fork, exec und wait verändern zu müssen.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Filesysteme für theclaw (30 Jahre Unix Source)</title>
      <link>https://blog.koehntopp.info/2006/12/26/filesysteme-fuer-theclaw-30-jahre-unix-source.html</link>
      <pubDate>Tue, 26 Dec 2006 19:09:59 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2006/12/26/filesysteme-fuer-theclaw-30-jahre-unix-source.html</guid>
      <description>&lt;p&gt;&amp;mdash; Log opened Di Dez 26 15:52:09 2006&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Hey :] &lt;a href=&#34;https://blog.koehntopp.info/2006/05/08/fragmentierung-fuer-jannik.html&#34;&gt;Spitze erklaerung zu ext2.&lt;/a&gt;

&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Danke&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Bist du Kerneldeveloper?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Nein. Mysql Consultant.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Hmm. Hab da was nicht verstanden bei der Erklärung. Und zwar: Was sind Datenblockzeiger?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Die Blockadressen von Datenblöcken einer Datei.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich paste mal was&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;(0-11):9711-9722, (IND):9723, (12-267):9724-9979, (DIND):9980, (IND):9981, (268-523):9982-10237, (IND):10238, (524-779):10239-10494, (IND):10495, (780-1035):10496-10751, (IND):10752, (1036-1291):10753-11008, (IND):11009, (1292-1547):11010-11265, (IND):11266, (1548-1795):11267-11514
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Isotopp&amp;gt; Habs im
&lt;a href=&#34;%28https://blog.koehntopp.info/2006/05/08/fragmentierung-fuer-jannik.html%29&#34;&gt;Originalartikel&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;code&gt;__le32 i_block[EXT2_N_BLOCKS];&lt;/code&gt; Das ist das, was unter BLOCKS bei debugfs steht?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt;
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L211&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L211&lt;/a&gt;

: Das ist was auf der Platte steht.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Okay mal durchdenken.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Die Definition steht in
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L165&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L165&lt;/a&gt;

. Es kommen also &lt;code&gt;EXT2_NDIR_BLOCKS&lt;/code&gt; direkt, also in der Inode selbst. Das sind (0-11):9711-9722.&lt;/p&gt;
&lt;p&gt;Dann kommt ein &lt;code&gt;EXT2_IND_BLOCK&lt;/code&gt;, (IND):9723. Der steht auch in der Inode, aber der zeigt nicht auf Daten, sondern auf einen Indirect Block. Der enthält die Blocknummern der Datenblöcke, (12-267):9724-9979.&lt;/p&gt;
&lt;p&gt;Dann kommt &lt;code&gt;EXT2_DIND_BLOCK&lt;/code&gt;. Der wiederum enthält keine Blocknummern von Datenblöcken, sondern die Blocknummern von Indirect Blocks, die wiederum Blocknummern von Datenblöcken enthalten. Daher
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;em&gt;anseh&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; In der inode steht nur (DIND):9980. In DIND steht dann (IND):9981 und (IND):10238 und so weiter. Und in (IND):9981 stehen dann 9982-10237, in (IND):10238 dann 10239-10494.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; DIR steht für &amp;ldquo;direct&amp;rdquo;?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; ja&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Muss das jetzt mal kurz mit debugfs ausprobieren.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Sieh mal
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L665&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L665&lt;/a&gt;

. Das &lt;code&gt;ext2_bmap&lt;/code&gt; geht über &lt;code&gt;generic_block_bmap&lt;/code&gt; nach
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L547&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L547&lt;/a&gt;

. Und das wiederum benutzt
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L196&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L196&lt;/a&gt;

. Und da siehst du den lookup.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; okay langsam kommts&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Wenn &lt;code&gt;i_block&lt;/code&gt;&amp;lt;0 -&amp;gt; error. Wenn &lt;code&gt;i_block&lt;/code&gt;&amp;lt;&lt;code&gt;direct_blocks&lt;/code&gt;, dann direkt. Sonst IND, sonst DIND, sonst TIND. Sonst bumm.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Wart mal, nicht so schnell. Ich kann das nicht alles gleichzeitig aufnehmen. Also, die ersten zwölf Blöcke sind -direkt- in der Inode?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja. Blocknummern. Nicht Blöcke.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;code&gt;i_block&lt;/code&gt; ist schon ein element aus &lt;code&gt;i_block[]&lt;/code&gt; oder? ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Wo bist du gerade? Also in welcher zeile?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;code&gt;static int ext2_block_to_path&lt;/code&gt;. Bei der Definition da.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Kannst du eine lxr url geben bitte? Sonst wird das schwer hier. Ah, hier:
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L196&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L196&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ja&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; &lt;code&gt;i_block&lt;/code&gt; ist der 2. Parameter der Funktion, der Aufruf steht in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L547&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L547&lt;/a&gt;

. Da ist es &lt;code&gt;iblock&lt;/code&gt;,
das wird durchgereicht vom 2. Parameter von &lt;code&gt;ext2_get_block&lt;/code&gt; &lt;code&gt;iblock&lt;/code&gt;. Das wiederum ist
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L665&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L665&lt;/a&gt;

, der das über den Umweg von
&lt;a href=&#34;http://lxr.linux.no/source/fs/buffer.c#L2759&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/buffer.c#L2759&lt;/a&gt;

 aufruft.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Nicht gerade trivial.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Für den Kernel schon. Das geht da überall so, inzwischen. Man gewöhnt sich dran, das Lesen zu können. Die
Alternative ist Code Duplication, und das nervt noch mehr. Anyway, &lt;code&gt;sector_t&lt;/code&gt; ist ein unsigned 64 bit
(long long, 8 byte) in i386. Eine Blocknummer.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; In
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L556&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L556&lt;/a&gt;

, das ist die wichtige Stelle, hast du die &lt;code&gt;inode&lt;/code&gt; und den &lt;code&gt;iblock&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Die &lt;code&gt;inode&lt;/code&gt; hat das 12-Elemente direct block array usw im Speicher und &lt;code&gt;iblock&lt;/code&gt; ist der Offset. Die Frage,
die in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L556&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L556&lt;/a&gt;

 geklärt werden muss
ist: wie tief müssen wir runter steigen - für die Blöcke 0-11 gar nicht, für die Blöcke 12- einen Level und so weiter.
Das klärt &lt;code&gt;ext2_block_to_path&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Den Abstieg sehen wir dann in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L562&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L562&lt;/a&gt;

.
Und der Abstieg klappt entweder, weil das File schon einen Block hat an der Stelle &lt;code&gt;iblock&lt;/code&gt;
(&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L564&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L564&lt;/a&gt;

),
oder es klappt nicht und wir müssen Blöcke beschaffen
(nach &lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L575&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L575&lt;/a&gt;

).&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Sekunde. Bin kein Kernelmensch ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Aber das ist doch nur gewöhnliches C.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Na ja, trotzdem komplex (für mich). Erstmal eine Frage. Man hat ein FS, und will die Inode nummer 23, wie wird die gefunden?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Über die Verzeichnisse. Wir wissen, / hat die inode 2. Das ist definiert in
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L60&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L60&lt;/a&gt;

,
also lesen wir das File mit der inode 2 durch, und parsen es als
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L510&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L510&lt;/a&gt;

 Strukturen.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Sind die indodes nicht nacheinander abgepeichert in den BGs?
Also die erste BG enthält die ersten X Inodes, die zweite BG die zweiten X usw&amp;hellip;&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Aeh, ah. Ich verstehe. Userland kann nichts mit Inodes machen, nur mit Filenamen. Es gibt kein &lt;code&gt;openi()&lt;/code&gt;.
Also müssen alle Funktionen im Userland immer Namen angeben, und du kommst dann vom Namen zur Inode über das kernel-interne &lt;code&gt;namei()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ja, klar. Aber der Kernel will ja Inode X irgendwie kriegen können.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, intern. Das weiß er, weil im Superblock ja steht, wie viele Inodes pro bg vorhanden sind, und er dann aus
der Inodenummer / inodes_per_bg sofort die bg nummer ausrechnen kann, und dann sofort weiß, wo die inode
stehen muss auf der Platte. Eine Inodenummer ist also implizit auch die Blockadresse der Inode auf der Platte.&lt;/p&gt;
&lt;p&gt;Hier ist der Superblock:
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L341&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L341&lt;/a&gt;

,
und &lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L352&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L352&lt;/a&gt;

 ist
die &lt;code&gt;s_inodes_per_group&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Und die Inode wird dann in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L998&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L998&lt;/a&gt;

 gelesen.&lt;/p&gt;
&lt;p&gt;Meine Rechnung von eben ist hier
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L1012&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L1012&lt;/a&gt;

.  &lt;code&gt;(ino - 1) / EXT2_INODES_PER_GROUP(sb);&lt;/code&gt;
und &lt;code&gt;((ino - 1) % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Nix für ungut aber für mich ist der Code grad ned so hilfreich.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Was ist das Problem?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Bin grad bisschen überfordert.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Du hast eine Inode Nr 23. Du weisst, pro bg hast Du sagen wir 8192 Inodes. Und (23-1) / ext2_indes_per_group(sb) = 0.
Also ist inode 23 in bg 0.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;em&gt;wartmal&lt;/em&gt; 8192?!&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; 8192 bei 1 kb blockgroesse, 32768 bei 4kb&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Wie gross ist eine Inode nochmal?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; 128 bytes.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;linux/ext2_fs.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ext2_inode&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;und&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:~&amp;gt; make probe
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;make: &amp;#34;probe&amp;#34; ist bereits aktualisiert.
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:~&amp;gt; ./probe
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;128
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;theclaw&amp;gt; Also pro BG ist allein 1 MB bzw 4 MB an Inodes reserviert?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja. Eine bg ist 8 MB oder 128 MB gross. Schau, hast du ein ext2 da?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ja&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Dann mach mal ein &lt;code&gt;debugfs /dev/...&lt;/code&gt; da drauf. Ist read only, macht also nix kaputt. Dann mach mal &lt;code&gt;show_super_stats&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;Inodes per group:         2008
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Inode count:              26104
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;für ein &lt;code&gt;/dev/sda5     ext2     99M  6.7M   87M   8% /boot&lt;/code&gt;
und &lt;code&gt;26104*128/1024 = 3263&lt;/code&gt;, also 3263 KB oder 3.2M für alle Inodes.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Aber meine Frage ist eine Andere.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; 21:40 Isotopp&amp;gt; und das wichtigste in &lt;code&gt;struct: __le32 i_block[EXT2_N_BLOCKS];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;code&gt;i_block[12]&lt;/code&gt; ist ein indirekter Block? &lt;em&gt;aaargh&lt;/em&gt; Die Adresse eines indirekten Blockes?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja.
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L165&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L165&lt;/a&gt;

. Dort ist
&lt;code&gt;#define EXT2_IND_BLOCK EXT2_NDIR_BLOCKS&lt;/code&gt; und weiter ist
&lt;code&gt;#define EXT2_NDIR_BLOCKS 12&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Also 15 &lt;code&gt;EXT2_N_BLOCKS&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Also ist &lt;code&gt;i_block[0]&lt;/code&gt; bis &lt;code&gt;i_block[11]&lt;/code&gt; direct, &lt;code&gt;i_block[12]&lt;/code&gt; indirect, und &lt;code&gt;i_block[13]&lt;/code&gt; DIND und &lt;code&gt;i_block[14]&lt;/code&gt; TIND. Alles in allem also 15.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Sind das die Faktoren die die max. Dateigröße in ext2 bestimmen?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Das sind die Faktoren, die die maximale Blocknummer bestimmen. Dateigröße ist Blockgröße mal maximale Blocknummer.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Also ja ;) Indirekt halt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; 9711-9722: Sind das die &amp;ldquo;Adressen&amp;rdquo;?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Blocknummern, ja, Adressen auf der Platte. In
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L234&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L234&lt;/a&gt;

 siehst du als Typ uebrigens &lt;code&gt;__le32&lt;/code&gt;. Das ist definiert in
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/types.h#L172&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/types.h#L172&lt;/a&gt;

 und endet als &lt;code&gt;__u32&lt;/code&gt;, also unsigned 32 bit. Also 2^32 Blöcke. Bei 4 KB Blöcken sind das 17592186044416 Bytes, oder 16 TB, bei 1 KB Blöcken nur 4 TB.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Diese Blöcke haben aber nix mit den Blöcken bei ext2 zu tun? Oder doch?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; &lt;code&gt;show_super_stats&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; &lt;code&gt;Block size:               1024&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; In meinem Fall also auch maximale Dateigröße 4 TB. 4 Gigablocks.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Okay, dann noch eine Frage:&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; TOTAL: 1804 und Blockcount: 3608, huh? Warum *2?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Hmm, da rechnet jemand mit 512 Byte Hardwaresektoren, warum auch immer.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:~ # ls -lsi /boot/vmlinuz-2.6.13-15-default
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt; 28 1513 -rw-r--r--  1 root root 1541719 Sep 13  2005 /boot/vmlinuz-2.6.13-15-default
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Isotopp&amp;gt; Inode 28, 1513 Blöcke auf der Platte, Dateilaenge 15411719 Bytes. Rechnerisch ist  &lt;code&gt;1541719/1024 = 1505.5849&lt;/code&gt;. 7 Blöcke Verwaltungsoverhead. Und zwar&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;(0-11):11515-11526, 
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;(IND):11527, (12-267):11528-11783, 
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;(DIND):11784, (IND):11785, (268-523):11786-12041, 
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;              (IND):12042, (524-779):12043-12298, 
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;              (IND):12299, (780-1035):12300-12555, 
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;              (IND):12556, (1036-1291):12557-12812, 
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;              (IND):12813, (1292-1505):12814-13027
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;TOTAL: 1513
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Isotopp&amp;gt; (IND):11527, (DIND):11784, (IND):11785, (IND):12299, (IND):12556, (IND):12813 &amp;lt;- das sind 6.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; 1541719/1024 = 1505.5849 sind 1506. Plus 6 sind 1512.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Er meint total sei 1513. Wieso?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich versteh das sowieso nicht, warum da 1513 angezeigt wird. 1292-1505 ist das letzte und dann total 1513. Evtl noch die Metainfos dazu?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Nein, aber die DIND und IND Blocks. Für die Blöcke 12-267 wird ja ein IND gebraucht, für die Blöcke 268-1505 wird ein DIND und vier IND gebraucht. 6 blocks Extra. Siehe noch einmal
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;

. Das rechts sind die Daten. In der Inode stehen die ersten paar Datenblocknummern direkt, in der zeichnung 10, in ext2 sind es 12. Dann steht in der Inode die Nummer vom IND, und im IND die Blocknummern der Datenblöcke, hier 12-267. Das ist also 1 block overhead, wenn das file mehr als 12 blocks lang wird. Dann ein DIND, wenn der 268&amp;rsquo;te block gebraucht wird und für jeweils 256 Blocks ein IND dazu.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Du erklaerst so schnell.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # dd if=/dev/zero of=kris bs=1k count=12
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # ls -ls kris
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;12 -rw-r--r--  1 root root 12288 Dec 26 16:58 kris
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;12 Blöcke, 12288 Bytes Länge. Und nun:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # dd if=/dev/zero of=kris bs=1k count=13
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # ls -ls kris
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;14 -rw-r--r--  1 root root 13312 Dec 26 16:58 kris
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Ein 1k länger, 14 Blocks statt 12.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Wie findet man die Größen der BGs eines dateisystems heraus?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Lies &lt;code&gt;show_super_stats&lt;/code&gt; von &lt;code&gt;debugfs&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # export DEBUGFS_PAGER=cat
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # debugfs /dev/sda5
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;debugfs 1.38 (30-Jun-2005)
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;debugfs:  show_super_stats
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Inode count:              26104
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Block count:              104388
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Block size:               1024
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Blocks per group:         8192
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Inodes per group:         2008
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Inode blocks per group:   251
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Isotopp&amp;gt; Wird einiges klarer?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ein bisschen. Also wenn ich z.B. block nummer X habe, dann ist (nummer X)/(blocks per group) die BG nummer gell?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, aber das interessiert nicht. Du redest ja von Blöcken.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Der n-te Block der Datei x kann irgendwo liegen. Wo, das sagt dir die Inode.  Normal hast du ja ein File, und eine Position in einem File.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich kann doch einfach von der Adresse auf der Platte X * bytes_per_block lesen?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Na ja, als root schon. Sonst nicht. debugfs macht das ja, die Disk als raw device auf und dann direkt auf die Blöcke klettern. Niemand sonst tut so etwas ausser debugfs und fsck. Alle anderen machen FILES auf und lesen dann am OFFSET in dem File. Punkt ist, dass du normal mit Files arbeitest und nicht mit Blöcken. Der Kernel arbeitet mit Blöcken. Und er muss irgendwie vom File + Offset auf den Block kommen.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ja Klar&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Unser ext2 hier hat 1 KB Blocksize. Wir lesen das File &lt;code&gt;/boot/vmlinuz-2.6.13-15-default&lt;/code&gt; (inode 36). Und zwar am Offset 1000000 (1 mio). Der wievielte Block im File ist das?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;em&gt;denk&lt;/em&gt;. Erstmal hat man ja nur den Dateinamen.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, das kümmert uns gerade noch nicht. Offset 1 mio &amp;ndash; welcher block? 1000000/1024 = 976.5625. Also Bytes 0-1023 sind Block 0, Bytes 1024-2047 sind Block 1 und so weiter.  In unserem fall also block 976. 976*1024=999424, 1000000-999424=576. Byte 1 000 000 steht also in Block 976, an Position 576 in diesem Block.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Okay. Stop mal. Hab da gleich ne Frage dazu:&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; 21:40 Isotopp&amp;gt; und das Wichtigste in &lt;code&gt;struct: __le32 i_block[EXT2_N_BLOCKS];&lt;/code&gt;
theclaw&amp;gt; dieser kontext: &lt;code&gt;i_block[976]&lt;/code&gt; brauchen wir da also. Ack? Und dazu noch das offset dazu?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, aber den kriegen wir nicht so.
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ja, das wollte ich grad sagen. :-P Blocks 0-11 kriegen wir so. Muss man sich halt den Weg durchhangeln.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; blocks 12-267 kriegen wir über den IND (single indirect block). Und blocks 268- kriegen wir über den DIND und den passenden IND.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; 976-12=964, 964-256=708. 708/256=2.7656. Also müssen wir über den 2. IND des DIND gehen.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich weiss nicht ganz was du da rechnest.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Naja, 1 KB blockgroesse, 4 byte pro blocknummer, also 256 blockadressen pro Block. 976ter Block ist gefragt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ay&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; 12 direct blocks, also 964 blocks dahinter.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Also mit einem &amp;ldquo;indirekten block&amp;rdquo; kann man 256 andere Blöcke adressieren, wie pointer in C&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich hab noch ganz grundlegende Fragen. Was wir wirklich wollen, ist doch das mapping logische Ext2block-Adresse der Datei → physische Blockadresse. Richtig?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; In diesem speziellen Fall: ja. Die allgemeine Formulierung lautet so: Wir haben ein Quadrupel (major number, minor number, inode number, offset in bytes), das ist ein Device, eine Partition (maj, min), und in dem Device ein File (inode), und in dem File eine Byteposition. Und wir wollen ein Tripel (maj, min, blockno), also in der partition (maj, min) den zu dieser Datei gehörenden physikalischen Block.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; jo&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Weil (maj, min) bei dieser Abbildung konstant sind (wir arbeiten immer innerhalb derselben partition), vergessen wir maj und min und reden von einer Funktion die (ino, offset) auf (phy block) abbildet. Das nennt man ein Mapping. Und zwar ein Mapping für Datenblöcke. Daher heisst die funktion &lt;code&gt;bmap&lt;/code&gt;. Jedes Dateisystem hat so eine Funktion, daher reden wir hier über die bmap funktion von ext2, die heisst also sinnigerweise &lt;code&gt;ext2_bmap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Schonmal sauhilfreich. ext2_bmap: Jetzt kann ich mir was darunter vorstellen. Danke. &lt;em&gt;codesuch&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Es ist eine diskrete Funktion.&lt;/p&gt;
&lt;p&gt;y = mx+k. Das sind kontinuierliche Funktionen von R-&amp;gt;R.&lt;/p&gt;
&lt;p&gt;Wir arbeiten hier mit diskreten, endlichen Funktionen. Die werden in der Regel als Lookuptable realisiert.&lt;/p&gt;
&lt;p&gt;Es gibt also eine Wertetabelle, die jedem (ino, offset) ein (phy block) zuordnet.&lt;/p&gt;
&lt;p&gt;Die Wertetabelle &lt;em&gt;ist&lt;/em&gt; die Inode. Eine Inode ist also ein Array von Blocknummern.&lt;/p&gt;
&lt;p&gt;Wenn es ein naives Array waere, dann waere die Inode variabel groß und für große Dateien sehr, sehr gross. Das ist wenig effizient.&lt;/p&gt;
&lt;p&gt;Daher hat man die Inode komprimiert, für kleine dateien (bis 12 blocks) speichert man die Wertetabelle tatsächlich &lt;em&gt;in&lt;/em&gt; der Inode (i_blocks[0-11]),
aber stell Dir dieses Verfahren mal für 1000 Blocks vor. Das wäre doof.&lt;/p&gt;
&lt;p&gt;Also speichert man die Wertetabelle für die Blöcke 12-267 nicht in der Inode, sondern in einem für diesen Zweck bestellten block, indem indirect block und in der Inode nur den einen Eintrag für diesen Block.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich habs soweit gecheckt.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Das kann man beweisen.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # dd if=/dev/zero of=kris bs=1k count=12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;12 blocks a 1 KB (ich hab ja ein ext2 mit 1 KB blocks).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # ls -ls kris
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;12** -rw-r--r--  1 root root 12288 Dec 26 17:30 kris
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;12288 bytes lang 12 blocks belegt. Nun mal 13 KB.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # dd if=/dev/zero of=kris bs=1k count=13
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # ls -ls kris
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;14 -rw-r--r--  1 root root 13312 Dec 26 17:30 kris
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;13312 bytes, aber 14 blocks! Da ist er, der IND.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;em&gt;selbstausprobier&lt;/em&gt; Ist das die Anzahl der Blöcke für das Inode inklusive den Daten?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Das ist die Anzahl der Blöcke OHNE die inode selber (Die belegt 128 byte in der Inodetable), also Daten + IND + DIND + TIND. Kann man auch beweisen.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # dd if=/dev/zero of=kris bs=1k count=0
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # ls -ls kris
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;0 -rw-r--r--  1 root root 0 Dec 26 17:33 kris
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Isotopp&amp;gt; File mit 0 Byte belegt 0 Blocks, Inode wird also nicht gezählt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; okay. Das war hilfreich die Erklaerung, danke.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Also wir haben in der Inode das Lookup Array für eine diskrete Funktion, eine Wertetabelle,
und die Speicherung des Array ist ulkig. Und wir haben deswegen overhead, weil wir die
mit 1, 2 und 3 markierten Blöcke in
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;


irgendwann belegen müssen. Und deswegen siehst du die Sprünge - kein File hat jemals 13 Blocks.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Moment, aber das ist ja sau umständlich eine ganze Datei zu lesen dann? :)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ah! Jetzt dämmert es langsam. Ist ja nicht so, dass ext2 GUT wäre.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; So, jetzt gehen wir noch mal in den Code&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Das ist
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L665&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ext2_bmap&lt;/a&gt;

, sehr kurz. Du erinnerst dich: JEDES Dateisystem hat ein bmap.
Darum ist &lt;code&gt;ext2_bmap&lt;/code&gt; sehr kurz, es ruft &lt;code&gt;generic_block_bmap&lt;/code&gt; auf. Das wiederum ruft dann allerdings
&lt;code&gt;ext2_get_block&lt;/code&gt; auf, das die Arbeit für &lt;code&gt;generic_block_bmap&lt;/code&gt; macht. &lt;code&gt;generic_block_bmap&lt;/code&gt; kriegt also
einen Callback nach &lt;code&gt;ext2_get_block&lt;/code&gt; mitgegeben. Wir landen also in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L547&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ext2_get_block&lt;/a&gt;

. So weit so klar?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ja warte. Ich schau mir den Code gerade an.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Tut nicht not. Noch nicht. Erst mal ist nur wichtig, wie wir zu &lt;code&gt;ext2_get_block&lt;/code&gt;
kommen und wieso da ein Umweg über das &lt;code&gt;generic_block_bmap&lt;/code&gt; gemacht wird.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Nicht klar. Warte. Wo bei &lt;code&gt;ext2_get_block()&lt;/code&gt; ist das Offset?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; in &lt;code&gt;iblock&lt;/code&gt; (2. parameter), ist schon umgerechnet in eine blocknummer.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ah klar, der n. block eines inodes.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Wir sind also in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L547&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L547&lt;/a&gt;

 und sollen &lt;code&gt;iblock&lt;/code&gt;
aus &lt;code&gt;inode&lt;/code&gt; (1. parameter) fischen. Also block 976 aus file 36. Wir müssen ja nun je nach
Blockoffset unterschiedlich kompliziert die Lookuptable runterklettern. Bei blocks 0-11 wäre
alles ganz einfach, bei 12-267 kommt der IND dazu und bei den folgenden Blöcken der DIND.
Soweit das Verfahren grundsätzlich klar?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich schau mir das .gif nochmal an.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Es wird leichter, wenn du
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L196&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L196&lt;/a&gt;

 liest.
&lt;code&gt;i_block&lt;/code&gt; ist also 976. Dann schau mal in die Zeile 196. Zeile 201: &lt;code&gt;direct_blocks&lt;/code&gt; ist 12. &lt;code&gt;indirect_blocks&lt;/code&gt; ist ptrs, also 256.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;code&gt;ext2_block_to_path&lt;/code&gt;. Das &lt;code&gt;path&lt;/code&gt; hat nix mit dem Dateisystempfad zu tun, sondern mit dem Pfad, wie man zum Block kommt. Ahh.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Es geht um den Path in
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;

, ja.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Warte, ich hab eine Frage zu dem GIF. Da z.b. &amp;ldquo;1&amp;rdquo;, also der erste indirekte Block. Der koennte auf 256 weitere zeigen?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja. In unserem Beispiel ist das so, 4 byte pro blocknummer und 1 kb pro block. Bei anderen
Größen (8 byte pro blocknr, und 4 kb pro block) ist das anders. 4096/8 = 512 pro IND z.B.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; hm. Sorry, ich dachte ne Blocknummer ist 32bit?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, in unserem Beispiel ist das so. Aber es waere ja möglich, das alles mit anderen Sizes zu compilen.
Und dann soll es auch noch funktionieren. Also coden wir das alles nicht hart rein, sondern speichern die
Rahmendaten im Superblock des Filesystems und schreiben den Code ordentlich. Soweit so klar?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; jo&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Drum auch der Code in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L196&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L196&lt;/a&gt;

, Zeilen 199 bis 203.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Den ich mir grad anschaue. ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Der fragt den Superblock sb nach den Anzahl der Adressen pro Block, und bestimmt dann die &lt;code&gt;direct_blocks&lt;/code&gt;,
die Anzahl der Blockadressen pro indirect Block in &lt;code&gt;indirect_block&lt;/code&gt; und die Anzahl der Blockadressen pro Double Indirect Block.&lt;/p&gt;
&lt;p&gt;Der macht das ein wenig komisch. Erst mal &lt;code&gt;direct_blocks&lt;/code&gt;. Das ist leicht, da nimmt er nur den #define.
&lt;code&gt;indirect_blocks&lt;/code&gt; ist auch leicht, das ist ptrs, also &lt;code&gt;EXT2_ADDR_PER_BLOCK(...sb)&lt;/code&gt;, also mal im Superblock nachschlagen.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[#define EXT2_ADDR_PER_BLOCK(s)          (EXT2_BLOCK_SIZE(s) / sizeof (__u32))](http://lxr.linux.no/source/include/linux/ext2_fs.h#L100)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Block size bei uns 1024 und &lt;code&gt;sizeof __u32&lt;/code&gt; ist immer 4. Also ist mein beispiel mit 8 derzeit hypothetisch.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ein double block kann ebenfalls ptrs viele Blockadressen enthalten, also 256 Stück. Jede von denen ist ein indirect block, der 256 Datenblöcke enthält.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; also 256^2 und ein TIND für 256^3.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Nun will er das aus irgendeinem Grund nicht so rechnen, sondern mit bit shifts, also macht er 1 &amp;laquo; (ptrs_bits * 2).&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Also warte, kann man 256+256^2+256^3 Blöcke adressieren, d.h. kann ne Datei so groß sein?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, das ist auch noch ein Limit. Aber da wir nur 2^32 viele Blocknummern haben, ist bei 4 Gigablocks Schluss, also bei 4 TB (1 kb Blöcke) oder 16 TB (4 kb Blöcke).&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Okay, irgendwie so ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Du müßtest schon die Blocknummern länger machen als ein &lt;code&gt;__u32&lt;/code&gt;, damit mehr geht, dann passen aber weniger direct_blocks in eine Inode, oder die Inode wird größer.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Aber wir wollen mal weiter im Code. Schau in zeile 207. Was machen die da?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; &lt;code&gt; if (i_block &amp;lt; 0) {&lt;/code&gt;
Isotopp&amp;gt; geht das überhaupt?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Warte&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Nah, nur durch nen Programmierfehler evtl.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Welchen typ hat &lt;code&gt;i_block&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; unsigned? :) Ja, okay. Das geht überhaupt nicht.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Steht oben in der Funktion - da ist es ein LONG!&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ah, doch ein signed :)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Aber eine Blocknummer, das haben wir vorher gesehen, ist ein &lt;code&gt;__u32&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Macht das sinn?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Nein, das ist FAHALSCH!&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Sag das doch!&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Du hast gerade deinen ersten Kernelfehler gefunden.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Geil! ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Der Fehler sieht Blocknummern als signed, daher ist also nun schon bei 2 Gigablocks zu, also 2 TB und 8 TB Filesize (für 1 und 4 kb Blocksize). Aber weiter im Text, Zeile 209.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Weiter zu 212. &lt;code&gt;((i_block -= direct_blocks) &amp;lt; indirect_blocks)&lt;/code&gt; ist dir auch klar? Wir zermatschen &lt;code&gt;i_blocks&lt;/code&gt; hier als Seiteneffekt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ja bin ein C-ler. Daran scheitert die Erklaerung nicht ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Also sind wir in 216. Nun ist &lt;code&gt;i_block&lt;/code&gt; also 964 und wir ziehen 256 (&lt;code&gt;indirect_blocks&lt;/code&gt;) ab. Das sind 708. Und &lt;code&gt;double_blocks&lt;/code&gt; ist 256^2. Also true. Also speichern wir in 217: lese &lt;code&gt;EXT2_DIND_BLOCK&lt;/code&gt;, dann in 218: lese &lt;code&gt;i_block/256&lt;/code&gt; (&lt;code&gt;i_block &amp;gt;&amp;gt; ptrs_bits&lt;/code&gt;), und in 219: lese &lt;code&gt;i_block % 256&lt;/code&gt; (&lt;code&gt;i_block &amp;amp; ( ptrs - 1)&lt;/code&gt;). Dann sind wir fertig.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Wir sind wieder in &lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L547,&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L547,&lt;/a&gt;

 line 557 nun, soweit klar?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Kleinen Moment, das Bitshifting finde ich verwirrend.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; ja&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ich weiss jetzt, was &lt;code&gt;ext2_block_to_path&lt;/code&gt; macht.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Also warte mal. Lass mich mal zusammenfassen.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Naja, nicht mal so einfach zu beschreiben.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Doch schon. Dir fehlen nur die Worte.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; :] jo&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Wir haben nun offset[0], offset[1] und offset[2]. In offset[0] steht welches Feld aus der Inode wir nehmen (das DIND feld),  Wir haben dann einen Block mit 256 Feldern, und nehmen das Feld offset[1] da draus, lesen den Block und nehmen das Feld offset[2] da draus.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Naja, das sind ja Details. Mich interessiert aber eher das Design als die Implementation ;), Das geht mir schon zu sehr in die Tiefe ehrlich gesagt.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Allgemeiner: wir haben ein Array, das nicht linear ist, sondern quadratisch steigend durch Indirektion komprimiert wird, und bei unseren Randparametern ist die schrittweite 8 bit (256 entries) pro Block, also 256, 256^2, 256^3, &amp;hellip; und das ist genau die Zeichnung
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Okay. Jetzt sind meine Fragen geklärt oder? Dieses ganze Detailwissen erschlägt mich ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Der Rest sind tatsaechlich Kerneldetails. Das hier war die Logik. Der Punkt ist, dass du in &lt;code&gt;block_to_path&lt;/code&gt; durch die Faltlogik geklettert bist. Also die, die das mit DIR, IND, DIND und TIND analysiert und entscheidet.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Naja, Faltlogik?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, erst 12 direkt, dann 256 einmal gefaltet, dann 256*256 zweimal gefaltet, dann 256*256*256 dreimal gefaltet statt eines einzigen linearen Arrays das zum groessten Teil leer waere.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Hm, ich versteh zwar das System, aber nicht was das mit Falten zu tun hat ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Naja, statt eines Array mit 2 Gigaentries (Kernelbug!) hast du ein Array mit 15 Eintraegen, bei dem die ersten 12 Eintraege für sich selber stehen, der Eintrag 13 für 256 Eintraege, der Eintrag 14 für 256 Eintraege, die für 256 Eintraege stehen, steht, und der Eintrag 15 für 256 Eintraege die für 256 Eintraege, die für 256 Eintraege stehen steht. Also einmal falten, zweimal falten, dreimal falten.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Aber &amp;ldquo;falten&amp;rdquo;?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; So in etwa:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;   ___
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;___\ /___
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;theclaw&amp;gt; Was stellt das dar?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ein Eintrag, der für viele steht. Ein Blatt Papier mit zwei Knicks, ein Eintrag (der zwischen \ /) steht für Drei (___)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Und zum Schluß
&lt;a href=&#34;http://www.tamacom.com/tour.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.tamacom.com/tour.html&lt;/a&gt;

,
&lt;a href=&#34;http://www.tamacom.com/tour/kernel/unix/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.tamacom.com/tour/kernel/unix/&lt;/a&gt;

,
&lt;a href=&#34;http://www.tamacom.com/tour/kernel/unix/S/97.html#L18&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.tamacom.com/tour/kernel/unix/S/97.html#L18&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;Das, mein Freund, ist der Urvater aller bmaps, bmap in V7 Unix.&lt;/p&gt;
&lt;p&gt;Rein gehen eine &lt;code&gt;struct inode&lt;/code&gt;, die inode,  eine &lt;code&gt;daddr_t bn&lt;/code&gt;, eine blocknummer und ein &lt;code&gt;rwflag&lt;/code&gt;, das ist aber Wurst. Raus geht eine &lt;code&gt;daddr_t&lt;/code&gt; blocknummer.&lt;/p&gt;
&lt;p&gt;Also (ino, block_in_file) -&amp;gt; (phys blocknr). NADDR ist die Anzahl der Eintraege in der Inode. Also sind 0-&amp;gt; NADDR-4 die direct blocks, NADDR-3 der IND,  NADDR-2 der DIND  und NADDR-1 der TIND.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Aber den Code will ich mir jetzt nicht genauer ansehen, sorry ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Das ist derselbe Code, nur noch verquaster. Der ist ja auch 30 Jahre alt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Den Link bookmarke ich mal, das könnte noch interessant werden.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Und weil es so schön ist, sind da auch die FreeBSD, NetBSD, OpenBSD und Hurd Versionen von demselben Zeug. Und da kannst du dann sehen wie fundamental das ist, was Du da gerade anfasst. Und wie sich C-Style im Kernel in den letzten 30 Jahren so entwickelt hat. Weil das V7 Zeugs da sind etwa 30 Jahre von hier, das 4.3BSD sind ca. 20 Jahre von hier und das Linux-Zeugs ist von jetzt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Wenn ich das so seh fällt mir grad auf wie sinnvoll man seine Zeit nützen könnte ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>User und Gruppen, Prozesse und Dateien</title>
      <link>https://blog.koehntopp.info/2005/11/01/user-und-gruppen-prozesse-und-dateien.html</link>
      <pubDate>Tue, 01 Nov 2005 18:41:28 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2005/11/01/user-und-gruppen-prozesse-und-dateien.html</guid>
      <description>&lt;p&gt;Heute im Irc stellte eine Teilnehmerin den folgenden Fragenschwall:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Wie finde ich eigentlich heraus, was für Gruppen es auf einem
Linuxsystem gibt? Wie füge ich da jemanden hinzu? Lege ich den
zuerst als User an, ganz normal? Und: Wenn ich einen Ordner
anlege, der nur für eine bestimmte Gruppe zugänglich sein
soll, mache ich das doch über File Permissions, oder habe ich
falsch gedacht?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Die offensichtliche Antwort, das Nachsehen in &lt;code&gt;/etc/group&lt;/code&gt;,
funktioniert bei modernen Unixen nicht mehr zwingend, denn
Gruppendefinitionen können nicht nur in lokalen Dateien stehen,
sondern auch aus dem NIS, dem NIS+, einem LDAP oder einem Active
Directory kommen.&lt;/p&gt;
&lt;p&gt;Die folgenden Dinge wurden mit Suse Linux 10.0 getestet, sollten
so aber auch auf Solaris funktionieren.&lt;/p&gt;
&lt;h2 id=&#34;name-service-switch&#34;&gt;
    &lt;a href=&#34;#name-service-switch&#34;&gt;
	Name Service Switch
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Genauer gesagt haben moderne Unixe ein Subsystem namens Name
Service Switch. Der Name Service Switch erlaubt es dem System,
für Benutzer, Gruppen, Hostnamen, Protokolle, Service und noch
ein paar Dinge beliebige Datenquellen zu verwenden, für die
vorgefertige Module existieren.&lt;/p&gt;
&lt;p&gt;Der Name Service Switch wird durch die Datei
&lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; gesteuert. Dort findet man für jede
Datenbasis (passwd, group, hosts, &amp;hellip;) einen einzeiligen
Eintrag. Nach dem Namen der Datenbasis werden durch Leerzeichen
getrennt die Namen der Datenquellen aufgelistet, und zwar in der
Reihenfolge, in der sie durchsucht werden sollen.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;passwd: files nis
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;shadow: files nis
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;group: files nis
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;hosts: files dns
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Diese Beispielkonfiguration holt ihre Benutzerdaten für Passwd-
und Shadow-Datei sowie die Gruppen aus den lokalen Dateien und
danach aus dem NIS, und sie ermittelt Hostnamen aus der lokalen
&lt;code&gt;/etc/hosts&lt;/code&gt; und danach aus dem DNS.&lt;/p&gt;
&lt;p&gt;Die Syntax für die &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; ist noch ein wenig
komplizierter. Zwischen den Einträgen für Datenquellen können in
eckigen Klammern nämlich noch Anweisungen für das Verhalten in
Fehlerfällen stehen. Auf diese Weise sind Setups möglich, die
ihre Daten normalerweise NUR aus dem NIS ziehen, aber aus den
lokalen Dateien, falls das NIS einmal nicht erreichbar sein
sollte.&lt;/p&gt;
&lt;p&gt;Die Datenbasen des Name Service Switch lassen sich mit dem
Kommando &lt;code&gt;getent&lt;/code&gt; testen. &lt;code&gt;getent group&lt;/code&gt; listet zum Beispiel die
gesamte &lt;code&gt;group&lt;/code&gt;-Datenbasis auf, &lt;code&gt;getent group disk&lt;/code&gt; listet nur
den Eintrag für die Gruppe &lt;code&gt;disk&lt;/code&gt; auf.&lt;/p&gt;
&lt;p&gt;Wir merken uns:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In einem modernen Unix mit Name Service Switch ist es also
falsch, eine Liste der Gruppen des Systems durch Auslesen von
&lt;code&gt;/etc/group&lt;/code&gt; zu erzeugen. Stattdessen muß die Liste mit
&lt;code&gt;getent group&lt;/code&gt; erzeugt werden.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Das Interface des Name Service Switch ist read-only. Es erlaubt
nicht die virtualisierte Erzeugung von Gruppen. Schreibzugriffe
müssen also weiterhin manuell in die richtige Datenbank geroutet
werden, also in eine lokale Datei oder in ein LDAP geschrieben
werden.&lt;/p&gt;
&lt;h2 id=&#34;prozesse-und-dateien&#34;&gt;
    &lt;a href=&#34;#prozesse-und-dateien&#34;&gt;
	Prozesse und Dateien
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;User und Gruppen sind nur dann von Bedeutung, wenn sie auch vom
Systemteilen verwendet werden. Systemteile sind Subjekte, also
Prozesse, und Objekte, also Dateien.&lt;/p&gt;
&lt;p&gt;Ein Prozeß in Unix hat eine effektive User-ID und eine effektive
primäre Gruppen-ID. Er kann außerdem eine Reihe von weiteren
sekundären Gruppen-IDs enthalten.&lt;/p&gt;
&lt;p&gt;Das Kommando &amp;ldquo;id&amp;rdquo; listet die User- und Gruppen-IDs eines Benutzers:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; id -a
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;uid=1000(kris) gid=100(users) Gruppen=16(dialout),33(video),100(users)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Der Benutzer kris hat also die User-ID 1000 und die primäre
Gruppen-ID 100. Er gehört außerdem den Gruppen 16 (dialout) und
33 (video) an.&lt;/p&gt;
&lt;p&gt;Wenn dieser Prozeß eine Datei erzeugt, dann gehört diese Datei
ebenfalls dem Benutzer 1000 (kris) und sie wird standardmäßig
(&amp;ldquo;System V Semantik&amp;rdquo;) der Gruppe 100 (users) angehören, denn
dies sind die primäre User- und Gruppen-ID dieses Prozesses.&lt;/p&gt;
&lt;p&gt;Es gibt eine andere Betriebsart für Dateisysteme (&amp;ldquo;BSD Semantik&amp;rdquo;), bei der neu angelegte Dateien nicht die primäre Gruppe des anlegenden Prozesses erben, sondern die Gruppe des unmittelbar übergeordneten Verzeichnisses. Man kann das ext2-Dateisystem komplett auf BSD-Semantik umstellen, indem man es mit der Option &amp;ldquo;grpid&amp;rdquo; (alternativ &amp;ldquo;bsdgroups&amp;rdquo;) mounted - der Default ist &amp;ldquo;nogrpid&amp;rdquo; (alternativ &amp;ldquo;sysvgroups&amp;rdquo;). In der Betriebsart &amp;ldquo;nogrpid&amp;rdquo; kann man für ein einzelnes Verzeichnis BSD Semantik wählen, indem man das SGID-Bit an dem Verzeichnis setzt. Hier ein Beispiel:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # lvcreate -l 10 -n test system
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Logical volume &amp;#34;test&amp;#34; created
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # mke2fs -q /dev/system/test
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # mount -o nogrpid /dev/mapper/system-test /export/test
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # mkdir /export/test/bla /export/test/fasel
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # chown kris:video /export/test/bla /export/test/fasel
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # chmod g+s /export/test/fasel
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # su - kris
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; cd /export/test
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; touch bla/eins fasel/zwei
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; ls -l bla/eins fasel/zwei
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris users 0 2005-11-01 18:59 bla/eins
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris video 0 2005-11-01 18:59 fasel/zwei
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; ls -ld bla fasel
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;drwxr-xr-x 2 kris video 1024 2005-11-01 18:59 bla
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;drwxr-sr-x 2 kris video 1024 2005-11-01 18:59 fasel
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In diesem Beispiel wird das logical Volume &lt;code&gt;test&lt;/code&gt; in der Volume
Group &lt;code&gt;system&lt;/code&gt; angelegt und mit dem ext2-Dateisystem formatiert.
Das Dateisystem wird mit der Option &lt;code&gt;nogrpid&lt;/code&gt; als /export/test
gemountet, was der Default für ext2 ist (und bei reiserfs
unveränderlich immer der Fall ist).&lt;/p&gt;
&lt;p&gt;In &lt;code&gt;/export/test&lt;/code&gt; werden die Verzeichnisse &lt;code&gt;bla&lt;/code&gt; und &lt;code&gt;fasel&lt;/code&gt; anlegt
und beide auf &lt;code&gt;kris:video&lt;/code&gt; gesetzt. An &lt;code&gt;fasel&lt;/code&gt; wird zusätzlich noch
das SGID-Bit gesetzt.&lt;/p&gt;
&lt;p&gt;Legt der User &lt;code&gt;kris:users&lt;/code&gt; nun in &lt;code&gt;bla&lt;/code&gt; und &lt;code&gt;fasel&lt;/code&gt; jeweils eine Datei
an, wird die Datei in &lt;code&gt;bla&lt;/code&gt; (System V Semantik, bzw. nogrpid) der
Gruppe users angehören. Die Datei in &lt;code&gt;fasel&lt;/code&gt; (BSD Semantik, durch
+s umgeschaltet) erbt ihre Gruppenzugehörigkeit jedoch vom
übergeordneten Verzeichnis, gehört also &lt;code&gt;kris:video&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Dasselbe Beispiel wie oben für ein Dateisystem, das mit &lt;code&gt;grpid&lt;/code&gt;
gemountet wurde, ergibt dann das folgende Bild:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; touch bla/eins fasel/zwei
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; ls -ld bla fasel
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;drwxr-xr-x 2 kris video 1024 2005-11-01 19:04 bla
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;drwxr-sr-x 2 kris video 1024 2005-11-01 19:04 fasel
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; ls -l bla/eins fasel/zwei
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris video 0 2005-11-01 19:04 bla/eins
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris video 0 2005-11-01 19:04 fasel/zwei
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das SGID-Bit am Verzeichnis hat dann also keine Wirkung mehr,
weil das Dateisystem an sich hier schon BSD-Semantik hat.&lt;/p&gt;
&lt;p&gt;Reiserfs kennt die Optionen &lt;code&gt;grpid&lt;/code&gt; und &lt;code&gt;nogrpid&lt;/code&gt; nicht und
verhält sich immer wie ein ext2-Dateissystem mit &lt;code&gt;nogrpid&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Wie kann man nun ein Verzeichnis einer Gruppe schenken? Nun, das
geht einfach mit chgrp:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; mkdir keks
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; chgrp video keks
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; chgrp disk keks
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;chgrp: Ändern der Gruppe für „keks“: Die Operation ist nicht erlaubt
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; chgrp users keks
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Offenbar kann man ein Verzeichnis nur Gruppen schenken, denen
man selbst angehört. Das ist deswegen so, weil Unix die
Zuordnung von Quotas zu Benutzern und zu Gruppen erlaubt. Indem
man eine Datei einer Gruppe schenkt, belastet die Datei die
Quota der Gruppe und natürlich darf man nur die Quota einer
Gruppe belasten, der man auch angehört.&lt;/p&gt;
&lt;p&gt;Wenn man eine Datei in einem Verzeichnis mit BSD-Semantik
anlegt, dann erbt diese Datei jedoch immer die Gruppe des
Verzeichnisses, selbst dann, wenn der Benutzer, der die Datei
anlegt, nicht dieser Gruppe angehört - hier kann dann ein
fremder Benutzer die Quota einer Gruppe belasten, der er nicht
angehört. Es ist also Aufgabe einer Gruppe, die Zugriffsrechte
an ihren Verzeichnissen so zu setzen, daß dort nicht fremde
Leute Daten ablegen können und so die Quota der Gruppe belasten.&lt;/p&gt;
&lt;p&gt;Es ist außerdem möglich (wenn auch unwahrscheinlich), daß ein
Benutzer so eine Datei anlegen kann, die er später nicht mehr
lesen darf.&lt;/p&gt;
&lt;p&gt;Das Szenario ist konstruiert, aber technisch möglich:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;gp&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# Kris legt ein Verzeichnis an&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; mkdir keks
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; chmod a+rwx,g+s keks
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; chgrp video keks
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; ls -ld keks
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;drwxrwsrwx 2 kris video 48 2005-11-01 19:17 keks
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gp&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# kdebuild legt dort eine Datei an&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kdebuild@dhcp-179:/home/kris/keks&amp;gt; umask 0727
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kdebuild@dhcp-179:/home/kris/keks&amp;gt; touch bla
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kdebuild@dhcp-179:/home/kris/keks&amp;gt; ls -l bla
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;----r----- 1 kdebuild video 0 2005-11-01 19:18 bla
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kdebuild@dhcp-179:/home/kris/keks&amp;gt; cat bla
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cat: bla: Keine Berechtigung
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das ist für ein Rechtesystem eine unschöne Situation. Fällt
jemandem ein sinnvoller Anwendungszweck für diese Eigenschaft
des Unix-Rechtesystems ein?&lt;/p&gt;
&lt;p&gt;Wir merken uns:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Um ein Verzeichnis zu erzeugen, auf das nur eine bestimmte
Gruppe Zugriff hat, legen wir das Verzeichnis an und schenken
es der Gruppe mit &lt;code&gt;chgrp&lt;/code&gt;, dann setzen wir die Zugriffsrechte
auf &lt;code&gt;rwxrwx---&lt;/code&gt; oder ähnlich.&lt;/p&gt;
&lt;p&gt;Wenn wir außerdem das SGID-Bit am Verzeichnis mit &lt;code&gt;chmod g+s …&lt;/code&gt; setzen, werden auch alle Dateien im Verzeichnis der
Gruppe gehören. Um ein Verzeichnis einer Gruppe schenken zu
können, muß man selbst Mitglied der Gruppe sein.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;zugriffsrechte-an-dateien&#34;&gt;
    &lt;a href=&#34;#zugriffsrechte-an-dateien&#34;&gt;
	Zugriffsrechte an Dateien
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In den letzten 30 Jahren war es in Unix immer so, daß eine Datei
einen Eigentümer und eine Eigentümer-Gruppe hatte. Rechte wurden
für den Eigentümer und die Eigentümer-Gruppe vergeben. Prozesse
hatten ebenfalls einen Eigentümer und eine Gruppe, und Unix hat
stur den folgenden simplen Test durchgeführt, um zu bestimmen,
welche Rechte für eine Datei gelten:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Stimmen der Datei-Eigentümer und der Prozeß-Eigentümer
überein? Wenn ja, dann gelten die User-Rechte, also das erste
rwx-Tripel. Das ist selbst dann der Fall, wenn in einem anderen
Tripel bessere Rechte definiert sind.&lt;/li&gt;
&lt;li&gt;Stimmen die Datei-Eigentümergruppe und eine der primären oder
sekundären Gruppen eines Prozesses überein? Wenn ja, dann gelten
die Gruppen-Rechte, also das zweite rwx-Tripel. Das ist selbst
dann der Fall, wenn im 3. Tripel bessere Rechte definiert
sind.&lt;/li&gt;
&lt;li&gt;In allen anderen Fällen gelten die Rechte aus dem 3. Tripel.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;access-control-lists-acls&#34;&gt;
    &lt;a href=&#34;#access-control-lists-acls&#34;&gt;
	Access Control Lists (ACLs)
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Mit modernen Unixen ist es jedoch alles viel komplizierter
geworden, denn nun können im Prinzip an einer Datei selber auch
viele Benutzer- und Gruppenrechte kleben.&lt;/p&gt;
&lt;p&gt;Zum Glück nicht per Default.&lt;/p&gt;
&lt;p&gt;Damit die Lage kompliziert wird, muß man das betreffende
Dateisystem mit der Option &lt;code&gt;acl&lt;/code&gt; mounten. Im Beispiel erzeugen
wir zur Abwechslung mal ein reiserfs und mounten dies mit der
passenden Option. Mit den Kommandos &lt;code&gt;getfacl&lt;/code&gt; und &lt;code&gt;setfacl&lt;/code&gt; (&amp;ldquo;get
and set a file access control list&amp;rdquo;) können wir dann lustig
individuelle Zugriffsrechte vergeben.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # lvcreate -l 10 -n test system
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Logical volume &amp;#34;test&amp;#34; created
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # mkreiserfs -q /dev/system/test
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;mkreiserfs 3.6.18 (2003 www.namesys.com)
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # mount -o acl /dev/mapper/system-test /export/test
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # cd /export/test
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:/export/test # touch keks
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:/export/test # chmod 000 keks
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:/export/test # setfacl -m u:kris:rwx,mask::rwx,g:video:rwx,u:kdebuild:rx keks
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:/export/test # ls -l keks
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;----rwx---+ 1 root root 0 Nov 1 19:26 keks
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:/export/test # getfacl keks
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gp&#34;&gt;# &lt;/span&gt;file: keks
&lt;span class=&#34;gp&#34;&gt;# &lt;/span&gt;owner: root
&lt;span class=&#34;gp&#34;&gt;# &lt;/span&gt;group: root
&lt;span class=&#34;go&#34;&gt;user::---
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;user:kris:rwx
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;user:kdebuild:r-x
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;group::---
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;group:video:rwx
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;mask::rwx
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;other::---
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Eine Datei mit einer ACL wird von ls mit einem &amp;ldquo;+&amp;quot;-Zeichen
markiert. Statt den Rechten der Gruppe werden dann im  zweiten
Tripel die Rechte der Mask angezeigt.&lt;/p&gt;
&lt;p&gt;Die Mask limitiert alle anderen Zugriffsrechte an der Datei
ausgenommen den Eigentümer und Others. Sie legt also quasi die
maximalen Rechte fest, die irgendjemand außer dem Eigentümer an
der Datei haben kann, wenn er nicht die Defaultrechte bekommt.&lt;/p&gt;
&lt;p&gt;Dies ist ein Kompatibilitätsmechanismus, der meistens das
korrekte Verhalten von Programmen bewirken soll, die nichts von
Zugriffsrechten wissen - sie bekommen durch Auslesen des zweiten
Rechtetripels einen etwas optimistischen View auf die Rechte,
die sie wahrscheinlich haben werden. :)&lt;/p&gt;
&lt;p&gt;Das Kommando &lt;code&gt;setfacl&lt;/code&gt; kann jetzt die Rechte an einer Datei
modifizieren. Die Option &lt;code&gt;-m&lt;/code&gt; (modify) bewirkt das.&lt;/p&gt;
&lt;p&gt;Im Beispiel werden Rechte für Benutzer (&amp;ldquo;u:&amp;quot;) und Gruppen (&amp;ldquo;g:&amp;quot;)
sowie eine Mask (&amp;ldquo;m:&amp;quot;) definiert.&lt;/p&gt;
&lt;p&gt;Liest man die ACL mit getfacl aus, wird recht schnell deutlich,
was hier geschieht:&lt;/p&gt;
&lt;p&gt;Der Eigentümer der Datei hat an ihr keine Rechte, der User kris
hat die Rechte rwx, der User kdebuild hat die Rechte rx, die
Defaultgruppe hat keine Rechte, die Gruppe video hat die Rechte
rwx, und die Maske schränkt die Rechte von kris, kdebuild, video
und der Defaultgruppe nicht ein.&lt;/p&gt;
&lt;p&gt;Der Rest der Welt hat keine Rechte an dieser Datei.&lt;/p&gt;
&lt;p&gt;Wir merken uns:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dateisysteme, die mit der Option &amp;ldquo;acl&amp;rdquo; gemounted wurden,
können beliebig komplizierte Rechteregeln pro Datei haben. Es
ist mit einem &amp;ldquo;+&amp;rdquo; an der Datei zu erkennen, ob dies der Fall
ist. Diese ACLs können mit setfacl editiert und mit getfacl
gelesen werden.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;acls-an-verzeichnissen&#34;&gt;
    &lt;a href=&#34;#acls-an-verzeichnissen&#34;&gt;
	ACLs an Verzeichnissen
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Um die Sache noch komplizierter zu machen, haben Verzeichnisse
&lt;em&gt;zwei&lt;/em&gt; ACLs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Eine normale wie wir sie schon kennen, die für das Verzeichnis
selber gilt,&lt;/li&gt;
&lt;li&gt;eine &lt;em&gt;default&lt;/em&gt; ACL, die für alle Verzeichnisse
und Dateien gilt, die in dem Verzeichnis erzeugt werden.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Werte für die Default-ACL werden festgelegt, indem man sie beim
&amp;ldquo;setfacl&amp;rdquo; mit &amp;ldquo;d:&amp;rdquo; prefixed, also &amp;ldquo;d:u:kris:rwx&amp;rdquo;,
&amp;ldquo;d:g:video:rwx&amp;rdquo; und &amp;ldquo;dⓜ️:rwx&amp;rdquo;.&lt;/p&gt;
&lt;h2 id=&#34;tldr&#34;&gt;
    &lt;a href=&#34;#tldr&#34;&gt;
	TL;DR
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Wir merken uns:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In den allermeisten Fällen tut das Unix-Rechtesystem mit den
drei Tripeln &amp;ldquo;ugo&amp;rdquo; und den drei Rechten &amp;ldquo;rwx&amp;rdquo; genau das, was
man von ihm will.&lt;/p&gt;
&lt;p&gt;Sehr selten braucht man was komplizierteres, und dann steht es
zur Verfügung.&lt;/p&gt;
&lt;p&gt;Selbst dann ist das Rechtesystem von Unix noch einfacher und
übersichtlicher zu warten als das von Windows, getreu dem
Motto &amp;ldquo;Simple things should be simple, and complex things
should be possible.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>#!/bin/bash -- Brace Expansion</title>
      <link>https://blog.koehntopp.info/2005/10/08/bin-bash-brace-expansion.html</link>
      <pubDate>Sat, 08 Oct 2005 08:43:57 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2005/10/08/bin-bash-brace-expansion.html</guid>
      <description>&lt;p&gt;Eine Unix-Kommandoshell nimmt die Benutzereingabe und unterteilt sie in Worte.
Das erste Wort einer Zeile ist ein Kommando, der Rest sind die Parameter des Kommandos.
So weit so langweilig.&lt;/p&gt;
&lt;p&gt;Interessant wird die Sache, weil eine Unix Shell gut mit Worten umgehen kann.
So kann sie Worte ersetzen und dabei auch neue Worte generieren.
Dies nennt man Expansion, und die Bash hat sehr viele Expansion-Mechanismen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brace expansion,&lt;/li&gt;
&lt;li&gt;tilde expansion,&lt;/li&gt;
&lt;li&gt;parameter expansion,&lt;/li&gt;
&lt;li&gt;variable expansion,&lt;/li&gt;
&lt;li&gt;arithmetic expansion,&lt;/li&gt;
&lt;li&gt;command substitution,&lt;/li&gt;
&lt;li&gt;word splitting und&lt;/li&gt;
&lt;li&gt;pathname expansion, sowie&lt;/li&gt;
&lt;li&gt;process substitution&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;werden in dieser Reihenfolge auf den Worten einer Zeile durchgeführt.
Nicht alle diese Mechanismen sind in einer klassischen &lt;code&gt;#!/bin/sh&lt;/code&gt; enthalten.&lt;/p&gt;
&lt;p&gt;Wenn man schnell mal ein paar Pfadnamen braucht, ist
&lt;a href=&#34;http://ebergen.net/wordpress/?p=80&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bash Brace Expansion&lt;/a&gt;


echt nützlich.
Die Grundidee ist diese:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~&amp;gt; echo a{b,c,d}e
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;abe ace ade
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das kann man benutzen, um ähnliche Dinge aufzuzählen, ohne mehr schreiben zu müssen:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/Source/tidy/src&amp;gt;ls parser.{c,h,o,lo}
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;parser.c  parser.h  parser.lo  parser.o
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Dabei ist es durchaus erlaubt, einen Teilausdruck leer zu lassen:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@h3118:/etc/httpd&amp;gt; ls -1 httpd.conf{,.old}
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;httpd.conf
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;httpd.conf.old
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Aber Brace Expansion kann noch mehr: Bestandteil des Konzeptes sind auch Ranges.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~&amp;gt; mkdir x; for i in {0..10}; do mkdir x/$i; done; ls x
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;0  1  10  2  3  4  5  6  7  8  9
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~&amp;gt; mkdir y; for i in {a..z}; do mkdir y/$i; done; ls y
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Da die Erweiterung reihenfolgetreu ist, ist es sehr leicht, zum Beispiel alte Logfiles zu rotieren. Das geht dann so:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/x&amp;gt; touch a.log
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/x&amp;gt; for i in {9..0}; do olog=a.log.$i; nlog=a.log.$(( $i+1 )); [ -f $olog ] &amp;amp;&amp;amp; mv $olog $nlog; done; mv a.log a.log.0; touch a.log; ls
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;a.log  a.log.0
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/x&amp;gt; for i in {9..0}; do olog=a.log.$i; nlog=a.log.$(( $i+1 )); [ -f $olog ] &amp;amp;&amp;amp; mv $olog $nlog; done; mv a.log a.log.0; touch a.log; ls
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;a.log  a.log.0  a.log.1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das letzte Beispiel verwendet eine weitere Bash-Expansion, Arithmethic Expansion.
Hier wird ein Ausdruck, der in &lt;code&gt;$(( ... ))&lt;/code&gt; steht, ausgerechnet und durch das Rechenergebnis ersetzt.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wieviel Load darf es denn sein?</title>
      <link>https://blog.koehntopp.info/2005/06/24/wieviel-load-darf-es-denn-sein.html</link>
      <pubDate>Fri, 24 Jun 2005 08:47:16 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2005/06/24/wieviel-load-darf-es-denn-sein.html</guid>
      <description>&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/load-beispiel.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;In
&lt;a href=&#34;http://webhostingtech.de/2106/677.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wann ist die Serverload zu hoch?&lt;/a&gt;


fragt Reimer:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Die Frage, ob ein Serverload von n zu hoch sei, höre ich häufig.
Die Antworten sind jedoch ebenso unterschiedlich.
So wird häufig die Zahl 1,00 als normaler Wert gehandelt, aber genau so fallen Zahlen wie 5,00 und 8,00 etc.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In Linux und Unix gibt es einige Zahlen, mit denen man die CPU-Auslastung des Systems ausdrücken kann.
Da ist erst einmal die momentane CPU-Auslastung in Prozent, wie sie von &lt;code&gt;top&lt;/code&gt; und anderen Tools angezeigt wird:&lt;/p&gt;
&lt;p&gt;Diese Zahl gibt detailliert Auskunft darüber, wie die CPU &lt;em&gt;in diesem Moment&lt;/em&gt; ihre Zeit verbringt:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;top - 10:49:36 up 11:53,  4 users,  load average: 2.71, 2.33, 2.20
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Tasks: 109 total,   3 running, 106 sleeping,   0 stopped,   0 zombie
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Cpu(s): 31.4% us,  8.9% sy,  0.0% ni, 47.5% id,  0.0% wa, 10.2% hi,  2.0% si
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Die Zahl &lt;code&gt;id&lt;/code&gt; ist die Idle-Zeit, die ungenutzte Zeit der CPU.
Die anderen Zahlen sagen detailliert, wie die CPU ihre Zeit verbringt: &lt;code&gt;us&lt;/code&gt; (User-Time) ist Zeit, die im Programm verbracht wird, und &lt;code&gt;sy&lt;/code&gt; (System-Time) die Zeit, die vom Kernel im Auftrag dieses Programmes verbraucht wird.
&lt;code&gt;ni&lt;/code&gt; (Nice-Time) ist Zeit, die von herunter priorisierten Prozessen sinnvoll verbraucht wird.
Alle drei Zeiten zusammen sind sinnvoll genutzte Arbeitszeit.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wa&lt;/code&gt; (Wait-Time) ist I/O-Wait, also Zeit, die der Rechner auf das Eintreffen von Daten von der Platte oder dem Netzwerk wartet.
&lt;code&gt;hi&lt;/code&gt; und &lt;code&gt;si&lt;/code&gt; (Hard- und Soft Interrupt) sind Zeiten, die das System mit der Bearbeitung von Interrupts zubringt, also in Gerätetreibern und Timer-Routinen.&lt;/p&gt;
&lt;p&gt;Die Loadzahlen geben die mittlere Länge der Run-Queue über eine Minute (erste Zahl), fünf Minuten (zweite Zahl) und 15 Minuten (dritte Zahl) an.
Die Zahl sagt, wie viele Prozessoren das System im Schnitt auslasten könnte.
Wenn also die Load 1 ist, ist ein Einprozessorsystem so in etwa ausgelastet, eine Enterprise 10000 mit 64 CPUs in einer Domain ist bei einer Load von 64 gut ausgelastet.&lt;/p&gt;
&lt;p&gt;Die Load auf meinem System ist derzeit so:&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/load-beispiel.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;Für Auslastungsabschätzungen ist die blaue Fläche aussagekräftig, denn sie stellt die 15 Minuten-Load dar.
Diese Zahl ist relativ unempfindlich gegen lokale Lastspitzen und daher ein besseres Maß für die Auslastung (im Gegensatz zur Elastizität) des Systems.
Meine Maschine läuft derzeit tagsüber mit einer Load von ca. 0.8, ist also mit einem Prozessor zu etwa 80 % voll.
Zu einzelnen Zeitpunkten (nachts um 4:15 Uhr, wenn das News-Expire läuft), wird die Ideal-Last von 1 deutlich überschritten.
Das ist zu diesem Zeitpunkt aber nicht schlimm.&lt;/p&gt;
&lt;p&gt;Die Spitzenlasten (rote Kurve: 1 Minuten-Load, und davon das Maximum) halten sich außer um 4:15 Uhr im Rahmen, die Maschine kommt nicht nennenswert über Load 2 hinaus.
Die Kiste hat also nicht mehr allzu viel Reserven, ist aber auch noch nicht überlastet.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

