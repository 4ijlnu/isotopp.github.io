---
author: isotopp
title: "Dynamically loading Classes in Java"
date: "2024-03-03T05:06:07Z"
feature-img: assets/img/background/rijksmuseum.jpg
toc: true
tags:
- lang_en
- computer
- java
---

The son needed to dynamically load some Java class into Minecraft, 
and then call a method on this.
The dynamically loaded class may have additional dependencies.
I wanted to see how this works, so I sketched a quick example.
You can follow along [on GitHub](https://github.com/isotopp/JavaTests).

# Project Layout

Using IntelliJ, we are creating a project using Maven which has three submodules.
The layout:

```console {hl_lines="4 13 22 30"}
$ tree
.
|-- dependent
|   |-- pom.xml    <--- per submodule pom.xml
|   `-- src
|       `-- main
|           `-- java
|               `-- de
|                   `-- koehntopp
|                       `-- java
|                           `-- Dependent.java
|-- external
|   |-- pom.xml    <--- per submodule pom.xml
|   `-- src
|       `-- main
|           `-- java
|               `-- de
|                   `-- koehntopp
|                       `-- java
|                           `-- External.java
|-- main
|   |-- pom.xml    <--- per submodule pom.xml
|   `-- src
|       `-- main
|           `-- java
|               `-- de
|                   `-- koehntopp
|                       `-- java
|                           `-- Main.java
`-- pom.xml   <--- top level pom.xml

22 directories, 8 files
```

The top level `pom.xml` will define the submodules:

```xml {hl_lines="10 18-22"}
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>de.koehntopp.java</groupId>
    <artifactId>JavaTests</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>pom</packaging>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <modules>
        <module>main</module>
        <module>external</module>
        <module>dependent</module>
    </modules>

</project>
```

Each submodule then needs to have its own `pom.xml`, will produce its own `target/` directory with its own `.jar` file.
We are not trying to bundle all these files into one "fat" jar because that was not required.

In order to be able to define submodules, we also need to specify a `<packaging />` method. The default is `jar`, 
but for submodules we need to use `pom`.

# `Dependent.java`

The class `Dependent` is a simple "Hello, world!" style program.
It looks like this:

```java
package de.koehntopp.java;

public class Dependent {
    public static void sayHello() {
        System.out.println("Hello from Dependent!");
    }
}
```

That is, we have a class with a single public, static method `sayHello()` that says hello.
The `pom.xml` for this is default, as generated by IntelliJ.

# `External.java`

The `External` class prints its own "Hello" message, and also calls the static method from `Dependent`.
It looks like this:

```java
package de.koehntopp.java;

public class External {
    public static void main(String[] args) {
        System.out.println("New Hello from External!");
        Dependent.sayHello(); // Ruft die Methode aus der Dependent-Klasse auf
    }
}
```

To compile, we need to declare a dependency in Maven:

```xml {hl_lines="17-23"}
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>de.koehntopp.java</groupId>
    <artifactId>external</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>de.koehntopp.java</groupId>
            <artifactId>dependent</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
    </dependencies>

</project>
```
This gives the compiler knowledge about the class `Dependent` at compile time.

# Dynamically loading code in `Main.java`

The `Main` class loads code dynamically using a `ClassLoader`, then calls the code using reflection.

```java {hl_lines="30 37 39 48-50"}
package de.koehntopp.java;

import java.io.File;
import java.net.URL;
import java.net.URLClassLoader;
import java.security.CodeSource;
import java.security.ProtectionDomain;
import java.util.ArrayList;
import java.util.List;

// $ mvn clean package
// ...
// $ java -jar main/target/main-...jar
//
// Beispiel-Ausgabe:
// file:/Users/kris/IdeaProjects/JavaTests/./dependent/target/dependent-1.0-SNAPSHOT.jar
// file:/Users/kris/IdeaProjects/JavaTests/./external/target/external-1.0-SNAPSHOT.jar
// file:/Users/kris/IdeaProjects/JavaTests/./main/target/main-1.0-SNAPSHOT.jar
// Klasse wurde geladen von: file:/Users/kris/IdeaProjects/JavaTests/target/classes/
// New Hello from External!
// Hello from Dependent!

public class Main {
    public static void main(String[] args) throws Exception {
        // Start-Ordner
        File currentDir = new File(".");

        // Liste der jars, die von searchForJars() gefüllt wird
        List<URL> urls = new ArrayList<>();
        searchForJars(currentDir, urls);

        for (URL url: urls) {
            System.out.println(url);
        }

        // classLoader durchsucht die gefundenen jars in `urls`.
        URLClassLoader classLoader = new URLClassLoader(urls.toArray(new URL[0]), Main.class.getClassLoader());
        // Lade de.joehntopp.java.External
        Class<?> externalClass = Class.forName("de.koehntopp.java.External", true, classLoader);

        // Debug: Wir wollen drucken, von wo die Klasse geladen wurde.
        ProtectionDomain protectionDomain = externalClass.getProtectionDomain();
        CodeSource codeSource = protectionDomain.getCodeSource();
        URL location = (codeSource != null) ? codeSource.getLocation() : null;
        System.out.println("Klasse wurde geladen von: " + location);

        // Aufruf von External.main(String[] args)
        externalClass
                .getMethod("main", String[].class)
                .invoke(null, (Object) new String[]{});
    }

    private static void searchForJars(File dir, List<URL> urls) throws Exception {
        File[] files = dir.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    searchForJars(file, urls); // Rekursiver Aufruf für Unterverzeichnisse
                } else if (file.getName().endsWith(".jar")) {
                    urls.add(file.toURI().toURL());
                }
            }
        }
    }
}
```

To find the `jar` with the `External` class, we start to search for any `jar` file recursively under `"."`.
This is done in `searchForJar(dir, urls)`.

We are using the `dir` directory to list all files in it,
then walk through the found files.
If the current file is a directory, we recursively descend into it.

If the current file has a name ending in `".jar"`, we add it to the `urls` list.

Using the list of jars, we create a `classLoader`.
Using the `classLoader`, we load the requested class as `externalClass`.

We then ask `externalClass` for its `main(String[] args)` method using `getMethod`.
We cannot simply ask for `main`, because a class in Java can have more than one implementation of `main` with different signatures.

The found method is then invoked as static (the first parameter of `.invoke()`, `this`, is `null`).
The second and following parameters are the arguments, here an empty `String[]` cast to `Object`.

## Calling with `java -jar`

To be able to call the `Main` class from its `jar`, we need to add the line
```console
Main-Class: de.koehntopp.java.Main
```
to the `MANIFEST.MF` file of the `jar`.
This is quickly and elegantly done in Maven with

```xml {hl_lines="17-33"}
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>de.koehntopp.java</groupId>
    <artifactId>main</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.3.0</version>
                <configuration>
                    <archive>
                        <manifest>
                            <addClasspath>true</addClasspath>
                            <mainClass>de.koehntopp.java.Main</mainClass>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>
        </plugins>
    </build>
    
</project>
```

# Building and running

We can build this with

```console
$ mvn clean
$ mvn package
```

from the top level directory.

We can then run it with

```console
$ java -jar main/target/main-1.0-SNAPSHOT.jar
file:/Users/kris/IdeaProjects/JavaTests/./dependent/target/dependent-1.0-SNAPSHOT.jar
file:/Users/kris/IdeaProjects/JavaTests/./external/target/external-1.0-SNAPSHOT.jar
file:/Users/kris/IdeaProjects/JavaTests/./main/target/main-1.0-SNAPSHOT.jar
Klasse wurde geladen von: file:/Users/kris/IdeaProjects/JavaTests/./external/target/external-1.0-SNAPSHOT.jar
New Hello from External!
Hello from Dependent!
```

# Debugging the class loading

To better understand what happens, we can run it with 

```console
$ java -verbose:class -jar main/target/main-1.0-SNAPSHOT.jar |grep -v 'shared objects file'
[0.020s][info][class,load] sun.nio.cs.UTF_8$Encoder source: jrt:/java.base
[0.029s][info][class,load] de.koehntopp.java.Main source: file:/Users/kris/IdeaProjects/JavaTests/main/target/main-1.0-SNAPSHOT.jar
file:/Users/kris/IdeaProjects/JavaTests/./dependent/target/dependent-1.0-SNAPSHOT.jar
file:/Users/kris/IdeaProjects/JavaTests/./external/target/external-1.0-SNAPSHOT.jar
file:/Users/kris/IdeaProjects/JavaTests/./main/target/main-1.0-SNAPSHOT.jar
[0.033s][info][class,load] java.net.URLClassLoader$1 source: jrt:/java.base
...
[0.040s][info][class,load] java.io.FilePermissionCollection$$Lambda/0x00000090010435e0 source: java.io.FilePermissionCollection
[0.040s][info][class,load] de.koehntopp.java.External source: file:/Users/kris/IdeaProjects/JavaTests/./external/target/external-1.0-SNAPSHOT.jar
[0.041s][info][class,load] java.lang.invoke.LambdaForm$MH/0x0000009001001800 source: __JVM_LookupDefineClass__
Klasse wurde geladen von: file:/Users/kris/IdeaProjects/JavaTests/./external/target/external-1.0-SNAPSHOT.jar
...
[0.043s][info][class,load] java.lang.invoke.LambdaForm$MH/0x0000009001002c00 source: __JVM_LookupDefineClass__
New Hello from External!
[0.043s][info][class,load] de.koehntopp.java.Dependent source: file:/Users/kris/IdeaProjects/JavaTests/./dependent/target/dependent-1.0-SNAPSHOT.jar
Hello from Dependent!
```

By adding the parameter `-verbose:class` to the java call, we get a list of classes loaded when they are loaded.
We see that only `Main` is loaded initially.
The classloader output is interspersed with our own debugging.

Eventually, `External` is loaded and then run.

Only when `External` instantiates its `Dependent` class to call the static method, `Dependent` is loaded.
We can see that, 
because the class loader debug output referencing the `Dependent` class comes after the `"New Hello from External!"` message. 

# Creating Instances 

It is also possible to create instances, and then call them.
For example, in a plugin loader for Minecraft:

```java 
    try {
        Object obj = pluginClass.newInstance();
        Method method = pluginClass.getMethod("onEnable");
        method.invoke(obj);        
    } catch (...e) {
        e.printStackTrace();        
    }
```

# Summary

In this tiny example, we have created a multi-target Maven project with static dependencies between the subprojects.
We created the main jar with a `Main-Class` property in the manifest to conveniently run the jar.
We are loading and calling `External` from `Main` dynamically,
and we are loading and calling `Dependent` from `External` statically, using a maven dependency.

We could do the class loader dance a second time to load and call `Dependent` dynamically as well,
if we wanted to.

See also:

[Dynamisch geladener Code]({{< relref "2005-10-08-dynamisch-geladener-code.md" >}})
: Article from 2005 in German language, which discusses a similar problem in C.
